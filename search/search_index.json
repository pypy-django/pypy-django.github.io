{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#home","title":"Home","text":""},{"location":"#backend-language","title":"Backend Language","text":"<ul> <li> <p> Python</p> </li> <li> <p> Laravel</p> </li> <li> <p> Go</p> </li> <li> <p> Java</p> </li> </ul> Note <p>Given the increasing prominence of artificial intelligence (AI) and its integration into backend systems, two languages with significant potential for the future of backend development in the AI domain are Python and Golang (Go).</p> <p>Python:</p> <p>Python has already established itself as a dominant language in AI and machine learning (ML) development due to its simplicity, versatility, and extensive libraries like <code>TensorFlow</code>, <code>PyTorch</code>, and <code>scikit-learn</code>. Its ease of use makes it ideal for rapid prototyping and experimentation, while its performance can be enhanced through libraries like <code>NumPy</code> and <code>Cython</code>.</p> <p>Golang (Go):</p> <p>Go is gaining traction in the AI and backend development communities due to its speed, concurrency support, and strong built-in standard library. Go's simplicity and efficiency make it well-suited for building scalable backend systems that handle AI workloads efficiently. Additionally, frameworks like <code>TensorFlow</code> and <code>gorgonia</code> provide Go bindings for AI development.</p> <p>By learning Python and Golang, you'll be well-equipped to tackle backend development tasks in the evolving landscape of AI-driven applications and systems. These languages offer complementary strengths and are likely to remain relevant in the future of AI-powered backend development.</p>"},{"location":"APIs/intro/","title":"Intro","text":"<pre><code># Install Django and Django REST Framework\npipenv install django djangorestframework\n\n\npipenv install django-cors-headers\n</code></pre> settings.py<pre><code>INSTALLED_APPS = [\n    ...\n    'corsheaders',\n    'rest_framework',\n    ...\n]\n\nMIDDLEWARE = [\n    ...\n    'corsheaders.middleware.CorsMiddleware',\n    ...\n]\n\nCORS_ORIGIN_ALLOW_ALL = True  # Allow all origins (or configure specific origins)\n</code></pre>"},{"location":"APIs/intro/#to-master-django-rest-framework-drf-here-are-some-essential-topics-to-explore","title":"To master Django REST Framework (DRF), here are some essential topics to explore:","text":"<p>1. Serializers *</p> <ul> <li> <p>Basic Serializers: Understand how to convert complex data types like querysets and model instances into native Python datatypes that can then be rendered into JSON, XML, or other content types.</p> </li> <li> <p>ModelSerializers: Automate the creation of serializers by mapping Django models directly.</p> </li> <li> <p>Custom Field Validation: Implement custom validation logic within serializers.</p> </li> <li> <p>Nested Serializers: Handle complex data structures by nesting serializers.</p> </li> </ul> <p>2. Views and Viewsets *</p> <ul> <li>APIView: Learn the base class for all DRF views.</li> <li>Generic Views: Utilize generic views for common patterns like listing and retrieving objects.</li> <li>Mixins: Understand how to use mixins to create custom views by combining behaviors.</li> <li>Custom Viewsets: Create custom actions within viewsets, such as <code>@action</code>.</li> </ul> <p>3. Authentication and Permissions *</p> <ul> <li>Authentication: Explore various authentication methods (Basic, Token, Session, OAuth).</li> <li>Custom Authentication: Implement custom authentication classes if needed.</li> <li>Permissions: Understand built-in permissions and create custom permission classes.</li> <li>Object-Level Permissions: Enforce permissions at the object level.</li> </ul> <p>4. Pagination *</p> <ul> <li>Basic Pagination: Implement pagination to manage large querysets.</li> <li>Custom Pagination: Customize pagination behavior according to your needs.</li> </ul> <p>5. Filtering, Ordering, and Search *</p> <ul> <li>Filtering: Use DRF\u2019s filtering backend to filter querysets.</li> <li>Ordering: Enable ordering of results through query parameters.</li> <li>Search: Implement search functionality across fields using <code>SearchFilter</code>.</li> </ul> <p>6. Throttling</p> <ul> <li>Rate Limiting: Limit the rate of requests to your API.</li> <li>Custom Throttling: Implement custom throttling logic.</li> </ul> <p>7. Versioning</p> <ul> <li>API Versioning: Learn how to manage different versions of your API.</li> </ul> <p>8. Content Negotiation</p> <ul> <li>Content Negotiation: Control how your API selects the appropriate media type for the response.</li> </ul> <p>9. Testing</p> <ul> <li>API Testing: Write tests for your API using DRF's testing framework.</li> <li>Test Clients: Use DRF's test clients for simulating requests and verifying responses.</li> </ul> <p>10. Schema Generation and Documentation</p> <ul> <li>OpenAPI/Swagger: Generate API documentation using DRF and tools like Swagger or Redoc.</li> <li>CoreAPI: Learn about CoreAPI, which is used for generating API schemas.</li> </ul> <p>11. Internationalization (i18n)</p> <ul> <li>Localization: Make your API support multiple languages.</li> <li>Translators: Use translators within serializers and views.</li> </ul> <p>12. Performance Optimization</p> <ul> <li>Query Optimization: Use techniques like select_related, prefetch_related, and raw SQL queries.</li> <li>Caching: Implement caching to improve API performance.</li> </ul> <p>13. Advanced Topics</p> <ul> <li>Signals and Webhooks: Integrate with external services through webhooks.</li> <li>Async Views: Explore asynchronous views in DRF.</li> <li>WebSocket Integration: Learn how to integrate WebSockets with Django Channels.</li> </ul> <p>14. Deployment and Security</p> <ul> <li>Security Best Practices: Implement best practices for securing your API.</li> <li>Deployment: Learn how to deploy DRF applications in production environments, including considerations for scaling and performance.</li> </ul> <p>15. Customizing DRF</p> <ul> <li>Custom Routers and URL Patterns: Customize how DRF generates URL patterns.</li> <li>Custom Renderer and Parsers: Define how data is rendered and parsed in your API.</li> </ul> <p>16. Advanced Routing Techniques</p> <ul> <li>Nested Routers: Create nested resources using DRF's routers.</li> <li>Custom URL Converters: Define custom URL path converters for more control over routing.</li> </ul> <p>17. Third-Party Packages</p> <ul> <li>Django-Filter: For complex filtering operations.</li> <li>Django-Guardian: For object-level permissions.</li> <li>Django-Rest-Auth / dj-rest-auth: For authentication flows, including registration and password reset.</li> </ul> <p>Mastering these topics will give you a comprehensive understanding of Django REST Framework and help you build robust and scalable APIs.</p>"},{"location":"APIs/intro/#god-tier-developer","title":"god-tier developer","text":"<p>To become a \"god-tier\" developer in the realm of APIs, you'll want to focus on several key areas to elevate your expertise. Here\u2019s a roadmap to mastering APIs at the highest level:</p> <ol> <li> <p>Deep Understanding of API Fundamentals</p> <ul> <li>Learn REST and GraphQL: Master the most popular API architectures. RESTful APIs are a staple, while GraphQL offers more flexible querying.</li> <li>Understand HTTP Protocol: Know how methods (GET, POST, PUT, DELETE) and status codes work. Deep dive into request and response headers.</li> <li>Authentication &amp; Authorization: Gain expertise in OAuth, JWT, API keys, and other security measures.</li> </ul> </li> <li> <p>Build and Consume APIs</p> <ul> <li>Design Your Own APIs: Practice designing clean, well-documented APIs. Use tools like Swagger/OpenAPI for documentation.</li> <li>Integrate External APIs: Work with popular APIs (e.g., Google Maps, Stripe, Twitter) and understand their nuances.</li> <li>API Development Frameworks: Use frameworks like Express.js (Node.js), Django REST Framework (Python), or Spring Boot (Java) to build APIs efficiently.</li> </ul> </li> <li> <p>Advanced Concepts and Techniques</p> <ul> <li>Rate Limiting &amp; Throttling: Implement and handle rate limits to manage API traffic effectively.</li> <li>Caching Strategies: Learn about caching mechanisms to enhance performance and reduce latency.</li> <li>Versioning: Implement API versioning strategies to maintain backward compatibility.</li> </ul> </li> <li> <p>Testing and Debugging</p> <ul> <li>Automated Testing: Use tools like Postman or Swagger for testing your APIs. Write unit and integration tests.</li> <li>Debugging Skills: Develop strong debugging skills to troubleshoot and resolve API-related issues quickly.</li> </ul> </li> <li> <p>Performance Optimization</p> <ul> <li>Efficient Data Handling: Optimize API responses and manage payload sizes.</li> <li>Asynchronous Processing: Implement asynchronous processing and background tasks where appropriate.</li> </ul> </li> <li> <p>Scalability and Reliability</p> <ul> <li>Microservices Architecture: Understand how to use APIs in a microservices setup for scalability and fault tolerance.</li> <li>Load Balancing and Failover: Implement strategies for load balancing and failover to ensure API reliability and performance.</li> </ul> </li> <li> <p>Security Best Practices</p> <ul> <li>Secure Data Transmission: Use HTTPS and understand data encryption techniques.</li> <li>Input Validation: Implement rigorous input validation to prevent injection attacks and other vulnerabilities.</li> </ul> </li> <li> <p>Documentation and Developer Experience</p> <ul> <li>Excellent Documentation: Write comprehensive and user-friendly API documentation.</li> <li>Developer Support: Provide SDKs or client libraries to facilitate easier integration for users.</li> </ul> </li> <li> <p>Stay Current and Contribute</p> <ul> <li>Follow Industry Trends: Stay updated with the latest API trends, tools, and best practices.</li> <li>Open Source Contributions: Contribute to open-source projects to gain insights from the community and enhance your skills.</li> </ul> </li> <li> <p>Real-World Projects and Networking</p> <ul> <li>Build Projects: Create and maintain real-world projects to apply your skills practically.</li> <li>Join Communities: Participate in developer communities, forums, and conferences to learn from others and share your knowledge.</li> </ul> </li> </ol> <p>By focusing on these areas, you\u2019ll develop a deep, nuanced understanding of APIs, making you a highly skilled and versatile developer.</p>"},{"location":"APIs/core/api-development/","title":"API Development","text":"<p>Becoming a \u201cgod-tier\u201d API developer is an ambitious goal, and achieving it involves a blend of deep technical knowledge, practical experience, and a good understanding of industry best practices.</p> <p>Here\u2019s a structured path you can follow to master API development from basic to advanced levels:</p> <ol> <li> <p>Understand the Basics</p> <ul> <li>Learn the Fundamentals: Understand what APIs are, why they are used, and how they fit into software architecture.</li> <li>HTTP Basics: Master HTTP methods (GET, POST, PUT, DELETE), status codes, and headers.</li> <li>REST Principles: Get familiar with RESTful API design principles and understand concepts like <code>statelessness</code>, <code>resource URIs</code>, and <code>JSON/XML</code> data formats.</li> <li>Basic Authentication: Learn about basic authentication methods (API keys, username/password).</li> </ul> Resources <ul> <li>\"RESTful Web APIs\" by Leonard Richardson and Mike Amundsen</li> <li>Online courses on HTTP and RESTful APIs (Coursera, Udemy)</li> </ul> </li> <li> <p>Learn to Build and Consume APIs</p> <ul> <li>Choose a Language: Start with a popular language for API development (e.g., Python, JavaScript/Node.js, Java, Ruby).</li> <li>Frameworks: Familiarize yourself with frameworks/libraries in your chosen language (e.g., Flask/Django for Python, Express for Node.js, Spring Boot for Java).</li> <li>Build APIs: Practice building simple APIs with CRUD operations.</li> </ul> Resources <ul> <li>Tutorials on using specific frameworks (e.g., Flask tutorials, Express guides)</li> <li>API documentation tools (Swagger/OpenAPI)</li> </ul> </li> <li> <p>Advanced API Design</p> <ul> <li>Authentication &amp; Authorization: Master OAuth2, JWT, and other authentication mechanisms.</li> <li>Versioning: Learn best practices for versioning APIs.</li> <li>Error Handling: Implement robust error handling and logging.</li> <li>Rate Limiting &amp; Throttling: Understand how to control and limit the use of your API.</li> <li>Security Best Practices: Learn about securing APIs (e.g., HTTPS, input validation, and protection against common vulnerabilities like SQL injection and XSS).</li> </ul> Resources <ul> <li>\"API Design Patterns\" by JJ Geewax</li> <li>Online articles and guides on API security and authentication</li> </ul> </li> <li> <p>Testing and Documentation</p> <ul> <li>API Testing: Learn to use tools like Postman for manual testing and libraries like JUnit (Java), Pytest (Python), or Mocha (Node.js) for automated testing.</li> <li>Documentation: Use tools like Swagger/OpenAPI to create comprehensive API documentation. Practice writing clear, concise, and useful documentation.</li> </ul> Resources <ul> <li>Postman documentation and tutorials</li> <li>Swagger/OpenAPI guides</li> </ul> </li> <li> <p>API Performance and Scalability</p> <ul> <li>Optimization: Learn about performance optimization techniques, including caching (e.g., Redis), pagination, and database indexing.</li> <li>Scaling: Understand how to scale APIs horizontally and vertically. Learn about load balancing and microservices architecture.</li> </ul> Resources <ul> <li>\"Designing Data-Intensive Applications\" by Martin Kleppmann</li> <li>Online resources on caching and load balancing</li> </ul> </li> <li> <p>API Management and Governance</p> <ul> <li>API Gateways: Familiarize yourself with API gateways (e.g., Kong, Apigee, AWS API Gateway) for managing traffic and enforcing policies.</li> <li>Monitoring and Analytics: Learn to monitor API performance and usage. Tools like Grafana and ELK stack are useful for this purpose.</li> </ul> Resources <ul> <li>Documentation for API gateway tools</li> <li>Articles and guides on API monitoring</li> </ul> </li> <li> <p>Stay Updated and Contribute</p> <ul> <li>Stay Current: Follow industry news, blogs, and forums to keep up with new trends and technologies in API development.</li> <li>Open Source: Contribute to open-source API projects or libraries to gain experience and network with other developers.</li> </ul> Resources <ul> <li>GitHub for exploring open-source projects</li> <li>Tech blogs and forums (e.g., Stack Overflow, Dev.to)</li> </ul> </li> <li> <p>Build a Portfolio</p> <ul> <li>Showcase Projects: Build and showcase real-world projects. Include detailed documentation and a clear explanation of the design and decisions made.</li> <li>GitHub: Maintain a well-organized GitHub repository with your projects, code samples, and contributions.</li> </ul> Resources <ul> <li>GitHub best practices</li> <li>Portfolio examples from other developers</li> </ul> </li> <li> <p>Seek Feedback and Iterate</p> <ul> <li>Code Reviews: Regularly seek feedback on your code from more experienced developers.</li> <li>Iterate: Continuously improve your skills based on feedback and evolving best practices.</li> </ul> Resources <ul> <li>Peer reviews and mentorship opportunities</li> <li>Online communities and local tech meetups</li> </ul> </li> </ol> <p>By following these steps and continually learning and adapting, you'll be well on your way to becoming an exceptional API developer.</p>"},{"location":"APIs/core/api-development/#advanced-level","title":"Advanced level","text":"<p>Sure! Let\u2019s dive into advanced-level API development topics. At this stage, you\u2019re expected to go beyond basic API creation and focus on optimizing performance, security, scalability, and advanced design considerations.</p> <ol> <li> <p>Advanced API Design</p> <ul> <li> <p>GraphQL: Learn GraphQL for more flexible and efficient queries. Understand how to design and implement a GraphQL schema and resolvers.</p> <ul> <li>Resources: Official GraphQL Documentation, \"Learning GraphQL\" by Eve Porcello and Alex Banks</li> </ul> </li> <li> <p>Hypermedia as the Engine of Application State (HATEOAS): Implement HATEOAS in RESTful APIs to allow clients to navigate your API dynamically.</p> <ul> <li>Resources: \"RESTful Web APIs\" by Leonard Richardson and Mike Amundsen</li> </ul> </li> <li> <p>API Composition and Orchestration: Learn techniques for composing APIs from multiple services, including API aggregation and service orchestration.</p> <ul> <li>Resources: Articles on API composition patterns</li> </ul> </li> </ul> </li> <li> <p>Advanced Security Practices</p> <ul> <li> <p>OAuth2 and OpenID Connect: Master OAuth2 for delegated authorization and OpenID Connect for authentication.</p> <ul> <li>Resources: OAuth 2.0 and OpenID Connect specifications</li> </ul> </li> <li> <p>API Security Best Practices: Implement advanced security measures such as rate limiting, IP whitelisting, and CORS configuration.</p> <ul> <li>Resources: OWASP API Security Top 10, articles on API security best practices</li> </ul> </li> <li> <p>Threat Modeling: Conduct threat modeling to identify potential security risks in your API.</p> <ul> <li>Resources: \"Threat Modeling: Designing for Security\" by Adam Shostack</li> </ul> </li> </ul> </li> <li> <p>Performance Optimization</p> <ul> <li> <p>Caching Strategies: Implement caching strategies using tools like Redis or Memcached to reduce load times and server load.</p> <ul> <li>Resources: Articles and guides on caching strategies and Redis/Memcached documentation</li> </ul> </li> <li> <p>Asynchronous Processing: Use asynchronous processing and messaging queues (e.g., RabbitMQ, Kafka) to handle long-running tasks and improve responsiveness.</p> <ul> <li>Resources: RabbitMQ and Kafka documentation, \"Designing Data-Intensive Applications\" by Martin Kleppmann</li> </ul> </li> <li> <p>Load Testing and Profiling: Perform load testing with tools like JMeter or Gatling and profile your API to identify performance bottlenecks.</p> <ul> <li>Resources: JMeter documentation, articles on API performance profiling</li> </ul> </li> </ul> </li> <li> <p>API Management and Monitoring</p> <ul> <li> <p>API Gateways: Utilize API gateways (e.g., Kong, Apigee, AWS API Gateway) to manage API traffic, apply policies, and enforce security.</p> <ul> <li>Resources: Documentation for API gateways, online tutorials</li> </ul> </li> <li> <p>Analytics and Monitoring: Implement monitoring and logging solutions (e.g., ELK stack, Grafana) to gain insights into API usage and performance.</p> <ul> <li>Resources: ELK stack and Grafana documentation, articles on API monitoring</li> </ul> </li> <li> <p>Rate Limiting and Quotas: Implement and manage rate limiting and quotas to prevent abuse and ensure fair usage.</p> <ul> <li>Resources: Articles and guides on rate limiting strategies</li> </ul> </li> </ul> </li> <li> <p>Microservices and API Architecture</p> <ul> <li> <p>Microservices Design: Understand how to design and implement APIs in a microservices architecture, focusing on inter-service communication and data consistency.</p> <ul> <li>Resources: \"Microservices Patterns\" by Chris Richardson</li> </ul> </li> <li> <p>Service Discovery: Implement service discovery mechanisms to dynamically locate and interact with services.</p> <ul> <li>Resources: Tools like Consul or Eureka, and related documentation</li> </ul> </li> <li> <p>API Versioning Strategies: Implement and manage API versioning strategies to handle backward compatibility and smooth transitions.</p> <ul> <li>Resources: Articles on API versioning patterns and strategies</li> </ul> </li> </ul> </li> <li> <p>Advanced Testing Techniques</p> <ul> <li> <p>Contract Testing: Implement contract testing (e.g., using Pact) to ensure that services adhere to expected contracts.</p> <ul> <li>Resources: \"Pact: Consumer-Driven Contracts\" documentation</li> </ul> </li> <li> <p>Integration and End-to-End Testing: Perform comprehensive integration and end-to-end testing of APIs to ensure they work correctly in real-world scenarios.</p> <ul> <li>Resources: Articles on integration and end-to-end testing frameworks</li> </ul> </li> </ul> </li> <li> <p>DevOps Integration</p> <ul> <li> <p>CI/CD Pipelines: Integrate API development into CI/CD pipelines for automated testing, deployment, and monitoring.</p> <ul> <li>Resources: Articles on CI/CD best practices and tools like Jenkins or GitHub Actions</li> </ul> </li> <li> <p>Containerization and Orchestration: Use Docker for containerization and Kubernetes for orchestration to manage and deploy your APIs efficiently.</p> <ul> <li>Resources: Docker and Kubernetes documentation, online tutorials</li> </ul> </li> </ul> </li> <li> <p>API Evolution and Governance</p> <ul> <li> <p>API Governance: Implement governance practices to maintain consistency and quality across APIs, including style guides and review processes.</p> <ul> <li>Resources: Articles on API governance frameworks</li> </ul> </li> <li> <p>API Evolution: Understand strategies for evolving APIs without disrupting existing clients, including deprecation strategies and backward compatibility.</p> <ul> <li>Resources: Articles and guides on API versioning and evolution strategies</li> </ul> </li> </ul> </li> <li> <p>Real-World Projects and Contributions</p> <ul> <li>Build Complex Projects: Work on complex projects that require integrating multiple services and technologies.</li> <li>Contribute to Open Source: Contribute to or maintain open-source API projects to gain experience and recognition in the community.</li> </ul> <p>Resources:</p> <ul> <li>GitHub for exploring and contributing to projects</li> <li>Open-source API project communities</li> </ul> </li> </ol> <p>By mastering these advanced topics, you'll be well-equipped to handle complex API challenges and design sophisticated, high-performance, and secure APIs.</p>"},{"location":"APIs/core/query-parameters/","title":"Query Paramter","text":"<p>In REST API design, the standard way to include query parameters in a URL is to start with <code>?</code>, not <code>/?</code>.</p>"},{"location":"APIs/core/query-parameters/#standard-query-parameter-syntax","title":"Standard Query Parameter Syntax","text":"<ul> <li> <p>Standard Format: <code>http://example.com/resource?param1=value1&amp;param2=value2</code></p> </li> <li> <p>Explanation:</p> <ul> <li>The <code>?</code> character signifies the beginning of the query string in the URL.</li> <li>Each query parameter is specified as a key-value pair, separated by an <code>=</code> sign.</li> <li>Multiple parameters are separated by an &amp; character.</li> </ul> </li> </ul>"},{"location":"APIs/core/query-parameters/#examples","title":"Examples:","text":"<pre><code>Single Query Parameter:\n    URL: `http://example.com/api/posts?page=2`\n    Here, `page=2` is the query parameter.\n\nMultiple Query Parameters:\n    URL: `http://example.com/api/posts?page=2&amp;sort=asc`\n    Here, `page=2` and `sort=asc` are the query parameters.\n</code></pre> Note on Leading Slash (/) <p>The leading slash (<code>/</code>) in <code>/?page=2</code> is not necessary and is typically not used in standard REST API design. It may appear if the base URL ends with a slash (e.g., <code>http://example.com/api/</code>), but it's not required.</p> Correct URL Pattern <ul> <li>Without Slash: <code>http://example.com/api/posts?page=2</code></li> <li>With Slash (if base URL has a trailing slash): <code>http://example.com/api/posts/?page=2</code></li> </ul> <p>Both are valid, but the key takeaway is that the query parameters should start with ?, and the preceding slash is part of the resource path, not the query string.</p>"},{"location":"APIs/core/query-parameters/#in-summary","title":"In summary:","text":"<ul> <li>Use ? to start query parameters.</li> <li>The / is part of the path, not the query string.</li> </ul>"},{"location":"APIs/core/query-parameters/#question","title":"Question","text":"<p>Django and Django REST Framework (DRF) often use a trailing slash (<code>/</code>) before the query string (<code>?</code>) due to several reasons related to URL routing, RESTful conventions, and the framework's design choices. Here\u2019s an explanation:</p>"},{"location":"APIs/core/query-parameters/#why-django-and-drf-use-trailing-slash","title":"Why Django and DRF Use Trailing Slash (<code>/</code>):","text":"<ol> <li> <p>RESTful Conventions:</p> <ul> <li>By convention, RESTful APIs often use a trailing slash in URLs to indicate a complete resource path. For example, <code>http://example.com/api/posts/</code>is considered the full path to the <code>posts</code> resource.</li> <li>This convention is influenced by the idea that URLs should represent resources or directories. In the same way that a directory path on a filesystem ends with a slash, resource paths in REST APIs often do as well.</li> </ul> </li> <li> <p>Django's <code>APPEND_SLASH</code> Setting:</p> <ul> <li>Django's <code>APPEND_SLASH</code> setting, when set to <code>True</code> (default), automatically appends a slash to URLs that don\u2019t end with one. This behavior ensures consistency in URL patterns and prevents errors related to missing slashes.</li> <li>For example, if you access <code>http://example.com/api/posts</code> (without the trailing slash), Django will redirect to <code>http://example.com/api/posts/</code>.</li> </ul> </li> <li> <p>DRF\u2019s Router Design:</p> <ul> <li>DRF\u2019s routers generate URL patterns that include a trailing slash by default. This aligns with the RESTful design principles and Django\u2019s URL handling.</li> </ul> </li> </ol>"},{"location":"APIs/core/query-parameters/#can-you-remove-the-trailing-slash","title":"Can You Remove the Trailing Slash (/)?","text":"<p>Yes, you can configure Django and DRF to remove the trailing slash before the query string if you prefer. Here\u2019s how you can do it:</p> <ol> <li> <p>Set <code>APPEND_SLASH = False</code>:</p> <p>This setting prevents Django from automatically adding a trailing slash to URLs that don\u2019t have one.</p> <pre><code># settings.py\nAPPEND_SLASH = False\n</code></pre> </li> <li> <p>Use <code>SimpleRouter</code> or Customize <code>DefaultRouter</code>:</p> <p>You can use <code>SimpleRouter</code> from DRF, which does not enforce trailing slashes by default, or create a custom router that removes the trailing slash.</p> <pre><code>from rest_framework.routers import SimpleRouter\n\nrouter = SimpleRouter()\nrouter.register(r'posts', PostViewSet)\n\nurlpatterns = [\n    path('api/', include(router.urls)),\n]\n</code></pre> <p>Alternatively, you can customize the <code>DefaultRouter</code>:</p> <pre><code>from rest_framework.routers import DefaultRouter\n\nclass NoSlashDefaultRouter(DefaultRouter):\n    def __init__(self, *args, **kwargs):\n        self.trailing_slash = ''  # No trailing slash\n        super().__init__(*args, **kwargs)\n\nrouter = NoSlashDefaultRouter()\nrouter.register(r'posts', PostViewSet)\n\nurlpatterns = [\n    path('api/', include(router.urls)),\n]\n</code></pre> </li> <li> <p>Update URL Patterns:</p> <p>Ensure that your URL patterns in urls.py do not end with a slash if you want to remove it.</p> <pre><code>urlpatterns = [\n    path('api/posts', PostViewSet.as_view({'get': 'list'})),  # No trailing slash\n]\n</code></pre> </li> </ol>"},{"location":"APIs/core/query-parameters/#important-considerations","title":"Important Considerations:","text":"<ul> <li>Consistency: If you choose to remove the trailing slash, make sure your entire API and frontend are consistent with this pattern to avoid confusion and routing issues.</li> <li>Redirects: With <code>APPEND_SLASH = False</code>, Django won\u2019t automatically redirect to URLs with a trailing slash, so ensure your URLs are correct.</li> </ul>"},{"location":"APIs/core/query-parameters/#conclusion","title":"Conclusion:","text":"<p>The trailing slash before the query string is a result of RESTful design principles and Django\u2019s default behavior. While it is possible to remove the trailing slash, doing so requires changes to both the <code>APPEND_SLASH</code> setting and potentially your URL routing strategy.</p>"},{"location":"APIs/core/ideas/api-example/","title":"API example","text":""},{"location":"APIs/core/ideas/api-example/#api-example","title":"API Example","text":"<p>Creating a Django CRUD API with pagination and search functionality is a great way to practice both Django and React. Here are some topic ideas for example APIs you can create:</p> <ol> <li> <p>Blog API:</p> <ul> <li> <p>Endpoints:</p> <ul> <li>GET <code>/api/posts/</code> (list posts with pagination and search by title/content)</li> <li>POST <code>/api/posts/</code> (create a new post)</li> <li>GET <code>/api/posts/{id}/</code> (retrieve a specific post)</li> <li>PUT <code>/api/posts/{id}/</code> (update a specific post)</li> <li>DELETE <code>/api/posts/{id}/</code> (delete a specific post)</li> </ul> </li> <li> <p>Fields: <code>id</code>, <code>title</code>, <code>content</code>, <code>author</code>, <code>created_at</code>, <code>updated_at</code></p> </li> </ul> </li> <li> <p>Product Inventory API:</p> <ul> <li> <p>Endpoints:</p> <ul> <li>GET <code>/api/products/</code> (list products with pagination and search by name/description)</li> <li>POST <code>/api/products/</code> (create a new product)</li> <li>GET <code>/api/products/{id}/</code> (retrieve a specific product)</li> <li>PUT <code>/api/products/{id}/</code> (update a specific product)</li> <li>DELETE <code>/api/products/{id}/</code> (delete a specific product)</li> </ul> </li> <li> <p>Fields: <code>`id</code>, <code>name</code>, <code>description</code>, <code>price</code>, <code>stock</code>, <code>created_at</code>, <code>updated_at</code></p> </li> </ul> </li> <li> <p>Library Management API:</p> <ul> <li> <p>Endpoints:</p> <ul> <li>GET <code>/api/books/</code> (list books with pagination and search by title/author)</li> <li>POST <code>/api/books/</code> (create a new book)</li> <li>GET <code>/api/books/{id}/</code> (retrieve a specific book)</li> <li>PUT <code>/api/books/{id}/</code> (update a specific book)</li> <li>DELETE <code>/api/books/{id}/</code> (delete a specific book)</li> </ul> </li> <li> <p>Fields: <code>id</code>, <code>title</code>, <code>author</code>, <code>genre</code>, <code>published_date</code>, <code>isbn</code>, <code>created_at</code>, <code>updated_at</code></p> </li> </ul> </li> <li> <p>User Management API:</p> <ul> <li> <p>Endpoints:</p> <ul> <li>GET <code>/api/users/</code> (list users with pagination and search by username/email)</li> <li>POST <code>/api/users/</code> (create a new user)</li> <li>GET <code>/api/users/{id}/</code> (retrieve a specific user)</li> <li>PUT <code>/api/users/{id}/</code> (update a specific user)</li> <li>DELETE <code>/api/users/{id}/</code> (delete a specific user)</li> </ul> </li> <li> <p>Fields: <code>id</code>, <code>username</code>, <code>email</code>, <code>first_name</code>, <code>last_name</code>, <code>created_at</code>, <code>updated_at</code></p> </li> </ul> </li> <li> <p>Task Management API:</p> <ul> <li> <p>Endpoints:</p> <ul> <li>GET <code>/api/tasks/</code> (list tasks with pagination and search by title/description)</li> <li>POST <code>/api/tasks/</code> (create a new task)</li> <li>GET <code>/api/tasks/{id}/</code> (retrieve a specific task)</li> <li>PUT <code>/api/tasks/{id}/</code> (update a specific task)</li> <li>DELETE <code>/api/tasks/{id}/</code> (delete a specific task)</li> </ul> </li> <li> <p>Fields: <code>id</code>, <code>title</code>, <code>description</code>, <code>status</code>, <code>priority</code>, <code>due_date</code>, <code>created_at</code>, <code>updated_at</code></p> </li> </ul> </li> </ol>"},{"location":"APIs/core/ideas/api-example/#api","title":"API","text":""},{"location":"APIs/core/ideas/api-example/#steps-to-implement","title":"Steps to Implement:","text":"<ol> <li> <p>Django Setup:</p> <ul> <li>Install Django and Django REST Framework.</li> <li>Create a new Django project and app.</li> <li>Define your models.</li> <li>Create serializers for your models.</li> <li>Create viewsets and configure routers.</li> <li>Add pagination and search filters.</li> </ul> </li> <li> <p>Pagination and Search:</p> <ul> <li>Use Django REST Framework's <code>PageNumberPagination</code> or <code>LimitOffsetPagination</code>.</li> <li>Implement search functionality using Django REST Framework's SearchFilter.</li> </ul> </li> <li> <p>React Setup:</p> <ul> <li>Create a new React project using Create React App.</li> <li>Set up routing with React Router.</li> <li>Create components for listing, creating, updating, and deleting records.</li> <li>Use Axios or Fetch API to interact with the Django API.</li> <li>Implement pagination and search in the React frontend.</li> </ul> </li> </ol> Example Code Snippet (Django):<pre><code># models.py\nfrom django.db import models\n\nclass Post(models.Model):\n    title = models.CharField(max_length=100)\n    content = models.TextField()\n    author = models.CharField(max_length=50)\n    created_at = models.DateTimeField(auto_now_add=True)\n    updated_at = models.DateTimeField(auto_now=True)\n\n# serializers.py\nfrom rest_framework import serializers\nfrom .models import Post\n\nclass PostSerializer(serializers.ModelSerializer):\n    class Meta:\n        model = Post\n        fields = '__all__'\n\n# views.py\nfrom rest_framework import viewsets\nfrom rest_framework.pagination import PageNumberPagination\nfrom rest_framework.filters import SearchFilter\nfrom .models import Post\nfrom .serializers import PostSerializer\n\nclass PostPagination(PageNumberPagination):\n    page_size = 10\n\nclass PostViewSet(viewsets.ModelViewSet):\n    queryset = Post.objects.all()\n    serializer_class = PostSerializer\n    pagination_class = PostPagination\n    filter_backends = [SearchFilter]\n    search_fields = ['title', 'content']\n\n# urls.py\nfrom django.urls import path, include\nfrom rest_framework.routers import DefaultRouter\nfrom .views import PostViewSet\n\nrouter = DefaultRouter()\nrouter.register(r'posts', PostViewSet)\n\nurlpatterns = [\n    path('api/', include(router.urls)),\n]\n</code></pre>"},{"location":"APIs/core/ideas/api-example/#using-in-react","title":"Using in React","text":"Example Code Snippet (React):<pre><code>// App.js\nimport React from 'react';\nimport { BrowserRouter as Router, Route, Switch } from 'react-router-dom';\nimport PostList from './components/PostList';\nimport PostDetail from './components/PostDetail';\nimport PostCreate from './components/PostCreate';\nimport PostEdit from './components/PostEdit';\n\nfunction App() {\n  return (\n    &lt;Router&gt;\n      &lt;Switch&gt;\n        &lt;Route exact path=\"/\" component={PostList} /&gt;\n        &lt;Route path=\"/posts/:id\" component={PostDetail} /&gt;\n        &lt;Route path=\"/create\" component={PostCreate} /&gt;\n        &lt;Route path=\"/edit/:id\" component={PostEdit} /&gt;\n      &lt;/Switch&gt;\n    &lt;/Router&gt;\n  );\n}\n\nexport default App;\n</code></pre> <p>You can extend and modify these examples to fit your specific use case.</p>"},{"location":"APIs/core/ideas/backend/","title":"Backend","text":"<p>For building an API for a dating app, you want to choose a framework that supports robust and scalable API development while ensuring security and performance. Given your tech stack of React Native for the frontend and Python for the backend, here's a detailed recommendation for API frameworks you can use:</p> <ol> <li> <p>Django Rest Framework (DRF)</p> <ul> <li> <p>Overview:</p> <ul> <li> <p>Description: Django Rest Framework is a powerful and flexible toolkit for building Web APIs in Django.</p> </li> <li> <p>Pros:</p> <ul> <li>Integrated Features: Includes built-in support for authentication (e.g., JWT, OAuth), serialization, and view sets.</li> <li>Admin Interface: Provides a robust admin interface for managing data.</li> <li>Scalability: Suitable for large applications with complex data structures.</li> <li>Security: Django\u2019s built-in security features are extended to the API layer.</li> </ul> </li> <li> <p>Use Case: Ideal if you are using Django for your backend and need a comprehensive, scalable solution for building RESTful APIs.</p> </li> </ul> </li> </ul> When to Use: <ul> <li>If you need a feature-rich, opinionated framework with strong built-in tools and an admin interface.</li> <li>If you expect to have a complex data model and require robust API management.</li> </ul> </li> <li> <p>Flask with Flask-RESTful</p> <ul> <li> <p>Overview:</p> <ul> <li>Description: Flask is a lightweight Python framework that can be extended with Flask-RESTful to build RESTful APIs.</li> <li>Pros:<ul> <li>Simplicity: Flask provides a minimalistic approach, making it easy to start with and flexible to extend.</li> <li>Flexibility: You can choose your own components (e.g., authentication, database).</li> <li>Performance: Often faster for smaller applications due to its lightweight nature.</li> </ul> </li> <li>Use Case: Ideal if you prefer a modular and flexible framework, or if your API needs are relatively straightforward.</li> </ul> </li> </ul> When to Use: <ul> <li>If you need a lightweight, customizable framework with greater control over components.</li> <li>If you prefer to avoid a more opinionated framework and need a simpler, more modular setup.</li> </ul> </li> <li> <p>FastAPI</p> <ul> <li> <p>Overview:</p> <ul> <li>Description: FastAPI is a modern, fast (high-performance) web framework for building APIs with Python 3.7+ based on standard Python type hints.</li> <li>Pros:<ul> <li>Performance: Known for high performance, comparable to Node.js and Go.</li> <li>Automatic Documentation: Automatically generates interactive API documentation using OpenAPI.</li> <li>Asynchronous Support: Excellent for handling asynchronous operations, such as real-time messaging.</li> </ul> </li> <li>Use Case: Ideal if performance is a critical concern and you want automatic API documentation and asynchronous capabilities.</li> </ul> </li> </ul> When to Use: <ul> <li>If you need high performance and asynchronous support.</li> <li>If you want automatic interactive API documentation with minimal configuration.</li> </ul> </li> </ol>"},{"location":"APIs/core/ideas/backend/#recommendation-summary","title":"Recommendation Summary:","text":"<ul> <li> <p>Django Rest Framework (DRF):</p> <ul> <li>Best for: Comprehensive solutions, feature-rich environments, complex data models.</li> <li>Pros: Built-in admin interface, extensive community support, strong security.</li> </ul> </li> <li> <p>Flask with Flask-RESTful:     Best for: Simplicity and flexibility, modular design.     Pros: Lightweight, customizable, easy to start with.</p> </li> <li> <p>FastAPI:</p> <ul> <li>Best for: High performance, modern asynchronous capabilities.</li> <li>Pros: Fast, automatic API documentation, asynchronous support.</li> </ul> </li> </ul>"},{"location":"APIs/core/ideas/backend/#final-recommendation","title":"Final Recommendation","text":"<ul> <li>For a Feature-Rich and Scalable API: Django Rest Framework (DRF) is recommended if you\u2019re looking for a complete and integrated solution with built-in features.</li> <li>For Flexibility and Simplicity: Flask with Flask-RESTful is ideal if you prefer a minimalistic and modular approach.</li> <li>For High Performance and Modern Features: FastAPI is excellent if you need asynchronous support and high performance.</li> </ul> <p>Your choice will depend on the specific needs of your app, your familiarity with the frameworks, and the complexity of your API requirements. Each of these frameworks has its strengths and is well-suited for building robust APIs.</p> Question <p>For a dating mobile application developed in React Native, you\u2019ll need a backend that can handle user authentication, data storage, real-time communication, and possibly matchmaking algorithms. Python is a solid choice for this due to its simplicity and the availability of powerful frameworks.</p> Here are some Python frameworks that could be a good fit: <ol> <li> <p>Django:</p> <ul> <li>Pros: Django is a high-level framework that comes with a lot of built-in features, including an ORM, user authentication, and admin interface. It\u2019s well-suited for rapid development and can help you build a robust backend quickly.</li> <li>Cons: It can be a bit heavyweight if you don\u2019t need all of its features. The learning curve might be steeper if you're new to Django.</li> </ul> </li> <li> <p>Flask:</p> <ul> <li>Pros: Flask is lightweight and highly flexible, allowing you to use only the components you need. It's great for microservices and APIs and has a large ecosystem of extensions to add functionality as needed.</li> <li>Cons: Unlike Django, Flask doesn\u2019t come with built-in features like user authentication or an ORM, so you might need to implement or integrate these separately.</li> </ul> </li> <li> <p>FastAPI:</p> <ul> <li>Pros: FastAPI is designed for high performance and is easy to use, especially for building APIs. It supports modern features like async programming, which can be beneficial for handling real-time updates in a dating app.</li> <li>Cons: It\u2019s relatively newer compared to Django and Flask, so the ecosystem and community might be smaller, though it's growing rapidly.</li> </ul> </li> <li> <p>Pyramid:</p> <ul> <li>Pros: Pyramid is flexible and allows you to start with a simple setup and scale up as needed. It\u2019s well-suited for building complex applications and can be a good middle-ground between Django and Flask.</li> <li>Cons: Pyramid has a steeper learning curve compared to Flask and doesn\u2019t have as many built-in features as Django.</li> </ul> </li> </ol> Considerations for Choosing a Framework: <ul> <li>Scalability: Choose a framework that can handle your expected load and scale with your application.</li> <li>Community and Support: A larger community can mean more resources, plugins, and third-party tools.</li> <li>Development Speed: Frameworks like Django can speed up development with built-in features, while Flask and FastAPI provide more flexibility.</li> </ul> <p>For a dating app, you\u2019ll likely need to focus on real-time features (like chat), <code>user management</code>, and <code>data security</code>. FastAPI could be particularly appealing due to its performance benefits and ease of creating APIs, which would pair well with a React Native frontend.</p> Integration with React Native: <p>Regardless of the framework you choose, you\u2019ll be working with RESTful APIs or GraphQL to communicate between your React Native app and the backend. Make sure the Python framework you select has good support for building and managing APIs.</p> <p>Feel free to ask more specific questions if you need guidance on any particular aspect!</p>"},{"location":"APIs/core/ideas/ideas/","title":"Intro","text":"dating app <p>Creating a dating app is an exciting challenge, especially given the complexities involved in handling user interactions, data privacy, and real-time communications. As a software engineer, here\u2019s a comprehensive guide to help you through the entire process:</p> <ol> <li> <p>Concept and Planning</p> <ul> <li> <p>Define Unique Value Proposition:</p> <ul> <li>What makes your dating app stand out? Consider features like unique matching algorithms, niche targeting, or enhanced security.</li> </ul> </li> <li> <p>Identify Target Audience:</p> <ul> <li>Define demographics, interests, and location to tailor the app's features and marketing strategy.</li> </ul> </li> <li> <p>Market Research:</p> <ul> <li>Analyze competitors to understand what works and identify gaps in the market.</li> </ul> </li> <li> <p>Feature List:</p> <ul> <li>Core Features: User profiles, matchmaking, messaging, notifications, search filters.</li> <li>Advanced Features: Video calls, AI-based matchmaking, location-based services, event features.</li> <li>Privacy and Security: Enhanced encryption, secure authentication, user data protection.</li> </ul> </li> </ul> </li> <li> <p>Technology Stack</p> <ul> <li> <p>Frontend Development:</p> <ul> <li>Mobile Platforms:<ul> <li>iOS: Swift or Objective-C.</li> <li>Android: Kotlin or Java.</li> <li>Cross-Platform: React Native, Flutter, or Xamarin.</li> </ul> </li> </ul> </li> <li> <p>Backend Development:</p> <ul> <li>Frameworks: Node.js with Express, Django (Python), Ruby on Rails, Spring Boot (Java).</li> <li>Database: PostgreSQL, MySQL, or NoSQL options like MongoDB.</li> </ul> </li> <li> <p>Real-Time Features:</p> <ul> <li>Messaging: Use WebSockets, Firebase Realtime Database, or PubNub.</li> <li>Notifications: Firebase Cloud Messaging (FCM), Apple Push Notification Service (APNs).</li> </ul> </li> <li> <p>Infrastructure:</p> <ul> <li>Cloud Providers: AWS, Google Cloud Platform, or Azure for scalable infrastructure.</li> <li>Containerization: Docker for deploying services.</li> <li>Orchestration: Kubernetes for managing containerized applications.</li> </ul> </li> </ul> </li> <li> <p>Design and User Experience</p> <ul> <li> <p>Wireframing:</p> <ul> <li>Create wireframes to map out the user flow and app layout.</li> </ul> </li> <li> <p>UI/UX Design:</p> <ul> <li>Tools: Figma, Sketch, Adobe XD.</li> <li>Design Principles: Focus on a clean, intuitive design that facilitates user engagement and ease of use.</li> </ul> </li> <li> <p>Prototyping:</p> <ul> <li>Develop interactive prototypes to test user flows and gather feedback.</li> </ul> </li> </ul> </li> <li> <p>Development Process</p> <ul> <li> <p>Frontend Development:</p> <ul> <li>UI Components: Implement user interfaces based on the designs.</li> <li>Integration: Connect with backend services and APIs.</li> </ul> </li> <li> <p>Backend Development:</p> <ul> <li>API Development: Create RESTful APIs or GraphQL endpoints.</li> <li>Authentication: Implement user login/signup, OAuth, JWT for secure sessions.</li> <li>Database Management: Design schema and implement CRUD operations.</li> <li>Matching Algorithms: Develop algorithms for matching users based on preferences and behavior.</li> </ul> </li> <li> <p>Real-Time Communication:</p> <ul> <li>Messaging System: Set up real-time chat functionality.</li> <li>Video Calls: Integrate services like Agora or Twilio for video communication if required.</li> </ul> </li> </ul> </li> <li> <p>Security and Privacy</p> <ul> <li> <p>Data Encryption:</p> <ul> <li>Encrypt data in transit (using HTTPS) and at rest.</li> </ul> </li> <li> <p>Authentication and Authorization:</p> <ul> <li>Use secure methods for user authentication.</li> <li>Implement role-based access control if needed.</li> </ul> </li> <li> <p>Data Privacy:</p> <ul> <li>Ensure compliance with data protection regulations (GDPR, CCPA).</li> <li>Develop clear privacy policies and data handling practices.</li> </ul> </li> <li> <p>User Reporting and Moderation:</p> <ul> <li>Implement features for reporting inappropriate content and users.</li> <li>Consider moderation tools and processes.</li> </ul> </li> </ul> </li> <li> <p>Testing</p> <ul> <li> <p>Unit Testing:</p> <ul> <li>Test individual components and functions.</li> </ul> </li> <li> <p>Integration Testing:</p> <ul> <li>Test interactions between components and services.</li> </ul> </li> <li> <p>UI/UX Testing:</p> <ul> <li>Ensure the app is intuitive and responsive across different devices.</li> </ul> </li> <li> <p>Performance Testing:</p> <ul> <li>Test app performance under various conditions, including high load.</li> </ul> </li> <li> <p>Security Testing:</p> <ul> <li>Conduct vulnerability assessments and penetration testing.</li> </ul> </li> </ul> </li> <li> <p>Deployment and Monitoring</p> <ul> <li> <p>App Store Preparation:</p> <ul> <li>Prepare app store listings with descriptions, screenshots, and marketing materials.</li> <li>Comply with app store guidelines for submission.</li> </ul> </li> <li> <p>Deployment:</p> <ul> <li>iOS: Use Xcode for building and submitting to the App Store.</li> <li>Android: Use Android Studio for building and submitting to Google Play.</li> </ul> </li> <li> <p>Monitoring:</p> <ul> <li>Analytics: Integrate tools like Google Analytics, Firebase Analytics to track user behavior.</li> <li>Error Tracking: Use services like Sentry or Rollbar to monitor and manage app errors.</li> </ul> </li> <li> <p>User Feedback:     Implement mechanisms for collecting user feedback and reviews.</p> </li> </ul> </li> <li> <p>Post-Launch</p> <ul> <li> <p>Marketing and Promotion:</p> <ul> <li>Develop a marketing strategy including social media, partnerships, and ads.</li> <li>Engage with influencers or use PR to increase visibility.</li> </ul> </li> <li> <p>User Support:</p> <ul> <li>Provide customer support through in-app chat, email, or a help center.</li> </ul> </li> <li> <p>Iterative Updates:</p> <ul> <li>Continuously update the app based on user feedback and performance metrics.</li> </ul> </li> </ul> </li> </ol> <p>Summary</p> <ul> <li>Concept and Planning: Define the app\u2019s purpose, target audience, and features.</li> <li>Technology Stack: Choose the right tools and frameworks for development.</li> <li>Design and UX: Focus on intuitive and engaging user interface design.</li> <li>Development Process: Implement frontend and backend, real-time features, and secure data handling.</li> <li>Testing: Ensure thorough testing for functionality, performance, and security.</li> <li>Deployment and Monitoring: Prepare for launch, deploy the app, and set up monitoring tools.</li> <li>Post-Launch: Market the app, provide support, and update based on feedback.</li> </ul> <p>By following this detailed guide, you can systematically approach the development of your dating app and address the various technical and strategic aspects involved.</p> <p>milyo</p>"},{"location":"APIs/drf/drf-roadmap/","title":"Roadmap","text":""},{"location":"APIs/drf/drf-roadmap/#djangorestframework-roadmap","title":"djangorestframework Roadmap","text":"<p>Mastering the Django Rest Framework (DRF) involves a combination of understanding its core concepts, practicing regularly, and building projects that leverage its features. Here's a structured approach to mastering DRF:</p>"},{"location":"APIs/drf/drf-roadmap/#steps-to-master-django-rest-framework","title":"Steps to Master Django Rest Framework","text":"<ol> <li> <p>Learn Django Basics:</p> <ul> <li>Understand Django <code>models</code>, <code>views</code>, <code>templates</code>, and <code>URL routing</code>.</li> <li>Get comfortable with Django's ORM, forms, and admin interface.</li> </ul> </li> <li> <p>Understand RESTful APIs:</p> <ul> <li>Learn about REST principles and HTTP methods (<code>GET</code>, <code>POST</code>, <code>PUT</code>, <code>DELETE</code>).</li> <li>Understand the structure and purpose of RESTful APIs.</li> </ul> </li> <li> <p>Study DRF Documentation:</p> <ul> <li>Read through the official DRF documentation.</li> <li>Pay attention to the tutorial section, which covers the basics comprehensively.</li> </ul> </li> <li> <p>Core Concepts in DRF:</p> <ul> <li>Serializers: Convert complex data types (like <code>Django QuerySets</code>) to native Python datatypes that can then be rendered into JSON, XML, or other content types.</li> <li>Views: Handle requests and return responses, similar to Django views but tailored for API responses.</li> <li>Routers: Simplify URL routing by automatically determining the URL conf for a set of views.</li> <li>Authentication &amp; Permissions: Manage user authentication and permissions for accessing API endpoints.</li> </ul> </li> <li> <p>Build Projects:</p> <ul> <li>Start with simple projects like a blog or a to-do app.</li> <li>Gradually increase complexity by adding features like <code>user authentication</code>, <code>search</code>, and <code>filtering</code>.</li> </ul> </li> <li> <p>Practice Advanced Features:</p> <ul> <li>Viewsets: Combine the logic for handling different HTTP methods (<code>GET</code>, <code>POST</code>, <code>PUT</code>, <code>DELETE</code>) into a single class.</li> <li>Custom Permissions: Create custom permission classes to control access to your API.</li> <li>Throttling: Implement rate limiting for your API.</li> <li>Pagination: Manage large sets of data by breaking them into pages.</li> </ul> </li> <li> <p>Testing:</p> <ul> <li>Write unit tests for your API endpoints.</li> <li>Use tools like pytest and pytest-django for effective testing.</li> </ul> </li> </ol>"},{"location":"APIs/drf/drf-roadmap/#practical-application","title":"Practical Application","text":"<p>Building projects and real-world applications is crucial for mastering DRF. Here are some project ideas:</p> <ul> <li>Blog API: A simple blog with CRUD operations for posts and comments.</li> <li>E-commerce API: An API for managing products, orders, and users.</li> <li>To-Do List API: A task management API with user authentication.</li> </ul> <p>By focusing on these main areas and consistently applying them in practical projects, you'll be well on your way to mastering Django Rest Framework.</p>"},{"location":"APIs/drf/drf-roadmap/#is_valid-and-save-methods","title":"<code>is_valid()</code> and <code>save()</code> Methods","text":"<p>Let's break down when to use is_valid() and save(), which to use first, and how status codes are used in Django REST Framework (DRF).</p>"},{"location":"APIs/drf/drf-roadmap/#is_valid","title":"is_valid()","text":"<ul> <li>Purpose: <code>is_valid()</code> is used to validate the incoming data against the serializer's fields and validation rules.</li> <li>When to use: You call <code>is_valid()</code> before trying to save or use the data in any meaningful way.</li> <li>What it does:</li> <li>Checks if the data passed to the serializer is valid.</li> <li>If the data is invalid, it returns <code>False</code>, and you can access the validation errors via <code>serializer.errors</code>.</li> <li>If valid, it returns <code>True</code>, and the validated data is stored in <code>serializer.validated_data</code>.</li> </ul>"},{"location":"APIs/drf/drf-roadmap/#save","title":"save()","text":"<ul> <li>Purpose: <code>save()</code> is used to create or update an instance of the model with the validated data.</li> <li>When to use: You call <code>save()</code> only after <code>is_valid()</code> has returned <code>True</code>.</li> <li>What it does:</li> <li>If the serializer is associated with a model (like when using <code>ModelSerializer</code>), <code>save()</code> will create or update the instance in the database.</li> <li>It can also be used to apply additional logic through the <code>create()</code> or <code>update()</code> methods if you've overridden them in the serializer.</li> </ul>"},{"location":"APIs/drf/drf-roadmap/#order-of-use","title":"Order of Use","text":"<ul> <li>Call <code>is_valid()</code> first: Validate the data to ensure everything is correct.</li> <li>Call <code>save()</code> next: Save the validated data to the database or use it further in your application logic.</li> </ul> Example<pre><code>serializer = BookModelSerializer(data=request.data)\nif serializer.is_valid():\n    serializer.save()  # Only call save() after is_valid() returns True\n    return Response(serializer.data, status=status.HTTP_201_CREATED)\nelse:\n    return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)\n</code></pre>"},{"location":"APIs/drf/drf-roadmap/#status-codes-in-api-responses","title":"Status Codes in API Responses","text":"<ul> <li> <p>status=status.HTTP_201_CREATED:</p> </li> <li> <p>This status code indicates that a new resource has been successfully created. You should use this status when your API endpoint is responsible for creating new objects (e.g., POST requests to create a new record in the database).</p> </li> <li> <p>Do You Need to Send Status in Every API Request?</p> </li> <li>Yes: It's a best practice to explicitly set the status code in every API response. This makes the response clear and standardized, ensuring that the client understands the outcome of their request.</li> <li>Different status codes for different scenarios:<ul> <li><code>status=status.HTTP_200_OK</code>: General success response, often used for GET requests.</li> <li><code>status=status.HTTP_201_CREATED</code>: Used when a new resource is created (e.g., after a successful POST request).</li> <li><code>status=status.HTTP_204_NO_CONTENT</code>: Used when a resource is successfully deleted.</li> <li><code>status=status.HTTP_400_BAD_REQUEST</code>: Used for validation errors or bad input.</li> <li><code>status=status.HTTP_404_NOT_FOUND</code>: Used when a requested resource is not found.</li> <li><code>status=status.HTTP_500_INTERNAL_SERVER_ERROR</code>: Used when an unexpected error occurs on the server.</li> </ul> </li> </ul> <pre><code>from rest_framework import status\nfrom rest_framework.response import Response\n\ndef create_book(request):\n    serializer = BookModelSerializer(data=request.data)\n    if serializer.is_valid():\n        serializer.save()\n        return Response(serializer.data, status=status.HTTP_201_CREATED)  # New resource created\n    return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)  # Validation error\n</code></pre>"},{"location":"APIs/drf/drf-roadmap/#summary","title":"Summary","text":"<ul> <li>is_valid(): Always use this first to validate incoming data.</li> <li>save(): Use this after <code>is_valid()</code> returns <code>True</code> to save or update the data.   Status Codes: Always explicitly set the status code in your API responses to indicate the result of the request. Different scenarios require different status codes.</li> </ul> <p>Following these practices ensures that your DRF API is robust, clear, and easy to work with for both developers and clients.</p>"},{"location":"APIs/drf/intro/","title":"Intro","text":""},{"location":"APIs/drf/intro/#installation","title":"Installation","text":"bash<pre><code>pip install djangorestframework\npip install markdown       # Markdown support for the browsable API.\npip install django-filter  # Filtering support\n</code></pre> <p>Add <code>rest_framework</code> to your INSTALLED_APPS setting.</p> <p>settings.py</p> <pre><code>INSTALLED_APPS = [\n    ...\n    'rest_framework',\n    ...\n]\n\nREST_FRAMEWORK = {\n    # Use Django's standard `django.contrib.auth` permissions,\n    # or allow read-only access for unauthenticated users.\n    'DEFAULT_PERMISSION_CLASSES': [\n        'rest_framework.permissions.DjangoModelPermissionsOrAnonReadOnly'\n    ]\n}\n</code></pre> <p>If you're intending to use the browsable API you'll probably also want to add REST framework's login and logout views. Add the following to your root <code>urls.py</code> file.</p> <p>urls.py</p> <pre><code>urlpatterns = [\n    ...\n    path('api-auth/', include('rest_framework.urls'))\n]\n</code></pre> <p>Note that the URL path can be whatever you want.</p>"},{"location":"APIs/drf/intro/#what-is-django-rest-framework","title":"What Is Django Rest Framework?","text":"<p>Django Rest Framework (DRF) is a library which works with standard Django models to build a flexible and powerful API for your project.</p>"},{"location":"APIs/drf/intro/#basic-architecture","title":"Basic Architecture","text":"<p>A DRF API is composed of 3 layers: the serializer, the viewset, and the router.</p> <ul> <li> <p>Serializer: converts the information stored in the database and defined by the Django models into a format which is more easily transmitted via an API</p> </li> <li> <p>Viewset: defines the functions (<code>read</code>, <code>create</code>, <code>update</code>, <code>delete</code>) which will be available via the API</p> </li> <li> <p>Router: defines the URLs which will provide access to each viewset</p> </li> </ul> <p></p>"},{"location":"APIs/drf/intro/#serializers","title":"Serializers","text":"<p>Django models intuitively represent data stored in your database, but an API will need to transmit information in a less complex structure. While your data will be represented as instances of your Model classes in your Python code, it needs to be translated into a format like JSON in order to be communicated over an API.</p> <p>The DRF serializer handles this translation. When a user submits information (such as creating a new instance) through the API, the serializer takes the data, validates it, and converts it into something Django can slot into a Model instance. Similarly, when a user accesses information via the API the relevant instances are fed into the serializer, which parses them into a format that can easily be fed out as JSON to the user.</p> <p>The most common form that a DRF serializer will take is one that is tied directly to a Django model:</p> <p>Success</p> <pre><code>class ThingSerializer(serializers.ModelSerializer):\n    class Meta:\n        model = Thing\n        fields = (\u2018name\u2019, )\n</code></pre> <p>Setting <code>fields</code> allows you to specify exactly which fields are accessible using this serializer. Alternatively, <code>exclude</code> can be set instead of <code>fields</code>, which will include all of the model\u2019s fields except those listed in <code>exclude</code>.</p> <p>Serializers are an incredibly flexible and powerful component of DRF. While attaching a serializer to a model is the most common use, serializers can be used to make any kind of Python data structure available via the API according to defined parameters.</p>"},{"location":"APIs/drf/intro/#viewsets","title":"ViewSets","text":"<p>A given serializer will parse information in both directions (reads and writes), but the ViewSet is where the available operations are defined. The most common ViewSet is the ModelViewSet, which has the following built-in operations:</p> <ul> <li>Create an instance: <code>create()</code></li> <li>Retrieve/Read an instance: <code>retrieve()</code></li> <li>Update an instance (all fields or only selected fields): <code>update()</code> or <code>partial_update()</code></li> <li>Destroy/Delete an instance: <code>destroy()</code></li> <li>List instances (paginated by default): <code>list()</code></li> </ul> <p>Each of these associated functions can be overwritten if different behavior is desired, but the standard functionality works with minimal code, as follows:</p> <p>Success</p> <pre><code>class ThingViewSet(viewsets.ModelViewSet):\n    queryset = Thing.objects.all()\n    serializer_class = ThingSerializer\n</code></pre> <p>If you need more customization, you can use generic viewsets instead of the <code>ModelViewSet</code> or even individual custom views.</p>"},{"location":"APIs/drf/intro/#routers","title":"Routers","text":"<p>Finally, the router provides the surface layer of your API. To avoid creating endless \u201clist\u201d, \u201cdetail\u201d and \u201cedit\u201d URLs, the DRF routers bundle all the URLs needed for a given viewset into one line per viewset, like so:</p> <p>Success</p> <pre><code># Initialize the DRF router; only once per urls.py file from rest_framework import routers`\nrouter = routers.DefaultRouter()\n\n# Register the viewset\nrouter.register(r'thing', main_api.ThingViewSet)\n</code></pre> <p>Then, all of the viewsets you registered with the router can be added to the usual <code>url_patterns</code>:</p> Python<pre><code>url_patterns += url(r'^', include(router.urls))\n</code></pre> <p>And you\u2019re up and running! Your API can now be accessed just like any of your other django pages. Next, you\u2019ll want to make sure people can find out how to use it.</p>"},{"location":"APIs/drf/intro/#documentation","title":"Documentation","text":"<p>While all code benefits from good documentation, this is even more crucial for a public-facing API, since APIs can\u2019t be browsed the same way a user interface can. Fortunately, DRF can use the logic of your API code to automatically generate an entire tree of API documentation, with just a single addition to your Django url_patterns:</p> Python<pre><code>url(r'^docs/', include_docs_urls(title='My API')),\n</code></pre>"},{"location":"APIs/drf/intro/#reference","title":"Reference","text":"<ul> <li>django-rest-framework.org</li> <li> <p>basics-django-rest-framework</p> </li> <li> <p>Recommended Blog</p> </li> <li>Basics of Django Rest Framework</li> <li>Single Page Application + REST as an Abstraction:</li> <li>How to Switch to a Custom Django User Model Mid-Project</li> <li>A Guide To Creating An API Endpoint With Django Rest Framework</li> <li>How to Use Django Bulk Inserts for Greater Efficiency</li> <li>Django: Recommended Reading</li> <li>Django vs WordPress: How to Decide?</li> <li>Make ALL Your Django Forms Better</li> <li>Creating Dynamic Forms with Django</li> <li>Add Value To Your Django Project With An API</li> <li>Is Django the Right Fit for your Project?</li> </ul>"},{"location":"APIs/drf/AuthenticationandPermissions/intro/","title":"Intro","text":""},{"location":"APIs/drf/AuthenticationandPermissions/intro/#api-authorization-and-authentication","title":"API authorization and authentication","text":"<p>Authentication is the process of verifying the identity of a user, while authorization is the process of determining whether a user has access to certain resources or operations.</p> <pre><code>$ pipenv install cryptography pyjwt\n</code></pre> <p><code>PyJWT</code> is a Python library that allows us to work with JSON Web Tokens, while <code>cryptography</code> will allow us to verify the tokens\u2019 signatures.</p>"},{"location":"APIs/drf/AuthenticationandPermissions/intro/#understanding-authentication-and-authorization-protocols","title":"Understanding authentication and authorization protocols","text":"<p>When it comes to API authentication, the two most important protocols you need to know are OAuth (Open Authorization) and OpenID Connect (OIDC). </p>"},{"location":"APIs/drf/AuthenticationandPermissions/intro/#reference","title":"Reference","text":"<ul> <li>Microservice APIs by JOS\u00c9 HARO PERALTA</li> </ul>"},{"location":"APIs/drf/Router/DefaultRouter/","title":"Default Router","text":""},{"location":"APIs/drf/Router/DefaultRouter/#defatultrouter","title":"DefatultRouter","text":"<p>The <code>DefaultRouter</code> in Django is specifically designed for use with Django REST Framework (DRF) and is used to generate the URL patterns for your API endpoints automatically. Here's a breakdown of why you need it and where it is used:</p> Purpose of <code>DefaultRouter</code>: <ul> <li> <p>Automatic URL Routing: The <code>DefaultRouter</code> automatically creates the URL patterns for all the actions in your <code>ViewSet</code> (like <code>list</code>, <code>create</code>, <code>retrieve</code>, <code>update</code>, <code>destroy</code>, etc.). This saves you from having to manually define each URL pattern for your API endpoints.</p> </li> <li> <p>API Root View: It also creates a default root view that provides a navigable list of all the registered viewsets in your API. This is particularly useful for browsing your API.</p> </li> </ul> Usage in API vs. Normal Web Views: <ul> <li> <p>API: The <code>DefaultRouter</code> is intended for use in APIs where you're building RESTful services. When you create viewsets (e.g., <code>PostViewSet</code>), the router registers these and maps them to the appropriate URLs.</p> </li> <li> <p>Normal Web Views: For standard web views (e.g., rendering HTML pages), you typically wouldn't use DefaultRouter. Instead, you'd define your URLs manually in a <code>urls.py</code> file using Django's <code>path</code> or <code>re_path</code> functions.</p> </li> </ul>"},{"location":"APIs/drf/Router/DefaultRouter/#example","title":"Example","text":"Example <pre><code>from rest_framework.routers import DefaultRouter\nfrom .views import PostViewSet\n\nrouter = DefaultRouter()\nrouter.register(r'posts', PostViewSet)\n\nurlpatterns = [\n    # Other web view URLs\n    path('admin/', admin.site.urls),\n\n    # Include the API URLs\n    path('api/', include(router.urls)),\n]\n</code></pre> <p>In the example above:</p> <ul> <li>The <code>router</code> is used for the API section (<code>/api/</code>), and it automatically handles the routing for <code>PostViewSet</code>.</li> <li>For other web views, you define URLs manually, as you would in a traditional Django project.</li> </ul> <p>In summary, the DefaultRouter is essential for API routing with DRF, but it's not needed for regular Django web views.</p> When to Use DefaultRouter: <ul> <li>Use in APIs: When you are creating REST APIs with DRF.</li> <li>Not for Standard Views: For normal Django views that render templates or handle non-API requests, you don't need to use <code>DefaultRouter</code>. Instead, use the usual Django URL patterns.</li> </ul>"},{"location":"APIs/drf/Router/DefaultRouter/#question","title":"Question","text":"why we don't use Default Router in Standard Views. or can we use it in Standard Views. what happens if use use it <p>The <code>DefaultRouter</code> in Django REST Framework (DRF) is specifically designed to work with viewsets that manage API endpoints. It automates the process of generating URL patterns for common RESTful operations like listing, creating, updating, and deleting resources. Here's why it's not used for standard views and what happens if you try to use it:</p> <ol> <li> <p>Why DefaultRouter is Not Used for Standard Views:</p> <ul> <li> <p>Designed for APIs: The <code>DefaultRouter</code> is built around the concept of RESTful APIs, which involves actions like <code>list</code>, <code>retrieve</code>, <code>create</code>, <code>update</code>, and <code>delete</code>. These actions map directly to HTTP methods like <code>GET</code>, <code>POST</code>, <code>PUT</code>, and <code>DELETE</code>.</p> </li> <li> <p>Different Use Case: Standard Django views, which typically render HTML templates, handle a broader variety of tasks that aren't strictly tied to these RESTful operations. For example, you might have views for displaying forms, handling file uploads, or rendering complex pages that don't fit neatly into the RESTful paradigm.</p> </li> <li> <p>URL Pattern Generation: <code>DefaultRouter</code> automatically generates URL patterns based on the viewsets, which might not align with the URLs and views you need for standard web applications.</p> </li> </ul> </li> <li> <p>Can You Use DefaultRouter in Standard Views?</p> <ul> <li> <p>Technically Possible, But Not Practical: You can technically include <code>DefaultRouter</code> in your URL configuration, but it will only generate URLs for viewsets that inherit from DRF's ViewSet classes. These viewsets are designed to handle API requests and return JSON responses, not render HTML templates.</p> </li> <li> <p>Limited Utility: If you try to use <code>DefaultRouter</code> with standard Django views (like <code>TemplateView</code>, <code>ListView</code>, <code>DetailView</code>), it won't work because these views don't have the same methods (<code>list</code>, <code>create</code>, etc.) that <code>DefaultRouter</code> expects. As a result, the router won't generate the correct URLs, or it may generate URLs that don't correspond to any views.</p> </li> </ul> </li> <li> <p>What Happens If You Use DefaultRouter with Standard Views:</p> <ul> <li> <p>No URL Generation: The <code>DefaultRouter</code> won't recognize standard Django views, so it won't generate any URLs for them.</p> </li> <li> <p>Potential Errors: If you try to register a standard Django view with the <code>DefaultRouter</code>, you'll likely encounter errors or unexpected behavior because <code>DefaultRouter</code> is not designed to handle the standard view classes.</p> </li> <li> <p>Mismatch in Expected Behavior: Even if you manage to route a request to a standard view using <code>DefaultRouter</code>, the behavior might not be what you expect. For example, API viewsets expect to return serialized data (typically JSON), while standard views are expected to return rendered HTML templates.</p> </li> </ul> </li> <li> <p>Proper Use Case:</p> <ul> <li> <p>Use DefaultRouter for API Endpoints: Stick to using <code>DefaultRouter</code> for DRF viewsets that handle API requests.</p> </li> <li> <p>Use Standard URL Patterns for Web Views: For standard Django views that render templates or handle non-API logic, use Django's traditional <code>path</code>, <code>re_path</code>, or <code>include</code> functions to define your URL patterns.</p> </li> </ul> </li> </ol> example<pre><code># This is the correct way to handle both API and standard views\nfrom django.urls import path, include\nfrom rest_framework.routers import DefaultRouter\nfrom .views import PostViewSet, HomeView\n\nrouter = DefaultRouter()\nrouter.register(r'posts', PostViewSet)\n\nurlpatterns = [\n    # Standard view URLs\n    path('', HomeView.as_view(), name='home'),\n\n    # API URLs\n    path('api/', include(router.urls)),\n]\n</code></pre> <ul> <li>HomeView is a standard Django view, and its URL is defined using <code>path</code>.</li> <li>PostViewSet is a DRF viewset, and its URLs are handled by <code>DefaultRouter</code>.</li> </ul> <p>In summary, <code>DefaultRouter</code> is specialized for APIs and isn't suitable for standard Django views that render HTML or handle other non-API tasks. Using it with standard views would not work as intended and could lead to errors or unexpected behavior.</p>"},{"location":"APIs/drf/Router/intro/","title":"Intro","text":"<p>In Django, particularly when working with Django REST Framework (DRF), there are several built-in router classes that help in automatically generating URL patterns for your API views. The main built-in routers provided by DRF include:</p> <ul> <li> <p> SimpleRouter</p> <p>This is the most basic router, generating routes for list, create, retrieve, update, and destroy actions for your viewsets. It doesn't include any routes for actions like <code>extra actions</code>.</p> <p> Getting started</p> </li> <li> <p> DefaultRouter</p> <p>This router extends <code>SimpleRouter</code> by additionally including a default root view that returns a list of all available API endpoints. This makes it very useful for creating a browsable API interface.</p> <p> Getting started</p> </li> </ul> Which One is the Best? <ul> <li> <p>DefaultRouter: If you want a straightforward setup with a browsable API interface, <code>DefaultRouter</code> is usually the best choice. It includes all the basic routes and a root API view, making it easy to navigate and test your API.</p> </li> <li> <p>SimpleRouter: If you prefer a more minimalistic setup without the root API view, <code>SimpleRouter</code> is a good choice. It\u2019s lighter and doesn\u2019t include the extra view that <code>DefaultRouter</code> provides.</p> </li> <li> <p>Custom Router: If you have very specific routing requirements that aren\u2019t covered by <code>SimpleRouter</code> or <code>DefaultRouter</code>, creating a custom router by subclassing one of these might be the best approach.</p> </li> </ul> <p>In most cases, DefaultRouter is the best option because it offers all the functionality of SimpleRouter plus the additional convenience of a root API view, making your API more user-friendly, especially during development.</p> Example SimpleRouterDefaultRouter<code>Route</code> and <code>DynamicRoute</code>Custom Router <p>The SimpleRouter is the most basic router, generating routes for standard actions (<code>list</code>, <code>create</code>, <code>retrieve</code>, <code>update</code>, and <code>destroy</code>) for your viewsets.</p> <pre><code># views.py\nfrom rest_framework import viewsets\nfrom myapp.models import MyModel\nfrom myapp.serializers import MyModelSerializer\n\nclass MyModelViewSet(viewsets.ModelViewSet):\n    queryset = MyModel.objects.all()\n    serializer_class = MyModelSerializer\n\n# urls.py\nfrom rest_framework.routers import SimpleRouter\nfrom myapp.views import MyModelViewSet\n\nrouter = SimpleRouter()\nrouter.register(r'mymodels', MyModelViewSet)\n\nurlpatterns = router.urls\n</code></pre> <pre><code>Generated Routes:\n\n/mymodels/ (GET, POST)\n/mymodels/{pk}/ (GET, PUT, PATCH, DELETE)\n</code></pre> <p>The <code>DefaultRouter</code> extends <code>SimpleRouter</code> by including a default root API view, which provides a browsable interface listing all the available endpoints.</p> <pre><code># views.py\nfrom rest_framework import viewsets\nfrom myapp.models import MyModel\nfrom myapp.serializers import MyModelSerializer\n\nclass MyModelViewSet(viewsets.ModelViewSet):\n    queryset = MyModel.objects.all()\n    serializer_class = MyModelSerializer\n\n# urls.py\nfrom rest_framework.routers import DefaultRouter\nfrom myapp.views import MyModelViewSet\n\nrouter = DefaultRouter()\nrouter.register(r'mymodels', MyModelViewSet)\n\nurlpatterns = router.urls\n</code></pre> <pre><code>Generated Routes:\n\n/mymodels/ (GET, POST)\n/mymodels/{pk}/ (GET, PUT, PATCH, DELETE)\n/ (root API view)\n</code></pre> <p>These classes are used internally by <code>SimpleRouter</code> and <code>DefaultRouter</code> to define the patterns for the routes. They are typically not used directly but can be subclassed if you need a very customized router.</p> <p>If you need something beyond what <code>SimpleRouter</code> or <code>DefaultRouter</code> offers, you can create a custom router by subclassing SimpleRouter or DefaultRouter.</p> <pre><code>from rest_framework.routers import DefaultRouter\n\nclass CustomRouter(DefaultRouter):\n    # Override methods or add custom route handling here\n    pass\n\nrouter = CustomRouter()\nrouter.register(r'mymodels', MyModelViewSet)\n\nurlpatterns = router.urls\n</code></pre>"},{"location":"APIs/drf/Router/listing-exposed-api/","title":"Listing API Exposed","text":""},{"location":"APIs/drf/Router/listing-exposed-api/#listing-exposed-api-endpoints-with-defaultrouter-in-django-rest-framework","title":"Listing Exposed API Endpoints with DefaultRouter in Django REST Framework\"","text":"<p>When you use the <code>DefaultRouter</code> in Django REST Framework (DRF), it automatically generates API endpoints for the viewsets you register with it. To know which API endpoints are exposed, you can follow these steps:</p> <ol> <li> <p>Use <code>router.urls</code>:</p> <p>After registering your viewsets with the DefaultRouter, you can inspect the urls property of the router to see the list of generated URL patterns.</p> <pre><code>from rest_framework.routers import DefaultRouter\nfrom myapp.views import MyViewSet\n\nrouter = DefaultRouter()\nrouter.register(r'my-viewset', MyViewSet, basename='myviewset')\n\n# Print the list of URLs\nprint(router.urls)\n</code></pre> <p>This will give you an idea of which endpoints are available. The output will be a list of <code>URLPattern</code> objects.</p> </li> <li> <p>Access the API Root Endpoint:</p> <p>By default, <code>DefaultRouter</code> creates an API root endpoint, usually at <code>/</code>. When you visit this endpoint in your browser or using a tool like Postman, it will list all the available endpoints.</p> <pre><code>urlpatterns = [\n    path('', include(router.urls)),\n]\n</code></pre> <p>If you navigate to <code>http://localhost:8000/</code> (or your API's base URL), you'll see a list of all registered endpoints.</p> </li> <li> <p>Check the urls.py Configuration:</p> <p>Ensure that you've included the router in your <code>urls.py</code> file. This is where you can see which viewsets are registered, giving you an idea of the endpoints exposed.</p> <pre><code>from django.urls import path, include\nfrom rest_framework.routers import DefaultRouter\nfrom myapp.views import MyViewSet\n\nrouter = DefaultRouter()\nrouter.register(r'my-viewset', MyViewSet, basename='myviewset')\n\nurlpatterns = [\n    path('', include(router.urls)),\n]\n</code></pre> </li> <li> <p>Use DRF's schema or swagger:</p> <p>If you're using tools like DRF's schema generation (/schema/) or Swagger (drf-yasg), you can generate documentation that lists all the exposed endpoints.</p> <p>Example:</p> <ul> <li>Swagger: Visit the <code>/swagger/</code> endpoint to view a list of all endpoints in a Swagger UI.</li> <li>Schema: Visit <code>/schema/</code> for a raw schema or <code>/redoc/</code> for ReDoc documentation.</li> </ul> </li> <li> <p>Run <code>manage.py show_urls</code>:</p> <p>You can use third-party packages like django-extensions to run a command that shows all registered URLs in your Django application, including those from the <code>DefaultRouter</code>.</p> <pre><code>python manage.py show_urls\n</code></pre> </li> </ol> <p>This will display all the URLs exposed by your application, including the ones managed by DRF's <code>DefaultRouter</code>.</p>"},{"location":"APIs/drf/Router/understanding-basename/","title":"Understanding basename","text":""},{"location":"APIs/drf/Router/understanding-basename/#understanding-and-using-basename-in-django-rest-framework","title":"Understanding and Using <code>basename</code> in Django REST Framework","text":"<p>The <code>basename</code> is specifically used in Django REST Framework (DRF) within the context of routers, particularly when registering <code>viewsets</code> with the router. It helps the router generate the correct names for URL patterns that correspond to the actions in the viewsets.</p> When to Use basename <ul> <li> <p>When you have multiple viewsets for the same model: Use basename to differentiate the URL names for each viewset.</p> </li> <li> <p>When you want custom URL names: Use basename to create more meaningful or specific names for reverse lookups.</p> </li> <li> <p>When your viewset does not have a queryset: Use basename to ensure DRF can generate URL names, as it can't infer the name without a model.</p> </li> </ul>"},{"location":"APIs/drf/Router/understanding-basename/#multiple-viewsets-for-the-same-model","title":"Multiple ViewSets for the Same Model","text":"<p>Suppose you have another viewset that handles books differently, like <code>ArchivedBookViewSet</code>, but it still operates on the same <code>Book</code> model. Here, the <code>basename</code> becomes essential to avoid name conflicts and to distinguish between the viewsets.</p> views.py<pre><code>class ArchivedBookViewSet(viewsets.ModelViewSet):\n    queryset = Book.objects.filter(is_archived=True)\n    serializer_class = BookSerializer\n</code></pre> <p>When you register both viewsets, you need to use different <code>basename</code> values to avoid conflicts and to create meaningful URL names.</p> urls.py<pre><code>router = DefaultRouter()\n\n# Standard books\nrouter.register(r'books', BookViewSet, basename='books')\n# Archived books\nrouter.register(r'archived-books', ArchivedBookViewSet, basename='archivedbooks')\n\nurlpatterns = [\n    path('', include(router.urls)),\n]\n</code></pre> <p>In short, use <code>basename</code> whenever you need to control or customize the URL names generated by DRF, especially in cases with multiple viewsets for the same resource or custom views that don\u2019t directly tie to a model.</p>"},{"location":"APIs/drf/Serializers/basic-serializers/","title":"Basic Serializer","text":""},{"location":"APIs/drf/Serializers/basic-serializers/#basic-serializers","title":"Basic Serializers","text":"<p>Imagine you have a Django model for <code>Book</code> and you want to serialize this data to be returned as JSON through an API endpoint.</p> Models<pre><code>from django.db import models\n\nclass Book(models.Model):\n    title = models.CharField(max_length=100)\n    author = models.CharField(max_length=100)\n    published_year = models.IntegerField()\n</code></pre> Serializers<pre><code>from rest_framework import serializers\nfrom .models import Book\n\nclass BookSerializer(serializers.Serializer):\n    title = serializers.CharField(max_length=100)\n    author = serializers.CharField(max_length=100)\n    published_year = serializers.IntegerField()\n</code></pre> Views<pre><code>from rest_framework.views import APIView\nfrom rest_framework.response import Response\nfrom .models import Book\nfrom .serializers import BookSerializer\n\nclass BookListView(APIView):\n    def get(self, request):\n        books = Book.objects.all()\n        serializer = BookSerializer(books, many=True)\n        return Response(serializer.data)\n</code></pre> URLs<pre><code>from django.urls import path\nfrom .views import BookListView\n\nurlpatterns = [\n    path('books/', BookListView.as_view(), name='book-list'),\n]\n</code></pre>"},{"location":"APIs/drf/Serializers/basic-serializers/#summary","title":"Summary","text":"<ul> <li>Basic Serializers: Used to serialize non-model-based data or when you need complete control over how each field is serialized.</li> </ul>"},{"location":"APIs/drf/Serializers/custom-field-validation/","title":"Custom Field Validation","text":"<p>In Django REST Framework (DRF), you can implement custom validation logic within serializers by using the <code>validate_&lt;field_name&gt;</code> method or the validate method for object-level validation. Here's how you can do it:</p>"},{"location":"APIs/drf/Serializers/custom-field-validation/#1-field-level-validation","title":"1.  Field-Level Validation","text":"<p>Field-level validation is done using the <code>validate_&lt;field_name&gt;</code> method. This method is called when validating the individual field, and it allows you to add custom validation logic specific to that field.</p> <pre><code>from rest_framework import serializers\n\nclass UserSerializer(serializers.Serializer):\n    username = serializers.CharField(max_length=100)\n    email = serializers.EmailField()\n\n    def validate_username(self, value):\n        if \"@\" in value:\n            raise serializers.ValidationError(\"Username should not contain the '@' symbol.\")\n        return value\n</code></pre> <p>In this example, the <code>validate_username</code> method checks if the username contains the \"@\" symbol and raises a <code>ValidationError</code> if it does.</p>"},{"location":"APIs/drf/Serializers/custom-field-validation/#2-object-level-validation","title":"2.  Object-Level Validation","text":"<p>Object-level validation is done using the validate method. This method allows you to validate the entire object as a whole, based on the interrelationship of multiple fields.</p> <pre><code>from rest_framework import serializers\n\nclass UserSerializer(serializers.Serializer):\n    username = serializers.CharField(max_length=100)\n    email = serializers.EmailField()\n    password = serializers.CharField(write_only=True)\n    password_confirm = serializers.CharField(write_only=True)\n\n    def validate(self, data):\n        if data['password'] != data['password_confirm']:\n            raise serializers.ValidationError(\"Passwords do not match.\")\n        return data\n</code></pre> <p>In this example, the <code>validate</code> method checks if the <code>password</code> and <code>password_confirm</code> fields match. If they don't, a <code>ValidationError</code> is raised.</p>"},{"location":"APIs/drf/Serializers/custom-field-validation/#3-using-custom-validators","title":"3. Using Custom Validators","text":"<p>You can also define reusable custom validators by creating standalone functions or classes and passing them to the serializer field.</p> function validatorclass-based validator <pre><code>from rest_framework import serializers\n\ndef validate_no_numbers(value):\n    if any(char.isdigit() for char in value):\n        raise serializers.ValidationError(\"This field should not contain numbers.\")\n    return value\n\nclass UserSerializer(serializers.Serializer):\n    username = serializers.CharField(max_length=100, validators=[validate_no_numbers])\n    email = serializers.EmailField()\n</code></pre> <pre><code>from rest_framework import serializers\n\nclass NoSpecialCharactersValidator:\n    def __call__(self, value):\n        if any(not char.isalnum() for char in value):\n            raise serializers.ValidationError(\"This field should not contain special characters.\")\n        return value\n\nclass UserSerializer(serializers.Serializer):\n    username = serializers.CharField(max_length=100, validators=[NoSpecialCharactersValidator()])\n    email = serializers.EmailField()\n</code></pre> <p>Summary</p> <ul> <li>Field-Level Validation: Use <code>validate_&lt;field_name&gt;</code> for validation specific to a single field.</li> <li>Object-Level Validation: Use the <code>validate</code> method for cross-field validation or when the validation depends on multiple fields.</li> <li>Custom Validators: Create reusable custom validators as functions or classes and apply them to fields.</li> </ul>"},{"location":"APIs/drf/Serializers/custom-field-validation/#example","title":"Example","text":"<p>Suppose you want to ensure that the <code>published_year</code> field cannot be in the future.</p> Serializers<pre><code>class BookModelSerializer(serializers.ModelSerializer):\n    class Meta:\n        model = Book\n        fields = ['id', 'title', 'author', 'published_year']\n\n    def validate_published_year(self, value):\n        if value &gt; 2024:\n            raise serializers.ValidationError(\"The published year cannot be in the future.\")\n        return value\n</code></pre> <p>Now, if someone tries to create or update a book with a <code>published_year</code> beyond 2024, they\u2019ll get a validation error.</p> Views<pre><code>from rest_framework import status\n\nclass BookCreateView(APIView):\n    def post(self, request):\n        serializer = BookModelSerializer(data=request.data)\n        if serializer.is_valid():\n            serializer.save()\n            return Response(serializer.data, status=status.HTTP_201_CREATED)\n        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)\n</code></pre>"},{"location":"APIs/drf/Serializers/custom-field-validation/#question","title":"Question","text":"when to use field-level validation and when to use object level validation <p>Field-level and object-level validation in Django REST Framework (DRF) serve different purposes and are used based on the context of your validation needs. Here\u2019s a guide to help you decide when to use each type of validation:</p> <p>Field-Level Validation</p> Use field-level validation when: <ol> <li> <p>Validation is Specific to a Single Field:</p> <ul> <li>The validation logic pertains only to the data within that particular field. For example, checking if an email address is in a valid format, or if a username contains forbidden characters.</li> </ul> </li> <li> <p>Independent Validation Logic:</p> <ul> <li>The validation does not depend on the values of other fields. For instance, ensuring a string field does not exceed a certain length.</li> </ul> </li> <li> <p>Error Messages are Specific to the Field:</p> <ul> <li>You want to provide detailed and specific error messages related to that particular field. For example, ensuring that a password field meets certain complexity requirements.</li> </ul> </li> </ol> <pre><code>from rest_framework import serializers\n\nclass UserSerializer(serializers.Serializer):\n    username = serializers.CharField(max_length=100)\n\n    def validate_username(self, value):\n        if \"@\" in value:\n            raise serializers.ValidationError(\"Username should not contain the '@' symbol.\")\n        return value\n</code></pre> <p>Object-Level Validation</p> Use object-level validation when: <ol> <li> <p>Validation Depends on Multiple Fields:</p> <ul> <li>The validation logic involves checking the relationship between multiple fields. For example, ensuring that two password fields match, or verifying that a start date is before an end date.</li> </ul> </li> <li> <p>Cross-Field Constraints:</p> <ul> <li>When constraints are based on the combined values of multiple fields. For instance, calculating an age from a date of birth and then validating it.</li> </ul> </li> <li> <p>Complex Validation Logic:</p> <ul> <li>The validation logic is more complex and involves multiple fields or requires accessing the entire object\u2019s data to determine if it meets the criteria.</li> </ul> </li> </ol> <pre><code>from rest_framework import serializers\n\nclass UserSerializer(serializers.Serializer):\n    username = serializers.CharField(max_length=100)\n    password = serializers.CharField(write_only=True)\n    password_confirm = serializers.CharField(write_only=True)\n\n    def validate(self, data):\n        if data['password'] != data['password_confirm']:\n            raise serializers.ValidationError(\"Passwords do not match.\")\n        return data\n</code></pre> <p>Summary</p> <ul> <li>Field-Level Validation: Use this when the validation logic is specific to one field and does not depend on other fields.</li> <li>Object-Level Validation: Use this when the validation needs to consider multiple fields together or when the validation logic involves the entire object\u2019s data.</li> </ul> <p>Choosing the appropriate level of validation ensures that your API data is validated efficiently and accurately, helping to maintain data integrity and provide meaningful feedback to users.</p>"},{"location":"APIs/drf/Serializers/custom-field-validation/#summary","title":"Summary","text":"<ul> <li>Custom Field Validation: Add custom logic to ensure your data meets specific criteria.</li> </ul>"},{"location":"APIs/drf/Serializers/drf-serializers/","title":"Intro","text":""},{"location":"APIs/drf/Serializers/drf-serializers/#serializers","title":"Serializers","text":"<p>Serializers in Django Rest Framework (DRF) are a powerful tool for converting complex data types, such as Django models, into native Python data types that can then be rendered into JSON, XML, or other content types. They are also responsible for <code>deserializing</code> parsed data back into complex types after validating the input. </p> <p>Serializer Types</p> <p>Main Types of Serializers</p> <ul> <li>Serializer</li> <li>ModelSerializer</li> <li>HyperlinkedModelSerializer</li> <li>ListSerializer</li> </ul> <p>Field Types for Relationships</p> <ul> <li>PrimaryKeyRelatedField</li> <li>StringRelatedField</li> <li>SlugRelatedField</li> <li>HyperlinkedRelatedField</li> <li>SerializerMethodField</li> </ul> <p>Here's a breakdown of the basic and advanced concepts of serializers in DRF:</p>"},{"location":"APIs/drf/Serializers/drf-serializers/#basic-concepts-of-serializers","title":"Basic Concepts of Serializers","text":"<ol> <li> <p>Basic Serializer</p> <p>A simple serializer for converting data to and from JSON.</p> <pre><code>from rest_framework import serializers\n\nclass UserSerializer(serializers.Serializer):\n    username = serializers.CharField(max_length=100)\n    email = serializers.EmailField()\n    is_active = serializers.BooleanField()\n\n    def create(self, validated_data):\n        return User.objects.create(**validated_data)\n\n    def update(self, instance, validated_data):\n        instance.username = validated_data.get('username', instance.username)\n        instance.email = validated_data.get('email', instance.email)\n        instance.is_active = validated_data.get('is_active', instance.is_active)\n        instance.save()\n        return instance\n</code></pre> </li> <li> <p>ModelSerializer</p> <p>A serializer that automatically creates fields based on the model fields.</p> <pre><code>from rest_framework import serializers\nfrom myapp.models import User\n\nclass UserModelSerializer(serializers.ModelSerializer):\n    class Meta:\n        model = User\n        fields = ['username', 'email', 'is_active']\n</code></pre> </li> </ol>"},{"location":"APIs/drf/Serializers/drf-serializers/#advanced-concepts-of-serializers","title":"Advanced Concepts of Serializers","text":"<ol> <li> <p>Serializer Fields</p> <p>DRF provides various field types to handle different data types. You can customize fields with arguments such as <code>read_only</code>, <code>write_only</code>, <code>required</code>, <code>default</code>, etc.</p> <pre><code>from rest_framework import serializers\n\nclass UserSerializer(serializers.ModelSerializer):\n    full_name = serializers.CharField(source='get_full_name', read_only=True)\n    age = serializers.IntegerField(required=False, default=0)\n\n    class Meta:\n        model = User\n        fields = ['username', 'email', 'is_active', 'full_name', 'age']\n</code></pre> </li> <li> <p>Custom Validation</p> <p>You can add custom validation methods to handle more complex validation logic.</p> <pre><code>from rest_framework import serializers\n\nclass UserSerializer(serializers.ModelSerializer):\n    class Meta:\n        model = User\n        fields = ['username', 'email', 'is_active']\n\n    def validate_email(self, value):\n        if 'example.com' in value:\n            raise serializers.ValidationError(\"We do not accept emails from 'example.com'.\")\n        return value\n\n    def validate(self, data):\n        if data['username'] == data['email']:\n            raise serializers.ValidationError(\"Username and email cannot be the same.\")\n        return data\n</code></pre> </li> <li> <p>Serializer Methods</p> <p>Add custom methods to include additional data or manipulate data before serialization.</p> <pre><code>class UserSerializer(serializers.ModelSerializer):\n    full_name = serializers.SerializerMethodField()\n\n    class Meta:\n        model = User\n        fields = ['username', 'email', 'is_active', 'full_name']\n\n    def get_full_name(self, obj):\n        return f\"{obj.first_name} {obj.last_name}\"\n</code></pre> </li> <li> <p>Nested Serializers</p> <p>Serializers can include other serializers to handle nested data structures.</p> <pre><code>class ProfileSerializer(serializers.ModelSerializer):\n    class Meta:\n        model = Profile\n        fields = ['bio', 'location']\n\nclass UserSerializer(serializers.ModelSerializer):\n    profile = ProfileSerializer()\n\n    class Meta:\n        model = User\n        fields = ['username', 'email', 'is_active', 'profile']\n</code></pre> </li> <li> <p>Writable Nested Serializers</p> <p>Handle creating or updating nested data by overriding <code>create</code> and <code>update</code> methods.</p> <pre><code>class UserSerializer(serializers.ModelSerializer):\n    profile = ProfileSerializer()\n\n    class Meta:\n        model = User\n        fields = ['username', 'email', 'is_active', 'profile']\n\n    def create(self, validated_data):\n        profile_data = validated_data.pop('profile')\n        user = User.objects.create(**validated_data)\n        Profile.objects.create(user=user, **profile_data)\n        return user\n\n    def update(self, instance, validated_data):\n        profile_data = validated_data.pop('profile')\n        profile = instance.profile\n\n        instance.username = validated_data.get('username', instance.username)\n        instance.email = validated_data.get('email', instance.email)\n        instance.is_active = validated_data.get('is_active', instance.is_active)\n        instance.save()\n\n        profile.bio = profile_data.get('bio', profile.bio)\n        profile.location = profile_data.get('location', profile.location)\n        profile.save()\n\n        return instance\n</code></pre> </li> <li> <p>HyperlinkedModelSerializer</p> <p>A serializer that uses hyperlinks for relationships instead of primary keys.</p> <pre><code>from rest_framework import serializers\nfrom myapp.models import User\n\nclass UserHyperlinkedModelSerializer(serializers.HyperlinkedModelSerializer):\n    class Meta:\n        model = User\n        fields = ['url', 'username', 'email', 'is_active']\n        extra_kwargs = {\n            'url': {'view_name': 'user-detail'}\n        }\n</code></pre> </li> </ol>"},{"location":"APIs/drf/Serializers/drf-serializers/#conclusion","title":"Conclusion","text":"<p>Mastering serializers in DRF involves understanding both the basics and the advanced concepts. Start with basic serializers and gradually move on to more complex features like nested serializers, custom validation, and serializer methods. Practice by building real-world applications and exploring various use cases to deepen your understanding.</p>"},{"location":"APIs/drf/Serializers/drf-serializers/#question","title":"Question","text":""},{"location":"APIs/drf/Serializers/drf-serializers/#validation-in-drf-is-typically-done-in-the-serializerspy","title":"validation in DRF is typically done in the <code>serializers.py</code>","text":"Yes, validation in Django REST Framework (DRF) is typically done in the serializers.py file, and this is the standard way to handle validation. <p>Here's how it works:</p>"},{"location":"APIs/drf/Serializers/drf-serializers/#1-validation-in-serializerspy-the-standard-approach","title":"1.  Validation in serializers.py: The Standard Approach","text":"<ul> <li> <p>Purpose:</p> <ul> <li>Serializers in DRF serve as a layer between the complex data types (like Django model instances) and the Python datatypes that can be easily rendered into JSON or other content types.</li> <li>Including validation logic in the serializer ensures that data conforms to the required format before it's saved to the database.</li> </ul> </li> <li> <p>Types of Validation:</p> <ul> <li>Field-level validation: You can define methods in the serializer named <code>validate_&lt;field_name&gt;</code> to validate individual fields.</li> <li>Object-level validation: You can override the <code>validate()</code> method in the serializer to add validation that involves multiple fields or requires custom logic that spans across the object.</li> </ul> </li> </ul>"},{"location":"APIs/drf/Serializers/drf-serializers/#2-how-is_valid-works-in-views","title":"2.  How <code>is_valid()</code> Works in Views","text":"<p>When you call <code>is_valid()</code> in a view, DRF performs several steps:</p> <ul> <li> <p>Instantiation: When you create a serializer instance with <code>serializer = BookModelSerializer(data=request.data)</code>, DRF initializes the serializer with the incoming data.</p> </li> <li> <p>Validation Process:</p> <ul> <li>Field-level validation: During the validation process, DRF automatically looks for methods named <code>validate_&lt;field_name&gt;</code> (e.g., validate_published_year) in the serializer.</li> <li>Field validation methods: These methods are automatically called for each corresponding field, and the returned value is used as the valid data for that field.</li> <li>Object-level validation: After field-level validation, if there is a <code>validate()</code> method in the serializer, DRF calls this method to perform any additional object-level validation.</li> </ul> </li> <li> <p>Error Collection: If any validation method raises a <code>ValidationError</code>, the error is collected, and <code>is_valid()</code> returns <code>False</code>. You can then access the validation errors via <code>serializer.errors</code>.</p> </li> </ul> Example Workflow: <ol> <li> <p>Request Data: The incoming data is passed to the serializer via serializer = BookModelSerializer(data=request.data).</p> </li> <li> <p><code>is_valid()</code> Call:</p> <ul> <li>When <code>is_valid()</code> is called, DRF triggers the validation process.</li> <li>It checks each field against its corresponding field validation method (e.g., <code>validate_published_year</code>).</li> <li>If there\u2019s a method for a field, it is executed, and the field\u2019s value is validated or transformed as needed.</li> </ul> </li> <li> <p>Validation Methods:</p> <ul> <li>The <code>validate_published_year()</code> method is found and called because the serializer includes a field named <code>published_year</code>.</li> <li>This method checks if the value of <code>published_year</code> is valid according to the custom logic you've defined.</li> </ul> </li> <li> <p>Return:</p> <ul> <li>If all fields pass validation, <code>is_valid()</code> returns <code>True</code>, indicating the data is valid.</li> <li>If any validation fails, <code>is_valid()</code> returns <code>False</code>, and you can check <code>serializer.errors</code> for the specific validation errors.</li> </ul> </li> </ol> Example <pre><code>from rest_framework import serializers\n\nclass BookModelSerializer(serializers.ModelSerializer):\n    class Meta:\n        model = Book\n        fields = ['id', 'title', 'author', 'published_year']\n\n    def validate_published_year(self, value):\n        if value &gt; 2024:\n            raise serializers.ValidationError(\"The published year cannot be in the future.\")\n        return value\n</code></pre> In the View<pre><code>serializer = BookModelSerializer(data=request.data)\nif serializer.is_valid():  # Triggers all validation logic defined in the serializer\n    serializer.save()  # Save the validated data\n    return Response(serializer.data, status=status.HTTP_201_CREATED)\nelse:\n    return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)\n</code></pre>"},{"location":"APIs/drf/Serializers/drf-serializers/#3-why-validation-in-serializers-is-the-standard-way","title":"3.  Why Validation in Serializers is the Standard Way","text":"<ul> <li>Centralized Validation Logic: By placing validation in the serializer, you keep the validation logic close to the data definition, making it - easier to maintain and understand.</li> <li>Reusability: Validation defined in the serializer can be reused across different views or even when working with the serializer outside the context of a view.</li> <li>Separation of Concerns: This approach helps keep your views clean and focused on handling HTTP requests and responses, while the serializer handles the data validation logic.</li> </ul>"},{"location":"APIs/drf/Serializers/drf-serializers/#summary","title":"Summary","text":"<ul> <li>Validation in <code>serializers.py</code> is indeed the standard approach in DRF.</li> <li><code>is_valid()</code> in the view automatically triggers the validation methods (<code>validate_&lt;field_name&gt;</code> and <code>validate()</code>) defined in the serializer.</li> </ul> <p>This approach ensures that data is validated in a consistent, reusable, and maintainable way.</p>"},{"location":"APIs/drf/Serializers/model-serializers/","title":"Model Serializer","text":""},{"location":"APIs/drf/Serializers/model-serializers/#modelserializers","title":"ModelSerializers","text":"<p>To simplify the serialization process, you can use ModelSerializer.</p> Serializers<pre><code>from rest_framework import serializers\nfrom .models import Book\n\nclass BookModelSerializer(serializers.ModelSerializer):\n    class Meta:\n        model = Book\n        fields = ['id', 'title', 'author', 'published_year']\n</code></pre> Views<pre><code>class BookListView(APIView):\n    def get(self, request):\n        books = Book.objects.all()\n        serializer = BookModelSerializer(books, many=True)\n        return Response(serializer.data)\n</code></pre> <p>Now, with <code>ModelSerializer</code>, you don't need to manually define each field as it directly maps to the <code>Book</code> model.</p>"},{"location":"APIs/drf/Serializers/model-serializers/#summary","title":"Summary","text":"<ul> <li>ModelSerializers: Automatically serialize model instances, reducing boilerplate code.</li> </ul>"},{"location":"APIs/drf/Serializers/nested-serializers/","title":"Nested Serializer","text":""},{"location":"APIs/drf/Serializers/nested-serializers/#nested-serializers","title":"Nested Serializers","text":"<p>Consider you have another model <code>Author</code> related to <code>Book</code>. You want to include the author details in the book serialization.</p> Models<pre><code>class Author(models.Model):\n    name = models.CharField(max_length=100)\n    age = models.IntegerField()\n\nclass Book(models.Model):\n    title = models.CharField(max_length=100)\n    author = models.ForeignKey(Author, on_delete=models.CASCADE)\n    published_year = models.IntegerField()\n</code></pre> Serializers<pre><code>class AuthorSerializer(serializers.ModelSerializer):\n    class Meta:\n        model = Author\n        fields = ['id', 'name', 'age']\n\nclass BookWithAuthorSerializer(serializers.ModelSerializer):\n    author = AuthorSerializer()\n\n    class Meta:\n        model = Book\n        fields = ['id', 'title', 'author', 'published_year']\n</code></pre> Views<pre><code>class BookListView(APIView):\n    def get(self, request):\n        books = Book.objects.all()\n        serializer = BookWithAuthorSerializer(books, many=True)\n        return Response(serializer.data)\n</code></pre> URLs<pre><code>from django.urls import path\nfrom .views import BookListView, BookCreateView\n\nurlpatterns = [\n    path('books/', BookListView.as_view(), name='book-list'),\n    path('books/create/', BookCreateView.as_view(), name='book-create'),\n]\n</code></pre>"},{"location":"APIs/drf/Serializers/nested-serializers/#summary","title":"Summary","text":"<ul> <li>Nested Serializers: Serialize related models, allowing you to represent complex relationships in your API.</li> </ul>"},{"location":"APIs/drf/Viewsets/drf-viewsets/","title":"drf viewsets","text":""},{"location":"APIs/drf/Viewsets/drf-viewsets/#djangorestframework","title":"djangorestframework","text":""},{"location":"APIs/drf/Viewsets/drf-viewsets/#drf-views","title":"DRF Views","text":"<p>The essential component of DRF views is the <code>APIView</code> class, which subclasses Django's <code>View</code> class.</p> <p><code>APIView</code> class is a base for all the views that you might choose to use in your DRF application.</p> <p>Whether it be-</p> <ul> <li>function-based views</li> <li>class-based views</li> <li>mixins</li> <li>generic view classes</li> <li>viewsets</li> </ul> <p>they all use the <code>APIView</code> class.</p> <p></p>"},{"location":"APIs/drf/Viewsets/drf-viewsets/#class-based-views","title":"Class-based Views","text":"<p>Class-based views extend the <code>APIView</code> class. With them, you determine how requests will be handled and which policy attributes you're going to use.</p> <pre><code>from rest_framework.response import Response\nfrom rest_framework.views import APIView\n\nclass DeleteAllItems(APIView):\n    def delete(self, request):\n        Item.objects.all().delete()\n        return Response(status=status.HTTP_204_NO_CONTENT)\n</code></pre>"},{"location":"APIs/drf/Viewsets/drf-viewsets/#policy-attributes","title":"Policy Attributes","text":"<p>If you want to override the default settings for your class-based views, you can use <code>policy attributes</code>.</p> <p>In the following example, we changed the permissions and how a response is rendered with the <code>permission_classes</code> and <code>renderer_classes</code> policy attributes: </p><pre><code>from rest_framework.permissions import IsAuthenticated\nfrom rest_framework.renderers import JSONRenderer\nfrom rest_framework.response import Response\nfrom rest_framework.views import APIView\n\nclass ItemsNotDone(APIView):\n\n    permission_classes = [IsAuthenticated]  # policy attribute\n    renderer_classes = [JSONRenderer]       # policy attribute\n\n    def get(self, request):\n\n        user_count = Item.objects.filter(done=False).count()\n        content = {'not_done': user_count}\n\n        return Response(content)\n</code></pre>"},{"location":"APIs/drf/Viewsets/drf-viewsets/#function-based-views","title":"Function-based Views","text":"<p>There are two ways to directly implement <code>APIView</code>: With a function or with a class. If you're writing a view in the form of a function, you'll need to use the <code>@api_view</code> decorator.</p> <p><code>@api_view</code> is a decorator that converts a <code>function-based</code> view into an APIView subclass (thus providing the <code>Response</code> and <code>Request</code> classes). It takes a list of allowed methods for the view as an argument.</p> <pre><code>from rest_framework.decorators import api_view\nfrom rest_framework.response import Response\n\n@api_view(['DELETE'])\ndef delete_all_items(request):\n    Item.objects.all().delete()\n    return Response(status=status.HTTP_200_OK)\n</code></pre>"},{"location":"APIs/drf/Viewsets/drf-viewsets/#policy-decorators","title":"Policy Decorators","text":"<p>If you want to override the default settings for your function-based view, you can use policy decorators. You can use one or multiple of the following</p> <ul> <li><code>@renderer_classes</code></li> <li><code>@parser_classes</code></li> <li><code>@authentication_classes</code></li> <li><code>@throttle_classes</code></li> <li><code>@permission_classes</code></li> </ul> <p>Those decorators correspond to APIView subclasses. Because the <code>@api_view</code> decorator checks if any of the following decorators are used, they need to be added below the <code>api_view</code> decorator.</p> <pre><code>from rest_framework.decorators import api_view, permission_classes, renderer_classes\nfrom rest_framework.permissions import IsAuthenticated\nfrom rest_framework.renderers import JSONRenderer\nfrom rest_framework.response import Response\n\n@api_view(['GET'])\n@permission_classes([IsAuthenticated])  # policy decorator\n@renderer_classes([JSONRenderer])       # policy decorator\ndef items_not_done(request):\n    user_count = Item.objects.filter(done=False).count()\n    content = {'not_done': user_count}\n\n    return Response(content)\n</code></pre>"},{"location":"APIs/drf/Viewsets/drf-viewsets/#viewsets","title":"ViewSets","text":"<p>A ViewSet class is simply a type of <code>class-based View</code>.</p> <p>There are four types of ViewSets, from the most basic to the most powerful:</p> <ol> <li>ViewSet</li> <li>GenericViewSet</li> <li>ReadOnlyModelViewSet</li> <li>ModelViewSet</li> </ol>"},{"location":"APIs/drf/Viewsets/drf-viewsets/#reference","title":"Reference","text":"<ul> <li>Django REST Framework Views - ViewSets</li> <li>viewsets - django-rest-framework.org</li> </ul>"},{"location":"APIs/drf/Viewsets/intro/","title":"Intro","text":"<p>Viewsets are a powerful feature provided by Django REST Framework (DRF), not Django itself. They are part of DRF, a toolkit for building Web APIs in Django.</p>"},{"location":"APIs/drf/Viewsets/intro/#what-are-viewsets","title":"What are Viewsets?","text":"<p>A Viewset is a type of class that allows you to define a set of related views in a single class. Instead of creating separate classes for each HTTP method (e.g., ListAPIView, RetrieveAPIView, CreateAPIView, etc.), you can combine them into one ViewSet class.</p> Why Use Viewsets? <ul> <li> <p>Code Organization: Viewsets help keep your code clean and organized by grouping related actions together.</p> </li> <li> <p>Reduced Redundancy: You don't need to write repetitive code for each action (list, retrieve, create, update, delete).</p> </li> <li> <p>Router Integration: Viewsets work seamlessly with DRF's routers, which can automatically generate the necessary URL patterns for you.</p> </li> </ul>"},{"location":"APIs/drf/Viewsets/intro/#example","title":"Example","text":"<pre><code>from rest_framework import viewsets\nfrom .models import MyModel\nfrom .serializers import MyModelSerializer\n\nclass MyModelViewSet(viewsets.ModelViewSet):\n    queryset = MyModel.objects.all()\n    serializer_class = MyModelSerializer\n</code></pre>"},{"location":"APIs/drf/Viewsets/intro/#types-of-viewsets","title":"Types of Viewsets","text":"<ul> <li>ModelViewSet: Provides default implementations for typical actions (list, create, retrieve, update, partial_update, and destroy) for a Django model.</li> <li>ReadOnlyModelViewSet: Similar to <code>ModelViewSet</code>, but only allows read-only operations (list and retrieve).</li> </ul>"},{"location":"APIs/drf/Viewsets/intro/#integration-with-routers","title":"Integration with Routers","text":"<p>To make use of the viewset, you'll typically register it with a router:</p> <pre><code>from rest_framework.routers import DefaultRouter\nfrom .views import MyModelViewSet\n\nrouter = DefaultRouter()\nrouter.register(r'mymodel', MyModelViewSet)\n\nurlpatterns = router.urls\n</code></pre> <p>This router will automatically generate the following routes:</p> <pre><code>GET /mymodel/ (list)\nGET /mymodel/&lt;pk&gt;/ (retrieve)\nPOST /mymodel/ (create)\nPUT /mymodel/&lt;pk&gt;/ (update)\nPATCH /mymodel/&lt;pk&gt;/ (partial_update)\nDELETE /mymodel/&lt;pk&gt;/ (destroy)\n</code></pre> <p>Conclusion</p> <ul> <li>Viewsets are part of Django REST Framework (DRF), not Django itself.</li> <li>They are used to create a group of related views within a single class.</li> <li>Viewsets are tightly integrated with DRF's routers to automatically generate URL patterns.</li> </ul> <p>So, Viewsets are a DRF class and are specific to DRF, not Django.</p>"},{"location":"APIs/drf/core/api-key-in-public-api/","title":"API Keys in Public API","text":""},{"location":"APIs/drf/core/api-key-in-public-api/#implementing-api-key-authentication-in-django-rest-framework-for-public-apis","title":"Implementing API Key Authentication in Django REST Framework for Public APIs\"","text":"<p>When working with public APIs in Django REST Framework (DRF), using API keys for authentication is a common approach. Below is an example of how you can implement API key authentication in a DRF project.</p>"},{"location":"APIs/drf/core/api-key-in-public-api/#step-1-install-the-required-package","title":"Step 1: Install the Required Package","text":"<p>First, you need to install <code>djangorestframework-api-key</code>, which is a package specifically designed to handle API key authentication.</p> <pre><code>pip install djangorestframework-api-key\n</code></pre>"},{"location":"APIs/drf/core/api-key-in-public-api/#step-2-add-rest_framework_api_key-to-your-installed_apps","title":"Step 2: Add <code>rest_framework_api_key</code> to Your INSTALLED_APPS","text":"<p>In your settings.py, add <code>rest_framework_api_key</code> to the <code>INSTALLED_APPS</code> list:</p> <pre><code>INSTALLED_APPS = [\n    ...\n    'rest_framework',\n    'rest_framework_api_key',\n]\n</code></pre>"},{"location":"APIs/drf/core/api-key-in-public-api/#step-3-create-the-api-key-model","title":"Step 3: Create the API Key Model","text":"<p>Run migrations to create the database tables needed for API keys:</p> <pre><code>python manage.py migrate\n</code></pre>"},{"location":"APIs/drf/core/api-key-in-public-api/#step-4-set-up-api-key-permissions","title":"Step 4: Set Up API Key Permissions","text":"<p>You can now create a view that requires an API key to access. Below is an example using the <code>HasAPIKey</code> permission class provided by <code>djangorestframework-api-key</code>.</p> <pre><code>from rest_framework.views import APIView\nfrom rest_framework.response import Response\nfrom rest_framework_api_key.permissions import HasAPIKey\nfrom rest_framework_api_key.models import APIKey\n\nclass PublicAPIView(APIView):\n    permission_classes = [HasAPIKey]\n\n    def get(self, request):\n        data = {\n            \"message\": \"This is a public API that requires an API key.\"\n        }\n        return Response(data)\n\n# To create an API key, you can do this in a Django shell:\n# from rest_framework_api_key.models import APIKey\n# api_key, key = APIKey.objects.create_key(name=\"my-api-key\")\n# print(\"API Key:\", key)\n</code></pre>"},{"location":"APIs/drf/core/api-key-in-public-api/#step-5-use-the-api-key-in-requests","title":"Step 5: Use the API Key in Requests","text":"<p>When making a request to this API, you will need to include the API key in the <code>Authorization</code> header like this:</p> <pre><code>curl -H \"Authorization: Api-Key your-api-key-here\" https://your-domain.com/api/public/\n</code></pre>"},{"location":"APIs/drf/core/api-key-in-public-api/#step-6-customize-api-key-management-optional","title":"Step 6: Customize API Key Management (Optional)","text":"<p>You can customize the behavior of API keys by overriding the default views or creating your own custom management commands.</p> <p>This example shows the basics of using API keys in a public API in Django REST Framework. You can expand on this by adding expiration dates, scopes, or other custom behaviors to suit your needs.</p>"},{"location":"APIs/drf/core/api-key-in-public-api/#to-find-or-create-api-keys-when-using-djangorestframework-api-key-follow-these-steps","title":"To find or create API keys when using djangorestframework-api-key, follow these steps:","text":""},{"location":"APIs/drf/core/api-key-in-public-api/#creating-api-keys","title":"Creating API Keys","text":"<ol> <li> <p>Django Admin Interface:</p> <ul> <li>Go to the Django admin interface (e.g., <code>http://localhost:8000/admin</code>).</li> <li>Look for the <code>API Keys</code> section under the <code>REST Framework API Key</code> model.</li> <li>Here, you can create a new API key by clicking the \u201cAdd API Key\u201d button. You\u2019ll be able to name the key and the system will generate a unique key value for you.</li> </ul> </li> <li> <p>Django Shell:</p> <ul> <li> <p>You can also create API keys using the Django shell. Open the Django shell with:</p> <pre><code>python manage.py shell\n</code></pre> </li> <li> <p>Create an API key using the following code:</p> <pre><code>from rest_framework_api_key.models import APIKey\n\n# Create a new API key\napi_key, key = APIKey.objects.create_key(name=\"my-api-key\")\nprint(\"API Key:\", key)\n</code></pre> </li> </ul> </li> </ol>"},{"location":"APIs/drf/core/api-key-in-public-api/#finding-existing-api-keys","title":"Finding Existing API Keys","text":"<ol> <li> <p>Django Admin Interface:</p> <ul> <li>In the Django admin interface, navigate to the API Keys section. You can view a list of all API keys here. The key values themselves are usually not shown for security reasons, but you can manage and revoke them from this interface.</li> </ul> </li> <li> <p>Django Shell:</p> <ul> <li> <p>You can retrieve existing API keys using the Django shell. For example:</p> <pre><code>from rest_framework_api_key.models import APIKey\n\n# List all API keys\nkeys = APIKey.objects.all()\nfor key in keys:\n    print(f\"Name: {key.name}, Key: {key.key}\")\n</code></pre> </li> </ul> <p>Note: Be cautious when printing or displaying API keys as they are sensitive information.</p> </li> </ol> Important Security Note <p>Always keep your API keys secure and avoid exposing them publicly. Only share them with trusted parties and ensure they are transmitted securely (e.g., over HTTPS).</p>"},{"location":"APIs/drf/core/api-key-in-public-api/#rotate-api-keys","title":"Rotate API Keys","text":"<p>To rotate API keys, you need to replace old keys with new ones while ensuring that your system remains functional and secure. Here\u2019s a step-by-step guide on how to handle API key rotation in Django:</p> <ol> <li> <p>Generate a New API Key</p> <p>You first need to generate a new API key. This can be done through the Django admin interface, Django shell, or programmatically via code.</p> Django Admin Interface: <ul> <li>Go to the Django admin interface.</li> <li>Navigate to the API Keys section.</li> <li>Add a new API key by creating a new entry.</li> </ul> Django Shell:<pre><code>from rest_framework_api_key.models import APIKey\n\n# Create a new API key\napi_key, new_key = APIKey.objects.create_key(name=\"new-api-key\")\nprint(\"New API Key:\", new_key)\n</code></pre> <p>Programmatically:</p> <p>You can also add code to your application that creates a new API key.</p> </li> <li> <p>Update Your Application to Use the New Key</p> <p>Once you have a new key, you need to update your application or any external services to use the new API key.</p> <ul> <li>For Your Application: Update configuration files, environment variables, or any other places where the API key is used.</li> <li>For External Services: If you have integrations or third-party services using the old key, update their configurations with the new key.</li> </ul> </li> <li> <p>Test the New Key</p> <p>Before revoking the old key, ensure that the new key works correctly. Test your application thoroughly to confirm that everything functions as expected with the new key.</p> </li> <li> <p>Revoke the Old API Key</p> <p>Once you have verified that the new key is working and all necessary updates have been made, you can revoke the old API key.</p> Django Admin Interface: <ul> <li>Go to the <code>API Keys</code> section in the Django admin interface.</li> <li>Find the old API key and delete it.</li> </ul> <pre><code>from rest_framework_api_key.models import APIKey\n\n# Find and delete the old API key\nold_key = APIKey.objects.get(name=\"old-api-key\")\nold_key.delete()\n</code></pre> </li> <li> <p>Monitor and Validate</p> <p>After rotating the API key, monitor your application to ensure that there are no issues. Keep an eye on logs and error reports to catch any potential issues that might arise from the key rotation.</p> </li> </ol> Automation and Best Practices <ul> <li>Automation: Consider automating API key rotation if possible, especially if you have multiple keys or high-security requirements. This can be done using scripts or integration with CI/CD pipelines.</li> <li>Documentation: Keep documentation up to date with information on how API keys are rotated and managed.</li> <li>Security: Regularly review your API key management practices to ensure they meet security standards.</li> </ul> <p>By following these steps, you can effectively manage and rotate API keys in your Django application, helping to maintain security and minimize disruption.</p>"},{"location":"APIs/drf/core/api-key-in-public-api/#how-often-to-rotate-api-keys","title":"How Often to Rotate API Keys","text":"Rotation Frequency: <ul> <li> <p>Security Policy: The frequency of API key rotation depends on your organization\u2019s security policy and the sensitivity of the data or services the API key provides access to. Common practices are:</p> <ul> <li>Quarterly: For high-security environments.</li> <li>Annually: For lower-risk applications.</li> <li>After Security Incidents: Immediately after a suspected breach or compromise.</li> </ul> </li> <li> <p>Regulatory Requirements: Certain industries or regulatory standards may mandate specific key rotation schedules.</p> </li> </ul>"},{"location":"APIs/drf/core/api-key-in-public-api/#automating-api-key-rotation","title":"Automating API Key Rotation","text":"<p>Automating API key rotation involves setting up processes to generate, deploy, and revoke keys without manual intervention. Here\u2019s a general approach to automate the process:</p> <ol> <li> <p>Script for Key Management</p> <p>Create scripts to automate key creation, updating, and deletion. Below is an example of how you might script this in Python using Django\u2019s ORM:</p> <pre><code># rotate_api_keys.py\n\nimport os\nfrom django.core.management.base import BaseCommand\nfrom rest_framework_api_key.models import APIKey\n\nclass Command(BaseCommand):\n    help = 'Rotate API keys'\n\n    def handle(self, *args, **kwargs):\n        # Generate a new API key\n        api_key, new_key = APIKey.objects.create_key(name=\"new-api-key\")\n        print(f\"New API Key: {new_key}\")\n\n        # Revoke old API key (example, replace with actual logic)\n        old_key_name = os.getenv('OLD_API_KEY_NAME', 'old-api-key')\n        try:\n            old_key = APIKey.objects.get(name=old_key_name)\n            old_key.delete()\n            print(f\"Old API Key ({old_key_name}) revoked.\")\n        except APIKey.DoesNotExist:\n            print(f\"Old API Key ({old_key_name}) not found.\")\n</code></pre> </li> <li> <p>Update Configuration Automatically</p> <ul> <li> <p>Environment Variables: Update environment variables or configuration files that store the API key. This can be done by scripting or using a configuration management tool like Ansible, Chef, or Puppet.</p> </li> <li> <p>Deployment Pipelines: Integrate the script into your CI/CD pipeline. For example, use Jenkins, GitLab CI, or GitHub Actions to trigger the script as part of your deployment process.</p> </li> </ul> </li> <li> <p>Scheduled Rotation</p> <p>Use a scheduling tool to automate the key rotation script:</p> <ul> <li> <p>Cron Jobs: Set up a cron job on your server to run the script at regular intervals.</p> <pre><code># Open crontab\ncrontab -e\n\n# Add a line to schedule the script\n0 0 1 * * /path/to/your/manage.py rotate_api_keys\n</code></pre> </li> <li> <p>Cloud Scheduler: If you\u2019re using a cloud provider, you can use their scheduling services. For example, AWS Lambda with CloudWatch Events or Google Cloud Functions with Cloud Scheduler.</p> </li> </ul> </li> <li> <p>Notify and Log</p> <ul> <li> <p>Notifications: Send notifications when keys are rotated to alert relevant teams. You can use email, Slack, or other communication tools.</p> </li> <li> <p>Logging: Keep logs of key creation and deletion events for auditing and troubleshooting purposes.</p> </li> </ul> </li> <li> <p>Testing and Validation</p> <ul> <li> <p>Test Automation: Implement automated tests to ensure that key rotation does not break your application. This includes integration tests that verify the application works with the new key.</p> </li> <li> <p>Validation: Regularly validate your key rotation process to ensure it functions correctly and securely.</p> </li> </ul> </li> </ol>"},{"location":"APIs/drf/core/api-key-in-public-api/#summary","title":"Summary","text":"<p>Automating API key rotation involves creating scripts for key management, integrating these scripts into your CI/CD pipelines, scheduling key rotation tasks, and ensuring proper notification and logging. The frequency of rotation depends on security needs and policy requirements. Regularly review and test your automation to maintain security and functionality.</p>"},{"location":"APIs/drf/core/bulk-insert-api/","title":"Bulk Insert APIs","text":"<p>Yes, you can send all the data inside an array in a single POST request to a Django REST Framework (DRF) API or save it to the database in a single batch. </p>"},{"location":"APIs/drf/core/bulk-insert-api/#optimizing-data-management-in-django-and-drf-bulk-insertion-and-standalone-api-interactions","title":"\"Optimizing Data Management in Django and DRF: Bulk Insertion and Standalone API Interactions\"","text":"<p>The code for posting data to a Django REST Framework (DRF) API or saving data to a Django database can be used in different contexts. I'll explain where and how you can use these snippets:</p>"},{"location":"APIs/drf/core/bulk-insert-api/#1-inside-djangodrf-api","title":"1. Inside Django/DRF API","text":"<p>If you're working within a Django project (which includes DRF), you typically use the Django ORM to interact with the database. This means you would use the Django code snippet (<code>bulk_create()</code>) within your Django project, such as in a management command, view, or signal.</p> Example: Using <code>bulk_create()</code> in a Django Management Command <p>You can create a management command that inserts data into your database:</p> <ol> <li> <p>Create a management command:</p> <p>In your Django app (e.g., <code>blog</code>), create the following directory structure if it doesn't already exist:</p> <pre><code>blog/\nmanagement/\n    __init__.py\n    commands/\n        __init__.py\n        insert_posts.py\n</code></pre> </li> <li> <p>Write the management command code:</p> <p>In <code>insert_posts.py</code>, write the following code:</p> <pre><code>from django.core.management.base import BaseCommand\nfrom blog.models import Post\nfrom datetime import datetime\n\nclass Command(BaseCommand):\n    help = 'Insert sample posts into the database'\n\n    def handle(self, *args, **kwargs):\n        data = [\n            {\n                \"title\": \"Exploring the Wonders of Asia\",\n                \"content\": \"Asia offers a wide range of experiences, from the bustling streets of Tokyo to the serene temples of Bali.\",\n                \"author\": \"Travel Blogger Chris Lee\",\n                \"created_at\": \"2024-08-09T07:10:20.123456Z\",\n                \"updated_at\": \"2024-08-09T07:10:20.123456Z\"\n            },\n            {\n                \"title\": \"The Ultimate Guide to Solo Travel\",\n                \"content\": \"Solo travel can be empowering and liberating. Here's how to make the most of your solo adventures.\",\n                \"author\": \"Travel Blogger Jamie Smith\",\n                \"created_at\": \"2024-08-08T06:15:30.654321Z\",\n                \"updated_at\": \"2024-08-08T06:15:30.654321Z\"\n            },\n            # Add other post objects here...\n        ]\n\n        posts = []\n        for item in data:\n            created_at = datetime.fromisoformat(item['created_at'].replace(\"Z\", \"+00:00\"))\n            updated_at = datetime.fromisoformat(item['updated_at'].replace(\"Z\", \"+00:00\"))\n\n            post = Post(\n                title=item[\"title\"],\n                content=item[\"content\"],\n                author=item[\"author\"],\n                created_at=created_at,\n                updated_at=updated_at\n            )\n            posts.append(post)\n\n        Post.objects.bulk_create(posts)\n        self.stdout.write(self.style.SUCCESS(f\"{len(posts)} posts saved successfully!\"))\n</code></pre> </li> <li> <p>Run the management command:</p> <p>You can run this command using:</p> <pre><code>python manage.py insert_posts\n</code></pre> </li> </ol>"},{"location":"APIs/drf/core/bulk-insert-api/#2-standalone-python-code","title":"2. Standalone Python Code","text":"<p>If you want to send data to your Django/DRF API from an external or standalone script (outside of the Django project), you would use the requests library to interact with the API.</p> Example: Posting Data to DRF API from a Standalone Script <ol> <li> <p>Standalone script:</p> <p>Create a new Python file, e.g., <code>post_data.py</code>, and add the following code:</p> <pre><code>import requests\n\n# Replace with your DRF API endpoint\nurl = \"http://localhost:8000/api/posts/\"\n\ndata = [\n    {\n        \"title\": \"Exploring the Wonders of Asia\",\n        \"content\": \"Asia offers a wide range of experiences, from the bustling streets of Tokyo to the serene temples of Bali.\",\n        \"author\": \"Travel Blogger Chris Lee\",\n        \"created_at\": \"2024-08-09T07:10:20.123456Z\",\n        \"updated_at\": \"2024-08-09T07:10:20.123456Z\"\n    },\n    {\n        \"title\": \"The Ultimate Guide to Solo Travel\",\n        \"content\": \"Solo travel can be empowering and liberating. Here's how to make the most of your solo adventures.\",\n        \"author\": \"Travel Blogger Jamie Smith\",\n        \"created_at\": \"2024-08-08T06:15:30.654321Z\",\n        \"updated_at\": \"2024-08-08T06:15:30.654321Z\"\n    },\n    # Add other post objects here...\n]\n\nresponse = requests.post(url, json=data)\n\nprint(response.status_code)\nprint(response.json())\n</code></pre> </li> <li> <p>Run the script:</p> <p>You can execute this script from your terminal:</p> <pre><code>python post_data.py\n</code></pre> </li> </ol>"},{"location":"APIs/drf/core/bulk-insert-api/#summary","title":"Summary:","text":"<ul> <li> <p>Django/DRF Project: Use <code>bulk_create()</code> or other Django ORM methods within your Django project to insert data into the database.</p> </li> <li> <p>Standalone Script: Use the <code>requests</code> library in an external Python script to send data to your DRF API.</p> </li> </ul> <p>This approach allows flexibility depending on whether you're working within Django or interacting with your API externally.</p>"},{"location":"APIs/drf/core/bulk-insert-api/#other-tips-and-tricks-in-django-and-drf","title":"Other Tips and Tricks in Django and DRF:","text":"<ol> <li> <p>Use <code>select_related</code> and <code>prefetch_related</code> for Query Optimization:</p> <ul> <li>select_related: Use this when you want to follow foreign-key relationships in a single database query, reducing the number of queries.</li> <li>prefetch_related: Use this when you need to follow many-to-many or reverse foreign-key relationships, optimizing by batching queries.</li> </ul> </li> <li> <p>Using <code>bulk_update</code> for Efficient Batch Updates:</p> <ul> <li>Like <code>bulk_create</code>, <code>bulk_update</code> allows you to update multiple records at once, reducing the number of database queries.</li> </ul> </li> <li> <p>Signal Handling for Automatic Data Processing:</p> <ul> <li>Use Django signals (like <code>post_save</code>, <code>pre_delete</code>) to automate tasks such as logging, sending notifications, or updating related models whenever certain actions occur on your models.</li> </ul> </li> <li> <p>Custom Management Commands:</p> <ul> <li>Create custom management commands to automate repetitive tasks, such as importing/exporting data, cleaning up old records, or sending scheduled reports.</li> </ul> </li> <li> <p>Caching with <code>django-cache</code>:</p> <ul> <li>Implement caching mechanisms for expensive queries or views using Django\u2019s caching framework. This can drastically improve the performance of frequently accessed resources.</li> </ul> </li> <li> <p>Custom QuerySets and Managers:</p> <ul> <li>Define custom methods in your model managers to encapsulate complex queries or frequently used filters. This keeps your code DRY and improves readability.</li> </ul> </li> <li> <p>DRF ViewSets and Routers:</p> <ul> <li>Use <code>ViewSets</code> and <code>Routers</code> to automatically generate CRUD operations for your models, simplifying your API views and making your code more maintainable.</li> </ul> </li> <li> <p>Using <code>serializer.save()</code> with <code>validated_data</code>:</p> <ul> <li>Override <code>serializer.save()</code> to customize the behavior of data saving, such as handling nested objects, modifying data before saving, or calling additional methods.</li> </ul> </li> <li> <p>Throttling and Rate-Limiting in DRF:</p> <ul> <li>Implement throttling to prevent abuse of your API by limiting the number of requests a user can make in a certain timeframe.</li> </ul> </li> <li> <p>API Versioning in DRF:</p> <ul> <li>Use DRF\u2019s built-in versioning schemes to manage changes in your API without breaking existing clients.</li> </ul> </li> </ol> <p>These tips and tricks can help you write more efficient, maintainable, and scalable applications with Django and DRF.</p>"},{"location":"APIs/drf/core/documenting-restapi/","title":"Documenting REST APIs","text":""},{"location":"APIs/drf/core/documenting-restapi/#documenting-rest-apis-with-openapi","title":"Documenting REST APIs with OpenAPI","text":""},{"location":"APIs/drf/core/documenting-restapi/#openapi","title":"OpenAPI","text":"<p>The OpenAPI Specification (OAS) is a standard for describing RESTful APIs. It provides a structured way to define the endpoints, request/response formats, authentication methods, and other aspects of an API in a machine-readable format. The OpenAPI Specification is typically written in YAML or JSON.</p> <p>An OpenAPI document (often referred to as a \"swagger file\" in earlier versions) includes details such as:</p> <ul> <li>Paths: Endpoints of the API.</li> <li>Operations: Methods (e.g., GET, POST) supported by each endpoint.</li> <li>Parameters: Query parameters, path parameters, etc.</li> <li>Request Bodies: The structure and format of data sent in requests.</li> <li>Responses: Expected responses, including status codes and response bodies.</li> <li>Security: Authentication methods.</li> </ul> Example of a simple OpenAPI document in YAML: <pre><code>openapi: 3.0.0\ninfo:\n    title: Sample API\n    version: 1.0.0\npaths:\n    /users:\n        get:\n        summary: List all users\n        responses:\n            '200':\n            description: A JSON array of user names\n            content:\n                application/json:\n                schema:\n                    type: array\n                    items:\n                    type: string\n</code></pre>"},{"location":"APIs/drf/core/documenting-restapi/#json-schema","title":"JSON Schema","text":"<p>JSON Schema is a vocabulary that allows you to annotate and validate JSON documents. It is used to define the structure and constraints of JSON data, ensuring that the data adheres to a specified format.</p> <p>JSON Schema supports the following basic data types:</p> <ul> <li><code>string</code> for character values</li> <li><code>number</code> for integer and decimal values</li> <li><code>object</code> for associative arrays (i.e., dictionaries in Python)</li> <li><code>array</code> for collections of other data types (i.e., lists in Python)</li> <li><code>boolean</code> for true or false values</li> <li><code>null</code> for uninitialized data</li> </ul> <p>Example</p> <p>JSON Schema can be used to describe the properties of JSON objects, including:</p> <ul> <li>Types: Define the data types (e.g., <code>string</code>, <code>number</code>, <code>object</code>).</li> <li>Properties: Describe the attributes of an object.</li> <li>Constraints: Specify rules for data (e.g., required fields, value ranges).</li> </ul> Example of a JSON Schema: <pre><code>{\n    \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n    \"title\": \"User\",\n    \"type\": \"object\",\n    \"properties\": {\n        \"name\": {\n        \"type\": \"string\"\n        },\n        \"age\": {\n        \"type\": \"integer\",\n        \"minimum\": 0\n        }\n    },\n    \"required\": [\"name\", \"age\"]\n}\n</code></pre>"},{"location":"APIs/drf/core/documenting-restapi/#swagger","title":"Swagger","text":"<p>Swagger originally referred to a set of tools for implementing the OpenAPI Specification. It was created by SmartBear Software and has become one of the most widely used frameworks for API documentation and testing.</p> <p>Swagger includes:</p> <ul> <li>Swagger UI: An interactive documentation tool that automatically generates a user interface based on an OpenAPI document. It allows users to test API endpoints directly from the documentation.</li> <li>Swagger Editor: An online editor for creating and editing OpenAPI documents with real-time preview and validation.</li> <li>Swagger Codegen: A tool for generating client libraries, server stubs, and API documentation from an OpenAPI document.</li> </ul> <p>Swagger tools work with OpenAPI documents to facilitate API design, documentation, and client generation.</p>"},{"location":"APIs/drf/core/documenting-restapi/#relationship-between-openapi-json-schema-and-swagger","title":"Relationship Between OpenAPI, JSON Schema, and Swagger","text":"<ul> <li>OpenAPI: A specification for describing RESTful APIs. OpenAPI documents can be written in YAML or JSON.</li> <li>JSON Schema: A vocabulary for validating and annotating JSON documents. OpenAPI uses JSON Schema to define the data models for API requests and responses.</li> <li>Swagger: A set of tools for working with OpenAPI documents, including generating interactive documentation, client libraries, and server stubs.</li> </ul> <p>Together, these technologies provide a comprehensive ecosystem for designing, documenting, validating, and interacting with APIs.</p>"},{"location":"APIs/drf/core/documenting-restapi/#reference","title":"Reference","text":"<ul> <li>Microservice APIs by JOS\u00c9 HARO PERALTA</li> <li>swagger about</li> </ul>"},{"location":"APIs/drf/core/drf-functionbasedviews/","title":"drf fbv","text":"<p>Django has two types of views;</p> <ul> <li>function-based views (FBVs), &amp;</li> <li>class-based views (CBVs)</li> </ul> <p>Django originally started out with only FBVs, but then added CBVs as a way to templatize functionality so that you didn\u2019t have to write boilerplate (i.e. the same code) code over and over again.</p>"},{"location":"APIs/drf/core/drf-functionbasedviews/#function-based-views-fbvs","title":"Function-based views (FBVs)","text":"<p>FBVs code here:</p> <p>Todo App (using FBVs)</p> <p>Let's look at how a simple todo application that allows CRUD operations would be written using only FBVs.</p> <pre><code># todo/views.py\n\nfrom django.shortcuts import render, get_object_or_404, redirect\n\nfrom .forms import TaskForm, ConfirmForm\nfrom .models import Task\n\n\ndef task_list_view(request):\n    return render(request, 'todo/task_list.html', {\n        'tasks': Task.objects.all(),\n    })\n\n\ndef task_create_view(request):\n    if request.method == 'POST':\n        form = TaskForm(data=request.POST)\n        if form.is_valid():\n            form.save()\n            return HttpResponseRedirect(reverse('task-list'))\n\n    return render(request, 'todo/task_create.html', {\n        'form': TaskForm(),\n    })\n\n\ndef task_detail_view(request, pk):\n    task = get_object_or_404(Task, pk=pk)\n    return render(request, 'todo/task_detail.html', {\n        'task': task,\n    })\n\n\ndef task_update_view(request, pk):\n    task = get_object_or_404(Task, pk=pk)\n\n    if request.method == 'POST':\n        form = TaskForm(instance=task, data=request.POST)\n        if form.is_valid():\n            form.save()\n            return HttpResponseRedirect(reverse('task-detail', args={pk: pk}))\n\n    return render(request, 'todo/task_update.html', {\n        'task': task,\n        'form': TaskForm(instance=task),\n    })\n\n\ndef task_delete_view(request, pk):\n    task = get_object_or_404(Task, pk=pk)\n\n    if request.method == 'POST':\n        form = ConfirmForm(data=request.POST)\n        if form.is_valid():\n            task.delete()\n            return HttpResponseRedirect(reverse('task-list'))\n\n    return render(request, 'todo/task_delete.html', {\n        'task': task,\n        'form': ConfirmForm(),\n    })\n</code></pre> <p>You can get the full source code on GitHub.</p>"},{"location":"APIs/drf/core/drf-functionbasedviews/#class-based-views-cbvs","title":"Class-based views (CBVs)","text":"<p>CBVs code here:</p> <p></p> <p>Todo App (using CBVs)</p> <p>Now, let's rewrite our todo application to only use CBVs:</p> <pre><code># todo/views.py\n\nfrom django.shortcuts import render, get_object_or_404, redirect\nfrom django.views import View\n\nfrom .forms import TaskForm, ConfirmForm\nfrom .models import Task\n\n\nclass TaskListView(View):\n\n    def get(self, request, *args, **kwargs):\n        return render(request, 'todo/task_list.html', {\n            'tasks': Task.objects.all(),\n        })\n\n\nclass TaskCreateView(View):\n\n    def get(self, request, *args, **kwargs):\n        return render(request, 'todo/task_create.html', {\n            'form': TaskForm(),\n        })\n\n    def post(self, request, *args, **kwargs):\n        form = TaskForm(data=request.POST)\n        if form.is_valid():\n            task = form.save()\n            return redirect('task-detail', pk=task.pk)\n\n        return self.get(request)\n\n\nclass TaskDetailView(View):\n\n    def get(self, request, pk, *args, **kwargs):\n        task = get_object_or_404(Task, pk=pk)\n\n        return render(request, 'todo/task_detail.html', {\n            'task': task,\n        })\n\n\nclass TaskUpdateView(View):\n\n    def get(self, request, pk, *args, **kwargs):\n        task = get_object_or_404(Task, pk=pk)\n        return render(request, 'todo/task_update.html', {\n            'task': task,\n            'form': TaskForm(instance=task),\n        })\n\n    def post(self, request, pk, *args, **kwargs):\n        task = get_object_or_404(Task, pk=pk)\n        form = TaskForm(instance=task, data=request.POST)\n        if form.is_valid():\n            form.save()\n            return redirect('task-detail', pk=task.pk)\n\n        return self.get(request, pk)\n\n\nclass TaskDeleteView(View):\n\n    def get(self, request, pk, *args, **kwargs):\n        task = get_object_or_404(Task, pk=pk)\n        return render(request, 'todo/task_confirm_delete.html', {\n            'task': task,\n            'form': ConfirmForm(),\n        })\n\n    def post(self, request, pk, *args, **kwargs):\n        task = get_object_or_404(Task, pk=pk)\n        form = ConfirmForm(data=request.POST)\n        if form.is_valid():\n            task.delete()\n            return redirect('task-list')\n\n        return self.get(request, pk)\n</code></pre> <p>Also, let's not forget to make our urls.py call <code>as_view()</code>:</p> <pre><code># todo/urls.py\n\nfrom django.urls import path\n\nfrom .views import TaskListView, TaskDetailView, TaskCreateView, TaskUpdateView, TaskDeleteView\n\n\nurlpatterns = [\n    path('', TaskListView.as_view(), name='task-list'),\n    path('create/', TaskCreateView.as_view(), name='task-create'),\n    path('&lt;int:pk&gt;/', TaskDetailView.as_view(), name='task-detail'),\n    path('update/&lt;int:pk&gt;/', TaskUpdateView.as_view(), name='task-update'),\n    path('delete/&lt;int:pk&gt;/', TaskDeleteView.as_view(), name='task-delete'),\n]\n</code></pre> <p>You can get the full source code on Github</p>"},{"location":"APIs/drf/core/drf-functionbasedviews/#djangos-generic-cbvs","title":"Django's Generic CBVs","text":"<p>Django's generic CBVs are great for solving common problems like retrieving, creating, modifying, and deleting objects as well as pagination and archive views. They speed up the development process too.</p> <pre><code>from django.views.generic import CreateView\n\n\nclass TaskCreateView(CreateView):\n    model = Task\n    context_object_name = 'task'\n    fields = ('name', 'description', 'is_done')\n    template_name = 'todo/task_create.html'\n</code></pre>"},{"location":"APIs/drf/core/drf-functionbasedviews/#djangos-built-in-cbv-types","title":"Django's Built-in CBV Types","text":""},{"location":"APIs/drf/core/drf-functionbasedviews/#reference","title":"Reference","text":"<ul> <li>Django : Class Based Views vs Function Based Views</li> <li>Class Based vs Function Based Views \u2013 Which One is Better to Use in Django?</li> <li>Class-based vs Function-based Views in Django</li> <li>What Are Django\u2019s Class-Based Views and How to Use Them Effectively</li> </ul>"},{"location":"APIs/drf/core/public-api-security/","title":"Public API Security","text":""},{"location":"APIs/drf/core/public-api-security/#enhancing-public-api-security-without-authentication-key-techniques-and-best-practices","title":"\"Enhancing Public API Security Without Authentication: Key Techniques and Best Practices\"","text":"<p>Yes, you can make a public API secure without requiring traditional user authentication (like JWT). Here are some techniques to enhance the security of a public API:</p>"},{"location":"APIs/drf/core/public-api-security/#1-rate-limiting-and-throttling","title":"1. Rate Limiting and Throttling","text":"<ul> <li> <p>Implement rate limiting to control the number of requests an IP address or user can make to your API. This prevents abuse and DDoS attacks.</p> </li> <li> <p>Django REST Framework supports throttling out of the box. You can use <code>AnonRateThrottle</code> for anonymous users.</p> <pre><code>from rest_framework.throttling import AnonRateThrottle\n\nclass PublicView(APIView):\n    throttle_classes = [AnonRateThrottle]\n    def get(self, request):\n        # Public logic here\n        pass\n</code></pre> </li> <li> <p>Customize the rate limits to suit your needs (e.g., 100 requests per hour).</p> </li> </ul>"},{"location":"APIs/drf/core/public-api-security/#2-api-keys","title":"2. API Keys","text":"<ul> <li> <p>Use API keys to control access to your API. Although it's not full authentication, it ensures that only users with a valid key can access the API.</p> </li> <li> <p>You can generate and distribute API keys to users and check for them in incoming requests.</p> <pre><code>from rest_framework.permissions import BasePermission\n\nclass HasAPIKey(BasePermission):\n    def has_permission(self, request, view):\n        api_key = request.headers.get('API-Key')\n        return api_key == 'your-expected-api-key'\n</code></pre> </li> <li> <p>Apply the <code>HasAPIKey</code> permission to your views:</p> <pre><code>class PublicView(APIView):\n    permission_classes = [HasAPIKey]\n\n    def get(self, request):\n        # Public logic here\n        pass\n</code></pre> </li> </ul>"},{"location":"APIs/drf/core/public-api-security/#3-cors-cross-origin-resource-sharing","title":"3. CORS (Cross-Origin Resource Sharing)","text":"<ul> <li> <p>Implement CORS to restrict which domains can access your API. This helps prevent unauthorized external use of your API.</p> </li> <li> <p>Django has <code>django-cors-headers</code> to manage CORS policies.</p> <pre><code># settings.py\nCORS_ALLOWED_ORIGINS = [\n    \"https://your-allowed-domain.com\",\n]\n</code></pre> </li> </ul>"},{"location":"APIs/drf/core/public-api-security/#4-input-validation-and-sanitization","title":"4. Input Validation and Sanitization","text":"<ul> <li> <p>Always validate and sanitize input data to prevent injection attacks, such as SQL injection or cross-site scripting (XSS).</p> </li> <li> <p>Use Django's built-in validators and clean data rigorously.</p> <pre><code>from django.core.validators import validate_email\nfrom rest_framework import serializers\n\nclass PublicSerializer(serializers.Serializer):\n    email = serializers.EmailField(validators=[validate_email])\n</code></pre> </li> </ul>"},{"location":"APIs/drf/core/public-api-security/#5-data-limiting","title":"5. Data Limiting","text":"<ul> <li> <p>Limit the amount of data returned in a single request to prevent excessive data exposure. Implement pagination for large datasets.</p> </li> <li> <p>Use Django REST Framework's pagination features:</p> <pre><code>from rest_framework.pagination import PageNumberPagination\n\nclass PublicPagination(PageNumberPagination):\n    page_size = 10\n\nclass PublicView(ListAPIView):\n    pagination_class = PublicPagination\n    # other settings\n</code></pre> </li> </ul>"},{"location":"APIs/drf/core/public-api-security/#6-ip-whitelisting","title":"6. IP Whitelisting","text":"<ul> <li>Restrict access to your API to only certain IP addresses or ranges that you trust.</li> <li> <p>You can enforce this at the server or application level, e.g., using middleware in Django.</p> <pre><code>class IPWhitelistMiddleware:\n    ALLOWED_IPS = ['123.456.789.0']\n\n    def __init__(self, get_response):\n        self.get_response = get_response\n\n    def __call__(self, request):\n        ip = request.META.get('REMOTE_ADDR')\n        if ip not in self.ALLOWED_IPS:\n            return HttpResponseForbidden('Forbidden')\n        return self.get_response(request)\n</code></pre> </li> </ul>"},{"location":"APIs/drf/core/public-api-security/#7-content-security-policy-csp","title":"7. Content Security Policy (CSP)","text":"<ul> <li> <p>Enforce a strong CSP to control where resources like scripts can be loaded from. This helps mitigate certain types of attacks, especially in web applications.</p> <pre><code># settings.py\nCSP_DEFAULT_SRC = (\"'self'\",)\nCSP_SCRIPT_SRC = (\"'self'\", \"https://trustedscripts.example.com\")\n</code></pre> </li> </ul>"},{"location":"APIs/drf/core/public-api-security/#8-monitoring-and-logging","title":"8. Monitoring and Logging","text":"<ul> <li> <p>Implement robust logging and monitoring to detect suspicious activity, such as unusual request patterns or potential attacks.</p> </li> <li> <p>Use Django's logging configuration to capture and analyze logs.</p> <pre><code>import logging\n\nlogger = logging.getLogger(__name__)\n\nclass PublicView(APIView):\n    def get(self, request):\n        logger.info(f\"Request received from IP: {request.META.get('REMOTE_ADDR')}\")\n        # Your logic here\n</code></pre> </li> </ul>"},{"location":"APIs/drf/core/public-api-security/#9-security-headers","title":"9. Security Headers","text":"<ul> <li>Add security headers like <code>X-Content-Type-Options</code>, <code>X-Frame-Options</code>, and <code>Strict-Transport-Security</code> (HSTS) to protect against common web vulnerabilities.</li> </ul> <pre><code># settings.py\nSECURE_BROWSER_XSS_FILTER = True\nSECURE_CONTENT_TYPE_NOSNIFF = True\nX_FRAME_OPTIONS = 'DENY'\n</code></pre>"},{"location":"APIs/drf/core/public-api-security/#10-encrypt-traffic-with-https","title":"10. Encrypt Traffic with HTTPS","text":"<p>Always serve your API over HTTPS to ensure that data in transit is encrypted.</p>"},{"location":"APIs/drf/core/public-api-security/#summary","title":"Summary","text":"<p>By combining these techniques, you can significantly enhance the security of your public API without requiring user authentication. These methods help prevent abuse, protect sensitive data, and ensure that your API remains accessible to legitimate users.</p> Tips <p>Rate limiting and throttling stands out as a key method for securing public APIs, ensuring they are protected against abuse while remaining accessible to legitimate users. However, it works best when combined with other security practices tailored to your specific API needs.</p>"},{"location":"APIs/drf/core/rate-limiting-throttling/","title":"Rate Limiting and Throttling","text":"<p>Here's a complete example of how to implement rate limiting and throttling in Django REST Framework (DRF):</p> <ol> <li> <p>Install Django REST Framework</p> <ul> <li> <p>Make sure you have Django REST Framework installed. If not, you can install it using pip:</p> <pre><code>pip install djangorestframework\n</code></pre> </li> </ul> </li> <li> <p>Configure Throttling in Django Settings</p> <ul> <li> <p>You can set global throttling rates in your <code>settings.py</code> file. DRF provides two built-in throttle classes: <code>AnonRateThrottle</code> (for anonymous users) and <code>UserRateThrottle</code> (for authenticated users).</p> <pre><code># settings.py\n\nREST_FRAMEWORK = {\n    'DEFAULT_THROTTLE_CLASSES': [\n        'rest_framework.throttling.AnonRateThrottle',\n        'rest_framework.throttling.UserRateThrottle',\n    ],\n    'DEFAULT_THROTTLE_RATES': {\n        'anon': '100/day',  # 100 requests per day for anonymous users\n        'user': '1000/day',  # 1000 requests per day for authenticated users\n    }\n}\n</code></pre> </li> </ul> </li> <li> <p>Implementing Throttling in Views</p> <ul> <li> <p>You can apply throttling to specific views or viewsets by using the <code>throttle_classes</code> attribute.</p> <pre><code>from rest_framework.views import APIView\nfrom rest_framework.response import Response\nfrom rest_framework.throttling import AnonRateThrottle, UserRateThrottle\n\nclass CustomAnonRateThrottle(AnonRateThrottle):\n    rate = '10/min'  # Override global setting: 10 requests per minute for anonymous users\n\nclass CustomUserRateThrottle(UserRateThrottle):\n    rate = '100/min'  # Override global setting: 100 requests per minute for authenticated users\n\nclass PublicAPIView(APIView):\n    throttle_classes = [CustomAnonRateThrottle, CustomUserRateThrottle]\n\n    def get(self, request):\n        data = {\"message\": \"This is a public API with rate limiting.\"}\n        return Response(data)\n</code></pre> </li> <li> <p>In this example, the <code>PublicAPIView</code> applies custom throttling rates. Anonymous users are limited to 10 requests per minute, while authenticated users can make 100 requests per minute.</p> </li> </ul> </li> <li> <p>Testing Throttling</p> <ul> <li> <p>You can test throttling by making multiple requests to the endpoint. Once the limit is reached, DRF will return a <code>429 Too Many Requests</code> response.</p> <pre><code># Make requests to the API endpoint\ncurl -X GET http://127.0.0.1:8000/api/public/\n</code></pre> </li> <li> <p>After exceeding the limit, the response will look like this:</p> <pre><code>{\n    \"detail\": \"Request was throttled. Expected available in 60 seconds.\"\n}\n</code></pre> </li> </ul> </li> <li> <p>Custom Throttle Classes</p> <ul> <li> <p>You can also create custom throttle classes to apply different rules based on your needs.</p> <pre><code>from rest_framework.throttling import BaseThrottle\nimport time\n\nclass BurstRateThrottle(BaseThrottle):\n    THROTTLE_RATES = {\n        'burst': '5/min'\n    }\n\n    def __init__(self):\n        self.history = []\n\n    def allow_request(self, request, view):\n        self.history = [timestamp for timestamp in self.history if timestamp &gt; time.time() - 60]\n        if len(self.history) &gt;= 5:\n            return False\n        self.history.append(time.time())\n        return True\n\n    def wait(self):\n        return 60 - (time.time() - self.history[-1])\n</code></pre> </li> <li> <p>Apply this custom throttle to your view:</p> <pre><code>class CustomThrottledAPIView(APIView):\n    throttle_classes = [BurstRateThrottle]\n\n    def get(self, request):\n        data = {\"message\": \"This API has a custom burst rate throttle.\"}\n        return Response(data)\n</code></pre> </li> </ul> </li> <li> <p>Logging and Monitoring Throttling</p> <ul> <li> <p>You can log throttling events for monitoring purposes:</p> <pre><code>import logging\nfrom rest_framework.throttling import SimpleRateThrottle\n\nlogger = logging.getLogger(__name__)\n\nclass LoggedAnonRateThrottle(SimpleRateThrottle):\n    scope = 'anon'\n\n    def allow_request(self, request, view):\n        if not super().allow_request(request, view):\n            logger.warning(f\"Throttled request from IP: {self.get_ident(request)}\")\n            return False\n        return True\n</code></pre> </li> <li> <p>Use this custom throttle in your view to log any throttled requests.</p> </li> </ul> </li> </ol>"},{"location":"APIs/drf/core/rate-limiting-throttling/#summary","title":"Summary","text":"<p>This example demonstrates how to implement rate limiting and throttling in Django REST Framework. By configuring global throttle rates, applying custom throttle classes, and logging throttling events, you can effectively manage API usage and protect your public API from abuse.</p>"},{"location":"APIs/drf/topic/authentication-overview/","title":"Authentication Overview","text":"<p>Sure! Let\u2019s dive into Django\u2019s authentication framework, covering sessions, tokens, and backend systems.</p>"},{"location":"APIs/drf/topic/authentication-overview/#1-authentication-overview","title":"1. Authentication Overview","text":"<p>Authentication in Django is about verifying user identities. It includes user registration, login/logout functionality, and managing user sessions. The framework also provides authorization to control access to views and data based on user permissions.</p>"},{"location":"APIs/drf/topic/authentication-overview/#2-sessions","title":"2. Sessions","text":"<p>What are Sessions?</p> <p>Sessions in Django allow you to store information about a user across different requests. When a user logs in, their session is created and can hold information like user ID or preferences.</p> <p>How Sessions Work:</p> <ul> <li>When a user logs in, Django creates a session and generates a session ID, which is stored in the user's browser as a cookie.</li> <li>This session ID maps to a session record stored in the database or cache, allowing Django to retrieve user data on subsequent requests.</li> <li>Django handles session management through middleware (<code>SessionMiddleware</code>), which processes session data for each request.</li> </ul> <p>Key Functions:</p> <ul> <li> <p><code>request.session</code>: A dictionary-like object that allows you to store and retrieve session data.</p> </li> <li> <p>Example:</p> </li> </ul> <pre><code>request.session['user_id'] = user.id\n</code></pre>"},{"location":"APIs/drf/topic/authentication-overview/#3-tokens","title":"3. Tokens","text":"<p>What are Tokens?</p> <p>Tokens are used primarily in API authentication, allowing users to log in without maintaining a session. Tokens represent a user and are sent with each request to verify identity.</p> <p>Types of Token Authentication:</p> <ul> <li>Token-based Authentication: Uses tokens to authenticate users instead of traditional sessions. A user logs in, receives a token, and uses it in headers for subsequent requests.</li> <li>JSON Web Tokens (JWT): A compact token format that is often used in REST APIs. It encodes user information and can be verified by the server.</li> </ul> <p>Implementing Token Authentication:</p> <ul> <li>Use packages like <code>djangorestframework-simplejwt</code> for JWT.</li> <li>Example of obtaining a token:</li> </ul> <pre><code>from rest_framework_simplejwt.views import TokenObtainPairView\n</code></pre> <ul> <li>Token handling usually includes issuing tokens on login and validating them on each request.</li> </ul>"},{"location":"APIs/drf/topic/authentication-overview/#4-authentication-backends","title":"4. Authentication Backends","text":"<p>What are Authentication Backends?</p> <p>Authentication backends are classes that determine how users are authenticated. Django comes with a default backend that checks credentials against the database.</p> <p>How Backends Work:</p> <ul> <li>Backends implement the <code>authenticate()</code> method, which takes username and password, verifies them, and returns the user object if valid.</li> <li>You can create custom backends to authenticate users in different ways (e.g., using email instead of username).</li> </ul> <p>Creating a Custom Backend:</p> <ul> <li>Define a class that inherits from <code>BaseBackend</code>.</li> <li>Implement the <code>authenticate()</code> method to specify custom authentication logic.</li> <li>Example:</li> </ul> <pre><code>from django.contrib.auth.backends import BaseBackend\n\nclass EmailBackend(BaseBackend):\n    def authenticate(self, request, email=None, password=None):\n        # Custom logic to authenticate by email\n        ...\n</code></pre>"},{"location":"APIs/drf/topic/authentication-overview/#5-integrating-authentication-with-views","title":"5. Integrating Authentication with Views","text":"<ul> <li>Login View: Use <code>django.contrib.auth.views.LoginView</code> for a built-in login view or create a custom one.</li> <li>Logout View: Use <code>django.contrib.auth.views.LogoutView</code> to log users out and clear their session.</li> <li>Protected Views: Use decorators like <code>@login_required</code> to restrict access to certain views.</li> </ul>"},{"location":"APIs/drf/topic/authentication-overview/#6-security-considerations","title":"6. Security Considerations","text":"<ul> <li>Session Security: Ensure cookies are marked as HttpOnly and Secure to protect against attacks.</li> <li>Token Expiry: Set expiration times for tokens to limit their validity.</li> <li>Prevent CSRF: Use Django\u2019s built-in CSRF protection for web forms.</li> </ul>"},{"location":"APIs/drf/topic/authentication-overview/#conclusion","title":"Conclusion","text":"<p>By understanding sessions, tokens, and authentication backends in Django, you can create robust authentication systems tailored to your application\u2019s needs. This knowledge is crucial for building secure web applications and APIs. For practical experience, try implementing these concepts in a small project, such as a simple login system or a REST API with token authentication.</p>"},{"location":"APIs/drf/topic/django-contrib-auth/","title":"django.contrib.auth","text":""},{"location":"APIs/drf/topic/django-contrib-auth/#overview","title":"Overview","text":"<p>The <code>django.contrib.auth</code> module is a powerful and flexible authentication framework provided by Django. It handles user authentication, permissions, and group management, allowing developers to implement user management features in their applications easily. Let's explore its components and functionalities in detail.</p>"},{"location":"APIs/drf/topic/django-contrib-auth/#1-user-model","title":"1. User Model","text":"<p>Built-in User Model</p> <p>Django includes a built-in User model that has fields like:</p> <ul> <li><code>username</code>: A unique identifier for the user.</li> <li><code>password</code>: The hashed password.</li> <li><code>email</code>: Email address of the user.</li> <li><code>first_name</code> and <code>last_name</code>: User's personal names.</li> <li><code>is_active</code>: Boolean to indicate if the user account is active.</li> <li><code>is_staff</code>: Boolean to indicate if the user can access the admin site.</li> <li><code>is_superuser</code>: Boolean to indicate if the user has all permissions.</li> </ul> <p>You can access the User model through:</p> <pre><code>from django.contrib.auth.models import User\n</code></pre>"},{"location":"APIs/drf/topic/django-contrib-auth/#custom-user-model","title":"Custom User Model","text":"<p>If you need to extend the User model, Django allows you to create a custom user model by subclassing either AbstractUser or AbstractBaseUser. This is recommended if you anticipate needing to add fields or change the authentication method.</p> Example of a Custom User Model: <pre><code>from django.contrib.auth.models import AbstractUser\nfrom django.db import models\n\nclass CustomUser(AbstractUser):\n    phone_number = models.CharField(max_length=15, blank=True)\n</code></pre> <p>Don't forget to set <code>AUTH_USER_MODEL</code> in your settings:</p> <pre><code>AUTH_USER_MODEL = 'yourapp.CustomUser'\n</code></pre>"},{"location":"APIs/drf/topic/django-contrib-auth/#2-authentication-backends","title":"2. Authentication Backends","text":"<p>Authentication backends determine how users are authenticated. Django provides a default backend that checks username and password against the User model.</p> <p>Custom Authentication Backends You can create custom backends to allow different authentication methods (like email/password or social logins).</p> Example of a Custom Backend: <pre><code>from django.contrib.auth.backends import BaseBackend\nfrom django.contrib.auth.models import User\n\nclass EmailBackend(BaseBackend):\n    def authenticate(self, request, email=None, password=None):\n        try:\n            user = User.objects.get(email=email)\n            if user.check_password(password):\n                return user\n        except User.DoesNotExist:\n            return None\n</code></pre>"},{"location":"APIs/drf/topic/django-contrib-auth/#3-user-management-functions","title":"3. User Management Functions","text":"<p>Creating Users</p> <p>You can create users using the <code>create_user</code> and <code>create_superuser</code> methods:</p> <pre><code>user = User.objects.create_user(username='john', password='password')\nsuperuser = User.objects.create_superuser(username='admin', password='adminpass')\n</code></pre> <p>User Authentication</p> <p>Django provides several methods for user authentication:</p> <ul> <li><code>authenticate()</code>: Verifies a user's credentials.</li> <li><code>login()</code>: Logs the user in and creates a session.</li> <li><code>logout()</code>: Logs the user out and clears the session.</li> </ul> Example: <pre><code>from django.contrib.auth import authenticate, login, logout\n\nuser = authenticate(request, username='john', password='password')\nif user is not None:\n    login(request, user)\n</code></pre>"},{"location":"APIs/drf/topic/django-contrib-auth/#4-permissions-and-groups","title":"4. Permissions and Groups","text":"<p>Django's authentication framework includes a robust permission system. Each user can have permissions assigned directly or through groups.</p> <p>Permissions</p> <p>Django provides built-in permissions like:</p> <ul> <li><code>add</code>, <code>change</code>, <code>delete</code>, and <code>view</code> for each model. You can check permissions using:</li> </ul> <pre><code>if request.user.has_perm('app_name.permission_codename'):\n    # User has permission\n</code></pre> <p>Groups</p> <p>Groups allow you to assign permissions collectively to multiple users. You can create groups in the Django admin or programmatically:</p> <pre><code>from django.contrib.auth.models import Group\n\ngroup = Group.objects.create(name='Editors')\ngroup.permissions.add(permission)\n</code></pre>"},{"location":"APIs/drf/topic/django-contrib-auth/#5-views-and-forms","title":"5. Views and Forms","text":"<p>Django provides built-in views and forms for handling user authentication, such as:</p> <ul> <li><code>LoginView</code>: For user login.</li> <li><code>LogoutView</code>: For user logout.</li> <li><code>PasswordChangeView</code>: For changing passwords.</li> <li><code>PasswordResetView</code>: For resetting forgotten passwords.</li> </ul> Example of using LoginView in URLs: <pre><code>from django.urls import path\nfrom django.contrib.auth.views import LoginView\n\nurlpatterns = [\n    path('login/', LoginView.as_view(), name='login'),\n]\n</code></pre>"},{"location":"APIs/drf/topic/django-contrib-auth/#6-middleware","title":"6. Middleware","text":"<p>Django\u2019s authentication framework uses middleware to manage sessions and user authentication:</p> <ul> <li><code>SessionMiddleware</code>: Manages sessions across requests.</li> <li><code>AuthenticationMiddleware</code>: Associates users with requests based on session data.</li> </ul>"},{"location":"APIs/drf/topic/django-contrib-auth/#7-signals","title":"7. Signals","text":"<p>Django provides signals that allow you to execute certain actions automatically when certain events occur. For example:</p> <ul> <li><code>user_logged_in</code>: Triggered when a user logs in.</li> <li><code>user_logged_out</code>: Triggered when a user logs out.</li> <li><code>user_created</code>: Custom signals can be defined to handle user creation events.</li> </ul> Example of using signals: <pre><code>from django.dispatch import receiver\nfrom django.contrib.auth.signals import user_logged_in\n\n@receiver(user_logged_in)\ndef user_login(sender, request, user, **kwargs):\n    print(f\"{user.username} logged in.\")\n</code></pre>"},{"location":"APIs/drf/topic/django-contrib-auth/#8-security-considerations","title":"8. Security Considerations","text":"<ul> <li>Password Storage: Django hashes passwords using PBKDF2 by default, making it secure.</li> <li>CSRF Protection: Ensure forms include CSRF tokens to protect against cross-site request forgery.</li> <li>Secure Cookies: Set cookies as <code>HttpOnly</code> and <code>Secure</code> when in production to enhance security.</li> </ul>"},{"location":"APIs/drf/topic/django-contrib-auth/#conclusion","title":"Conclusion","text":"<p>The <code>django.contrib.auth</code> module provides a comprehensive framework for handling user authentication, authorization, and management. By utilizing its built-in features and customizing as needed, you can create a robust authentication system tailored to your application\u2019s requirements. For hands-on experience, practice building authentication features in a small project, integrating different aspects like custom user models, permissions, and user management functionalities.</p>"},{"location":"APIs/drf/topic/intro/","title":"Intro","text":""},{"location":"APIs/drf/topic/intro/#overview","title":"Overview","text":"<p>Mastering Django's built-in User model involves understanding its features and how to customize it for your needs. Here\u2019s a step-by-step guide to help you get started:</p>"},{"location":"APIs/drf/topic/intro/#1-understand-the-default-user-model","title":"1. Understand the Default User Model","text":"<ul> <li>Familiarize yourself with the fields in django.contrib.auth.models.User, such as <code>username</code>, <code>password</code>, <code>email</code>, <code>first_name</code>, <code>last_name</code>, and <code>is_active</code>.</li> <li>Review the authentication methods provided by Django.</li> </ul>"},{"location":"APIs/drf/topic/intro/#2-using-the-built-in-user-model","title":"2. Using the Built-in User Model","text":"<ul> <li>Creating Users: Use <code>User.objects.create_user()</code> for creating new users securely.</li> <li>Authenticating Users: Use <code>authenticate()</code> and <code>login()</code> functions to handle user authentication.</li> <li>Password Management: Learn how to use <code>set_password()</code> to hash passwords and <code>check_password()</code> for verification.</li> </ul>"},{"location":"APIs/drf/topic/intro/#3-customizing-the-user-model","title":"3. Customizing the User Model","text":"<ul> <li>Abstract Base User: If you need to change the fields, consider using <code>AbstractBaseUser</code> or <code>AbstractUser</code>.</li> <li>Custom User Model: Create your own user model by subclassing AbstractUser and adding your custom fields. Update <code>AUTH_USER_MODEL</code> in your settings.</li> </ul>"},{"location":"APIs/drf/topic/intro/#4-implementing-user-profiles","title":"4. Implementing User Profiles","text":"<ul> <li>Create a one-to-one relationship with a profile model if you want to store additional user information.</li> <li>Use signals (like<code>post_save</code>) to automatically create/update profiles when a user is created/updated.</li> </ul>"},{"location":"APIs/drf/topic/intro/#5-permissions-and-groups","title":"5. Permissions and Groups","text":"<ul> <li>Learn how to use Django\u2019s permission system to manage user access.</li> <li>Familiarize yourself with the <code>Group</code> model to organize users and permissions.</li> </ul>"},{"location":"APIs/drf/topic/intro/#6-user-authentication-and-authorization","title":"6. User Authentication and Authorization","text":"<ul> <li>Implement custom authentication backends if needed (e.g., for social login).</li> <li>Learn about the <code>@login_required</code> decorator and how to protect views.</li> </ul>"},{"location":"APIs/drf/topic/intro/#7-forms-and-views","title":"7. Forms and Views","text":"<ul> <li>Use <code>UserCreationForm</code> and <code>AuthenticationForm</code> for user registration and login.</li> <li>Customize forms as needed and handle form validation properly.</li> </ul>"},{"location":"APIs/drf/topic/intro/#8-admin-interface","title":"8. Admin Interface","text":"<ul> <li>Customize the Django admin to manage users more effectively. Register your custom user model and adjust the admin interface for better usability.</li> </ul>"},{"location":"APIs/drf/topic/intro/#9-testing-user-functionality","title":"9. Testing User Functionality","text":"<ul> <li>Write tests for user creation, authentication, and permissions to ensure your implementation works as expected.</li> </ul>"},{"location":"APIs/drf/topic/intro/#10-explore-third-party-packages","title":"10. Explore Third-Party Packages","text":"<ul> <li>Consider using packages like django-allauth or django-rest-auth for extended user management features, especially if you plan to implement social authentication or API-based user management.</li> </ul>"},{"location":"APIs/drf/topic/intro/#resources","title":"Resources","text":"<ul> <li>Django Documentation: Always refer to the official Django documentation for the most accurate information.</li> <li>Books and Tutorials: Consider reading books or online tutorials focused on Django to deepen your understanding.</li> </ul> <p>By following these steps and continually practicing, you'll become proficient in using and customizing Django's User model effectively.</p>"},{"location":"APIs/drf/topic/intro/#additional","title":"Additional","text":"<p>To truly master Django's built-in User model and become a top developer, you can follow a more advanced and structured approach. Here\u2019s a roadmap to guide you:</p>"},{"location":"APIs/drf/topic/intro/#1-deep-understanding-of-django-authentication","title":"1. Deep Understanding of Django Authentication","text":"<ul> <li>Study Authentication Framework: Dive into the authentication framework, understanding how sessions, tokens, and backend systems work.</li> <li>Source Code Exploration: Read the source code of django.contrib.auth to grasp the internals of how authentication and permissions are implemented.</li> </ul>"},{"location":"APIs/drf/topic/intro/#2-custom-user-model-design","title":"2. Custom User Model Design","text":"<ul> <li>Build Complex User Models: Create custom user models with unique fields (e.g., phone number, profile picture) using <code>AbstractBaseUser</code>.</li> <li>Understand Migration Strategy: Learn how to handle migrations effectively when changing user models, especially in existing projects.</li> </ul>"},{"location":"APIs/drf/topic/intro/#3-security-best-practices","title":"3. Security Best Practices","text":"<ul> <li>Password Management: Implement best practices for password storage, including using Django\u2019s built-in functions for hashing and salting.</li> <li>Two-Factor Authentication: Explore libraries like django-otp to implement two-factor authentication for enhanced security.</li> </ul>"},{"location":"APIs/drf/topic/intro/#4-integrating-with-frontend-frameworks","title":"4. Integrating with Frontend Frameworks","text":"<ul> <li>REST APIs: Use Django REST Framework to create APIs for user management, allowing integration with modern frontend frameworks like React or Vue.js.</li> <li>GraphQL: Explore Django Graphene for building GraphQL APIs to manage user data effectively.</li> </ul>"},{"location":"APIs/drf/topic/intro/#5-advanced-user-management-features","title":"5. Advanced User Management Features","text":"<ul> <li>Social Authentication: Implement social authentication using packages like django-allauth or social-auth-app-django.</li> <li>Custom Permissions and Roles: Design a robust permission system that includes roles and fine-grained access control.</li> </ul>"},{"location":"APIs/drf/topic/intro/#6-testing-and-quality-assurance","title":"6. Testing and Quality Assurance","text":"<ul> <li>Automated Testing: Write comprehensive tests for user authentication flows using Django\u2019s testing framework.</li> <li>Continuous Integration: Set up CI/CD pipelines to automate testing and deployment of changes.</li> </ul>"},{"location":"APIs/drf/topic/intro/#7-performance-optimization","title":"7. Performance Optimization","text":"<ul> <li>Database Indexing: Understand how to optimize queries related to user authentication by using proper indexing.</li> <li>Caching Strategies: Implement caching strategies for frequently accessed user data to improve performance.</li> </ul>"},{"location":"APIs/drf/topic/intro/#8-real-world-projects","title":"8. Real-World Projects","text":"<ul> <li>Build Applications: Create a variety of applications (e.g., social networks, e-commerce sites) that utilize Django\u2019s user model extensively.</li> <li>Contribute to Open Source: Engage with the Django community by contributing to open-source projects, which will expose you to real-world problems and solutions.</li> </ul>"},{"location":"APIs/drf/topic/intro/#9-stay-updated","title":"9. Stay Updated","text":"<ul> <li>Follow Updates: Keep an eye on Django\u2019s release notes for new features and enhancements related to authentication and user management.</li> <li>Engage with Community: Join forums, attend meetups, and participate in Django conferences to learn from peers and industry leaders.</li> </ul>"},{"location":"APIs/drf/topic/intro/#10-documentation-and-resources","title":"10. Documentation and Resources","text":"<ul> <li>Create Documentation: Document your customizations and learnings as you develop. This will not only help you but also others in the community.</li> <li>Books and Courses: Invest in advanced books or courses focused on Django and web development best practices.</li> </ul> <p>By following these steps, continually learning, and building real-world applications, you\u2019ll be well on your way to mastering Django\u2019s User model and becoming a top developer in the field.</p>"},{"location":"APIs/drf/topic/learning-path/","title":"Learning Path","text":""},{"location":"APIs/drf/topic/learning-path/#overview","title":"Overview","text":"<p>To become a top-level Django programmer, you'll need a structured learning path that covers both foundational knowledge and advanced topics. Here\u2019s a comprehensive roadmap to guide you through the process:</p>"},{"location":"APIs/drf/topic/learning-path/#1-foundation-in-python","title":"1. Foundation in Python","text":"<ul> <li>Learn Python Basics: Understand data types, control structures, functions, and object-oriented programming.</li> <li>Recommended Resources:</li> <li>\u201cAutomate the Boring Stuff with Python\u201d by Al Sweigart</li> <li>Online platforms like Codecademy or freeCodeCamp.</li> </ul>"},{"location":"APIs/drf/topic/learning-path/#2-understanding-web-development-basics","title":"2. Understanding Web Development Basics","text":"<ul> <li>HTML, CSS, and JavaScript: Get comfortable with front-end technologies.</li> <li>HTTP &amp; Web Protocols: Learn how web requests and responses work.</li> <li>Recommended Resources:</li> <li>MDN Web Docs for HTML, CSS, and JavaScript.</li> </ul>"},{"location":"APIs/drf/topic/learning-path/#3-learn-django-basics","title":"3. Learn Django Basics","text":"<ul> <li>Django Framework: Set up a Django project, understand the MTV architecture, and learn about routing, views, templates, and models.</li> <li> <p>Build Simple Applications: Create basic CRUD applications.</p> </li> <li> <p>\u201cDjango for Beginners\u201d by William S. Vincent</p> </li> <li>Django\u2019s official documentation.</li> </ul>"},{"location":"APIs/drf/topic/learning-path/#4-mastering-djangos-built-in-user-model","title":"4. Mastering Django's Built-in User Model","text":"<ul> <li>Authentication &amp; Authorization: Learn about the User model, permissions, and groups.</li> <li>Custom User Models: Understand how to create and implement custom user models.</li> <li>Forms and Validation: Use Django forms for user registration and login.</li> <li>Recommended Resources:</li> <li>Django documentation on authentication and authorization.</li> </ul>"},{"location":"APIs/drf/topic/learning-path/#5-advanced-django-concepts","title":"5. Advanced Django Concepts","text":"<ul> <li>Class-Based Views: Learn how to use class-based views for more complex applications.</li> <li>Django REST Framework: Build RESTful APIs and understand serialization, viewsets, and routers.</li> <li>Caching and Optimization: Implement caching strategies to improve performance.</li> <li>Recommended Resources:</li> <li>\u201cDjango for APIs\u201d by William S. Vincent.</li> </ul>"},{"location":"APIs/drf/topic/learning-path/#6-front-end-integration","title":"6. Front-End Integration","text":"<ul> <li>JavaScript Frameworks: Learn how to integrate with frameworks like React or Vue.js for single-page applications.</li> <li>AJAX and Fetch API: Understand how to make asynchronous requests.</li> <li>Recommended Resources:</li> <li>Online courses on React or Vue.js (e.g., Udemy, Coursera).</li> </ul>"},{"location":"APIs/drf/topic/learning-path/#7-security-best-practices","title":"7. Security Best Practices","text":"<ul> <li>User Data Protection: Implement best practices for user authentication, password management, and securing sensitive information.</li> <li>Common Vulnerabilities: Learn about common web vulnerabilities (e.g., SQL injection, XSS) and how to prevent them.</li> <li>Recommended Resources:</li> <li>OWASP Top Ten guidelines.</li> </ul>"},{"location":"APIs/drf/topic/learning-path/#8-deployment-and-devops","title":"8. Deployment and DevOps","text":"<ul> <li>Deploy Django Applications: Learn to deploy your applications using platforms like Heroku, AWS, or DigitalOcean.</li> <li>CI/CD Pipelines: Set up continuous integration and deployment processes.</li> <li>Containerization: Understand Docker and how to use it with Django applications.</li> <li>Recommended Resources:</li> <li>\u201cDjango 3 By Example\u201d by Antonio Mel\u00e9.</li> </ul>"},{"location":"APIs/drf/topic/learning-path/#9-real-world-projects","title":"9. Real-World Projects","text":"<ul> <li>Build Complex Applications: Work on projects that solve real-world problems (e.g., e-commerce, social networks).</li> <li>Contribute to Open Source: Engage with the Django community by contributing to existing projects on GitHub.</li> </ul>"},{"location":"APIs/drf/topic/learning-path/#10-stay-updated-and-network","title":"10. Stay Updated and Network","text":"<ul> <li>Follow Django Updates: Keep track of new features and changes in Django releases.</li> <li>Join Communities: Participate in forums, attend meetups, and join Django-related Slack or Discord channels.</li> <li>Recommended Resources:</li> <li>DjangoCon talks and videos.</li> </ul>"},{"location":"APIs/drf/topic/learning-path/#11-advanced-topics","title":"11. Advanced Topics","text":"<ul> <li>Asynchronous Django: Learn about Django Channels for handling WebSockets and asynchronous tasks.</li> <li>GraphQL: Explore Graphene-Django for building GraphQL APIs.</li> <li>Microservices Architecture: Understand how to build Django applications using a microservices approach.</li> </ul>"},{"location":"APIs/drf/topic/learning-path/#12-mentorship-and-continuous-learning","title":"12. Mentorship and Continuous Learning","text":"<ul> <li>Find a Mentor: Seek out experienced developers for guidance.</li> <li>Take Advanced Courses: Invest in specialized courses to deepen your knowledge in areas of interest.</li> </ul> <p>By following this structured learning path and continually practicing and building projects, you\u2019ll develop the skills needed to become a top-level Django programmer. Stay curious, experiment with new technologies, and engage with the community to enhance your learning journey!</p>"},{"location":"APIs/drf/topic/learning-path/#timeline","title":"Timeline","text":"<p>The timeline to master Django and become a top-level developer varies based on several factors, including your prior programming experience, the amount of time you can dedicate daily, and your learning pace. Here\u2019s a rough estimate based on a structured learning path:</p>"},{"location":"APIs/drf/topic/learning-path/#estimated-timeline","title":"Estimated Timeline","text":"<ol> <li> <p>Foundation in Python: 2-4 weeks</p> <ul> <li>Daily Commitment: 1-2 hours.</li> <li>Focus on basic concepts and practice coding exercises.</li> </ul> </li> <li> <p>Understanding Web Development Basics: 2-3 weeks</p> <ul> <li>Daily Commitment: 1-2 hours.</li> <li>Learn HTML, CSS, JavaScript, and web protocols.</li> </ul> </li> <li> <p>Learn Django Basics: 3-4 weeks</p> <ul> <li>Daily Commitment: 2-3 hours.</li> <li>Build simple projects and understand the core concepts.</li> </ul> </li> <li> <p>Mastering Django's Built-in User Model: 2-3 weeks</p> <ul> <li>Daily Commitment: 2-3 hours.</li> <li>Focus on authentication, custom user models, and forms.</li> </ul> </li> <li> <p>Advanced Django Concepts: 4-6 weeks</p> <ul> <li>Daily Commitment: 2-3 hours.</li> <li>Learn class-based views, Django REST Framework, and optimization techniques.</li> </ul> </li> <li> <p>Front-End Integration: 3-4 weeks</p> <ul> <li>Daily Commitment: 2-3 hours.</li> <li>Learn a front-end framework and how to integrate it with Django.</li> </ul> </li> <li> <p>Security Best Practices: 2 weeks</p> <ul> <li>Daily Commitment: 1-2 hours.</li> <li>Study user data protection and common vulnerabilities.</li> </ul> </li> <li> <p>Deployment and DevOps: 2-3 weeks</p> <ul> <li>Daily Commitment: 2-3 hours.</li> <li>Learn about deploying applications and CI/CD.</li> </ul> </li> <li> <p>Real-World Projects: 4-8 weeks</p> <ul> <li>Daily Commitment: 2-4 hours.</li> <li>Build complex applications and contribute to open-source projects.</li> </ul> </li> <li> <p>Stay Updated and Network: Ongoing</p> <ul> <li>Engage with the community, attend meetups, and follow Django updates.</li> </ul> </li> <li> <p>Advanced Topics: 4-6 weeks (optional)</p> <ul> <li>Daily Commitment: 2-3 hours.</li> <li>Explore asynchronous programming, GraphQL, and microservices.</li> </ul> </li> </ol>"},{"location":"APIs/drf/topic/learning-path/#total-estimated-time","title":"Total Estimated Time","text":"<p>Approximately 4-6 months (assuming a part-time commitment of 1-4 hours daily).</p>"},{"location":"APIs/drf/topic/learning-path/#additional-tips","title":"Additional Tips","text":"<ul> <li>Adjust the Timeline: This timeline can be shortened or extended based on your dedication and prior experience.</li> <li>Consistency is Key: Regular practice and building projects will reinforce your learning.</li> <li>Engage with Others: Collaborating with others can accelerate your understanding and expose you to new ideas.</li> </ul> <p>Ultimately, mastering Django and becoming a top-level developer is a continuous journey. Focus on learning, building, and staying curious, and you\u2019ll see significant progress over time!</p>"},{"location":"APIs/fastAPI/fast-api/","title":"Fast API","text":"<p>FastAPI targets development of web APIs. FastAPI was mainly designed to build APIs, and its default input is <code>JSON</code>. FastAPI itself does not include a web server but recommends <code>Uvicorn</code>.</p> <pre><code>$ pip install fastapi uvicorn\n</code></pre> <p>You can start <code>Uvicorn</code> and the FastAPI web application in two ways:</p> <ol> <li>externally (or)</li> <li>internally</li> </ol>"},{"location":"APIs/fastAPI/fast-api/#1-to-start-uvicorn-externally-via-the-command-line","title":"1. To start Uvicorn externally, via the command line","text":"<pre><code># Start Uvicorn with the command line\n$ uvicorn hello:app --reload\n\n# The hello refers to the hello.py file, and app is the FastAPI variable name within it.\n</code></pre>"},{"location":"APIs/fastAPI/fast-api/#2-to-start-uvicorn-internally-in-the-application-itself","title":"2. To start Uvicorn internally in the application itself","text":"<pre><code># Start Uvicorn internally\n\nfrom fastapi import FastAPI\n\napp = FastAPI()\n\n@app.get(\"/hi\")\ndef greet():\n  return \"Hello? World?\"\n\nif __name__ == \"__main__\":\n  import uvicorn\n  uvicorn.run(\"hello:app\", reload=True)\n</code></pre> <p>In either case, that reload tells Uvicorn to restart the web server if hello.py changes.</p>"},{"location":"APIs/fastAPI/fast-api/#test-fastapi-after-installing","title":"Test FastAPI after Installing","text":"<p>To make sure the installation worked, we can open a Python interactive shell and try to import the <code>FastAPI</code> package:</p> <pre><code>$ python\n\n&gt;&gt;&gt; from fastapi import FastAPI\n</code></pre>"},{"location":"APIs/fastAPI/fast-api/#installing-the-httpie-command-line-utility","title":"Installing the HTTPie command-line utility","text":"<ul> <li><code>FastAPI</code> automatic documentation (we'll talk about this later in the book)</li> <li><code>Postman</code>, a GUI tool to perform HTTP requests</li> <li><code>cURL</code>, the well-known and widely used command-line tool to perform   network requests</li> <li><code>HTTPie</code>, a command-line tool aimed at making HTTP   requests with an intuitive syntax, JSON support, and syntax highlighting.</li> </ul> <pre><code># GET\n$ http GET https://603cca51f4333a0017b68509.mockapi.io/todos\n\n#POST\n$ http -v POST https://603cca51f4333a0017b68509.mockapi.io/todos text=\"My new task\"\n\n#\n$ http -v GET https://603cca51f4333a0017b68509.mockapi.io/todos \"My-Header: My-Header-Value\"\n</code></pre>"},{"location":"APIs/fastAPI/fast-api/#web-tools","title":"Web Tools","text":"<p>The main Python web tools (FastAPI):</p> <ul> <li><code>FastAPI</code>: The web framework itself</li> <li><code>Uvicorn</code>: An asynchronous web server</li> <li><code>HTTPie</code>: A text web client, similar to curl</li> <li><code>Requests</code>: A synchronous web client package</li> <li><code>HTTPX</code>: A synchronous/asynchronous web client package</li> </ul>"},{"location":"APIs/fastAPI/fast-api/#sqlalchemy","title":"SQLAlchemy","text":"<p>SQLAlchemy is the most popular ORM library and can establish communication between any Python-based application and database platform.</p> <p>This ORM is a boilerplated interface that aims to create a database-agnostic data layer that can connect to any database engine. But compared to other ORMs, SQLAlchemy is DBA-friendly because it can generate optimized native SQL statements.</p> <pre><code>pip install SQLAlchemy\n</code></pre>"},{"location":"APIs/fastAPI/fast-api/#installing-the-database-driver","title":"Installing the database driver","text":"<p>SQLAlchemy will not work without the required database driver. It is mandatory to install the <code>psycopg2</code> dialect since the database of choice is PostgreSQL:</p> <pre><code>pip install psycopg2\n</code></pre>"},{"location":"APIs/fastAPI/fast-api/#reference","title":"Reference","text":"<ul> <li>FastAPI: Modern Python Web Development by Bill Lubanovic</li> </ul>"},{"location":"APIs/microservices/intro/","title":"Intro","text":""},{"location":"APIs/microservices/intro/#django-native-component","title":"Django native component","text":"<p>Exploring Django\u2019s native components for microservices web applications</p> <p>Django is a versatile web development tool and has these native components for developing microservices already on board:</p> <ul> <li>Django Rest Framework (DRF): A framework for building RESTful APIs as general microservices.</li> <li>Django Cache Framework: A framework for optimizing the performance of a microservices application.</li> </ul>"},{"location":"APIs/microservices/intro/#extenernal-django-component","title":"Extenernal Django component","text":"<p>Traversing the external components for Django microservices web applications</p> <p>The main components of a microservices architecture:</p> <ul> <li>Producer</li> <li>Task queue</li> <li>Worker</li> </ul>"},{"location":"APIs/microservices/intro/#task-and-message-queue-brokers","title":"Task and message queue brokers","text":"<p>For task and message queueing, Django collaborates with the following external components:</p> Component Purpose Type <code>Celery</code> Task queue broker Python package <code>RabbitMQ</code> Message queue broker Stand-alone software <code>Redis</code> Message queue broker and caching system Stand-alone software <p>Table 2.1 \u2013 Task and message queue brokers for Django</p> <p>There are other task and message queueing brokers, such as Dramatiq. But Celery, RabbitMQ, and Redis are the most common in the Django community; therefore, we will focus on Celery, RabbitMQ and Redis.</p>"},{"location":"APIs/microservices/intro/#reference","title":"Reference","text":"<ul> <li>Hands-On Microservices with Django by Tieme Woldman</li> </ul>"},{"location":"APIs/microservices/python-microservices/","title":"python microservices","text":""},{"location":"APIs/microservices/python-microservices/#python-questions","title":"Python Questions","text":""},{"location":"APIs/microservices/python-microservices/#topics","title":"Topics","text":"<ul> <li>What are Microservices?</li> <li>Project Introduction</li> <li>Django Setup</li> <li>Adding Docker Files</li> <li>Connect Django with MySQL with Docker</li> <li>Models &amp; Serializers</li> <li>Rest APIs with ViewSets</li> <li>User Endpoint with APIView</li> <li>Flask Setup with Docker</li> <li>Connect Flask with Mysql</li> <li>Models</li> <li>Flask Migrations</li> <li>RabbitMQ</li> <li>Django Producer and Consumer</li> <li>Flask Producer and Consumer</li> <li>Queue Service</li> <li>Data Consistency</li> <li>Internal Http Requests</li> <li>Finishing the python apps</li> <li>React Setup</li> <li>Products CRUD</li> <li>Completing the Main App</li> </ul> <ul> <li>Learn About Python Microservices - freecodecamp</li> <li>Python Microservices Web App - Full Course (youtube)</li> <li>Microservices in Python: Django, RabbitMQ and Pika</li> <li>Building Scalable Applications with Django, Celery, and RabbitMQ: A Step-by-Step Guide</li> </ul>"},{"location":"APIs/testing/guidelines-range-version-pipfile/","title":"Guidelines","text":""},{"location":"APIs/testing/guidelines-range-version-pipfile/#guidelines-for-using-exact-vs-range-of-versions-in-pipfiles","title":"Guidelines for Using Exact vs Range of Versions in Pipfiles","text":"<p>Whether to use an exact version or a range of versions depends on the type of package and the stability you want in your project. Here\u2019s a guideline to help you decide:</p>"},{"location":"APIs/testing/guidelines-range-version-pipfile/#1-core-frameworks-and-libraries-eg-django-flask-react","title":"1.  Core Frameworks and Libraries (e.g., Django, Flask, React)","text":"<ul> <li> <p>Use a Range of Versions: For widely-used frameworks like Django, it's best to use a range of versions, as these libraries are well-maintained, and backward compatibility is usually handled well. The range allows you to benefit from minor bug fixes and security patches.</p> </li> <li> <p>Example:</p> <pre><code>django = \"&gt;=3.2, &lt;4.0\"  # Pin to Django 3.x versions\ndjangorestframework = \"&gt;=3.12, &lt;4.0\"    # Pin to DRF 3.x versions\n</code></pre> </li> <li> <p>Why Range?: These core libraries release frequent updates with important fixes or new features, and you generally want to keep your project up-to-date within a stable version range (e.g., all <code>3.x</code> versions).</p> </li> </ul>"},{"location":"APIs/testing/guidelines-range-version-pipfile/#2-utility-libraries-eg-requests-numpy","title":"2. Utility Libraries (e.g., Requests, NumPy)","text":"<ul> <li> <p>Use a Range of Versions: For well-maintained utility libraries, it\u2019s also a good idea to use a range. These packages typically have a high level of stability, and minor updates rarely break functionality.</p> </li> <li> <p>Example:</p> <pre><code>requests = \"&gt;=2.25, &lt;3.0\"\nnumpy = \"&gt;=1.19, &lt;1.24\"\n</code></pre> </li> <li> <p>Why Range?: These libraries usually evolve incrementally, and staying within a range helps avoid potential breaking changes in major releases.</p> </li> </ul>"},{"location":"APIs/testing/guidelines-range-version-pipfile/#3-security-or-essential-dependency-packages-eg-jwt-auth-libraries","title":"3.  Security or Essential Dependency Packages (e.g., JWT, Auth Libraries)","text":"<ul> <li> <p>Use Exact Versions: For packages related to security or critical components (e.g., authentication libraries), it is often safer to lock them to an exact version to avoid unexpected changes in security behavior.</p> </li> <li> <p>Example</p> <pre><code>pyjwt = \"2.1.0\"\ncryptography = \"3.4.7\"\n</code></pre> </li> <li> <p>Why Exact Version?: Security packages can sometimes introduce significant changes even in minor releases, so locking them to a tested version helps ensure stability.</p> </li> </ul>"},{"location":"APIs/testing/guidelines-range-version-pipfile/#4-development-or-build-tools-eg-linters-testing-libraries","title":"4. Development or Build Tools (e.g., Linters, Testing Libraries)","text":"<ul> <li> <p>Use Exact Versions or Very Narrow Ranges: For development tools (e.g., <code>flake8</code>, <code>pytest</code>), you may want to use exact versions or narrow ranges to ensure consistent behavior across all environments, especially in CI/CD pipelines.</p> </li> <li> <p>Example:</p> <pre><code>flake8 = \"3.9.2\"\nblack = \"21.5b0\"\npytest = \"&gt;=6.2.4, &lt;6.3\"\n</code></pre> </li> <li> <p>Why Exact or Narrow?: These tools directly impact your development workflow, and it\u2019s essential to avoid unexpected changes in formatting, testing, or code linting due to updates.</p> </li> </ul>"},{"location":"APIs/testing/guidelines-range-version-pipfile/#5-packages-in-active-development-or-with-known-instability","title":"5. Packages in Active Development or With Known Instability","text":"<ul> <li> <p>Use Exact Versions: If a package is relatively new, not well-documented, or has a history of breaking changes, it\u2019s best to use an exact version that you\u2019ve tested.</p> </li> <li> <p>Example:</p> <pre><code>some-unstable-library = \"0.5.2\"\n</code></pre> </li> <li> <p>Why Exact Version?: For packages that might introduce breaking changes frequently or are still in early development (pre-1.0 versions), you should lock the version to avoid unexpected behavior.</p> </li> </ul>"},{"location":"APIs/testing/guidelines-range-version-pipfile/#general-rule-of-thumb","title":"General Rule of Thumb:","text":"<ul> <li>Range for stability, minor updates, and flexibility: For mature and well-maintained packages.</li> <li>Exact version for security, critical dependencies, or packages with frequent breaking changes: For security or more unstable libraries.</li> </ul> <p>This balanced approach ensures you get the best of both worlds: flexibility in your main dependencies while avoiding unexpected changes in critical areas.</p> <p>Here\u2019s an example of an updated Pipfile with these recommendations:</p> <pre><code>[[source]]\nurl = \"https://pypi.org/simple\"\nverify_ssl = true\nname = \"pypi\"\n\n[packages]\ndjango = \"&gt;=3.2, &lt;4.0\"\ndjangorestframework = \"&gt;=3.12, &lt;4.0\"\n\n[dev-packages]\nflake8 = \"*\"\nblack = \"*\"\npytest = \"*\"\npytest-django = \"*\"\nsafety = \"*\"\nbandit = \"*\"\n\n[requires]\npython_version = \"3.8\"\npython_full_version = \"3.8.1\"\n</code></pre> <p>This should make your project more stable and maintainable while following good development practices.</p>"},{"location":"APIs/testing/guidelines-range-version-pipfile/#manual-vs-command-based-editing-of-pipfile-for-installing-packages","title":"Manual vs Command-Based Editing of Pipfile for Installing Packages","text":"<p>You can either manually edit (hardcode) the Pipfile or use Pipenv commands to automatically add the package with version constraints. Both approaches are valid, but it depends on your preference.</p>"},{"location":"APIs/testing/guidelines-range-version-pipfile/#option-1-hardcode-the-pipfile","title":"Option 1: Hardcode the Pipfile","text":"<p>You can manually add the version constraint directly into your Pipfile. This is useful if you want full control over the versions and dependencies.</p> <ul> <li> <p>Example:</p> <pre><code>[packages]\ndjango = \"&gt;=3.2, &lt;4.0\"\n</code></pre> </li> </ul> <p>After editing the Pipfile, simply run:</p> <pre><code>pipenv install\n</code></pre>"},{"location":"APIs/testing/guidelines-range-version-pipfile/#option-2-use-pipenv-command-to-add-version-constraints","title":"Option 2: Use Pipenv Command to Add Version Constraints","text":"<p>You can also let <code>Pipenv</code> modify the Pipfile for you by using the following command:</p> <pre><code>pipenv install \"django&gt;=3.2,&lt;4.0\"\n</code></pre> <p>This command will:</p> <ul> <li>Automatically add the specified version constraint to your Pipfile under the [packages] section.</li> <li>Install the correct version of Django within the specified range.</li> </ul> Which Method is Better? <ul> <li> <p>Hardcoding (Manual Edit): Gives you full control if you want to carefully manage or review your Pipfile. You might prefer this for large projects where you want to keep track of changes in a more controlled manner.</p> </li> <li> <p>Pipenv Command: Faster and easier, especially when adding multiple packages or if you prefer automation. This also ensures that the Pipfile is updated correctly and avoids manual errors.</p> </li> </ul> <p>Both methods achieve the same result, so it's up to your personal workflow preference.</p>"},{"location":"APIs/testing/guidelines-range-version-pipfile/#choosing-between-version-range-vs-exact-version-for-installing-django-with-pipenv","title":"Choosing Between Version Range vs Exact Version for Installing Django with Pipenv","text":"<p>Both commands serve slightly different purposes, and which one is better depends on your project\u2019s needs. Let me explain the differences between the two approaches:</p>"},{"location":"APIs/testing/guidelines-range-version-pipfile/#1-pipenv-install-django4250","title":"1.  pipenv install \"django&gt;=4.2,&lt;5.0\"","text":"<ul> <li>What it does: This command installs Django 4.2 or any newer release up to, but not including, version 5.0.</li> <li>Benefits:<ul> <li>It gives you flexibility to upgrade to minor releases (like 4.2.1, 4.3, etc.) within the 4.x series automatically when you run <code>pipenv update</code>.</li> <li>Useful if you want to always have the latest bug fixes, security patches, and features in the 4.x series without manually updating the version.</li> </ul> </li> <li>Drawback: You might unintentionally install a new minor version that could introduce changes that you\u2019re not prepared for (although minor versions generally avoid breaking changes).</li> </ul>"},{"location":"APIs/testing/guidelines-range-version-pipfile/#2-pipenv-install-django42","title":"2. pipenv install \"django==4.2\"","text":"<ul> <li>What it does: This command locks your project to exactly Django 4.2 (specifically the version 4.2.0).</li> <li>Benefits:<ul> <li>Ensures your project stays on Django 4.2.0, without automatically upgrading to newer minor versions like 4.2.1 or 4.3.</li> <li>Provides stability and control if you want to prevent any automatic upgrades and only update manually when you're ready.</li> </ul> </li> <li>Drawback: You miss out on automatic updates for bug fixes and security patches within the 4.x series unless you manually upgrade.</li> </ul> Which is Better? <ul> <li> <p>If you want flexibility to stay up-to-date with bug fixes, minor feature improvements, and security patches, use:</p> <pre><code>pipenv install \"django&gt;=4.2,&lt;5.0\"\n</code></pre> </li> <li> <p>If you prefer stability and want to control exactly which version of Django is installed without any automatic updates, use:</p> <pre><code>pipenv install \"django==4.2\"\n</code></pre> </li> </ul> <p>DRF 3.14.x is fully compatible with <code>Django 4.2</code> and <code>Python 3.8</code>.</p> <pre><code>pipenv install \"djangorestframework==3.14.0\"\n</code></pre> <p>compatible with <code>Django 4.2</code> and <code>Python 3.8</code>.</p> <pre><code>pipenv install \"django&gt;=4.2,&lt;5.0\"\npipenv install \"djangorestframework&gt;=3.14,&lt;3.15\"\n</code></pre>"},{"location":"APIs/testing/guidelines-range-version-pipfile/#recommendation","title":"Recommendation:","text":"<ul> <li>For most projects, especially long-term or production projects, pinning to a specific version (like <code>django==4.2</code>) is often the best choice to avoid unexpected changes.</li> <li>If you are comfortable with handling minor updates and want to stay up-to-date within the 4.x series, then the range version (\"<code>django&gt;=4.2,&lt;5.0</code>\") works well.</li> </ul>"},{"location":"APIs/testing/code-formating-and-linting/black/","title":"Black","text":"<p>In Python development, it's standard practice to list development tools and libraries under <code>[dev-packages]</code> in your <code>Pipfile</code> when using Pipenv. This helps differentiate between packages needed for development (like linters, formatters, and testing tools) and those needed for the application to run in production.</p> <p>The <code>black</code> package, which is a code formatter, is typically used as a development tool rather than something required for the production environment. Therefore, it should be added to <code>[dev-packages]</code>.</p> <p>Here\u2019s how you can ensure black is added to <code>[dev-packages]</code>:</p> <ol> <li> <p>Install <code>black</code> as a development package:</p> <pre><code>pipenv install --dev black\n</code></pre> <p>This command installs <code>black</code> and places it under the <code>[dev-packages]</code> section of your Pipfile.</p> </li> <li> <p>Verify your Pipfile:</p> <p>Check the Pipfile to ensure black is now listed under <code>[dev-packages]</code>:</p> <pre><code>[dev-packages]\nblack = \"*\"\n</code></pre> </li> <li> <p>Format Your Code:</p> <p>You can format your Django project's code by running <code>Black</code> on your project directory. Typically, you run it from the root of your project:</p> <pre><code>black .\n</code></pre> <p>This command will recursively format all Python files in the current directory and its subdirectories.</p> </li> </ol> <p>By following these steps, you'll keep your development dependencies properly organized and ensure that your production environment only includes the packages necessary for runtime.</p>"},{"location":"APIs/testing/code-formating-and-linting/black/#configure-black","title":"Configure Black","text":"<p>You might want to configure Black to fit your preferences. Create a <code>pyproject.toml</code> file in the root of your project if you don't already have one, and add Black\u2019s configuration to it. Here\u2019s a basic example:</p> <pre><code>Copy code\n[tool.black]\nline-length = 88\n</code></pre> <p>The <code>line-length</code> option is set to 88 by default, but you can adjust it according to your project's style guide.</p> toml<pre><code>[tool.black]\nline-length = 88\ntarget-version = ['py38']\nskip-string-normalization = true\nexclude = '''\n/(\n  \\.tox\n  | \\.nox\n  | \\.git\n  | \\.mypy_cache\n  | \\.pytest_cache\n  | \\.eggs\n  | _build\n  | buck-out\n  | build\n  | dist\n  | migrations\n)/\n'''\ninclude = '\\.pyi?$'\nverbose = true\n</code></pre>"},{"location":"APIs/testing/code-formating-and-linting/black/#integrate-black-with-your-development-workflow","title":"Integrate Black with Your Development Workflow","text":"<p>IDE Integration: Many IDEs and editors have plugins or built-in support for Black. For example, in Visual Studio Code, you can install the Black extension and configure it to format your code on save.</p> <p>Pre-commit Hook: To ensure that Black is always run before commits, you can use a pre-commit hook. First, install the <code>pre-commit</code> package:</p> <pre><code>pip install pre-commit\n</code></pre> <p>Create a <code>.pre-commit-config.yaml</code> file in your project's root directory with the following content:</p> <pre><code>repos:\n  - repo: https://github.com/pre-commit/pre-commit-hooks\n    rev: v3.4.0\n    hooks:\n      - id: trailing-whitespace\n      - id: end-of-file-fixer\n\n  - repo: https://github.com/psf/black\n    rev: 23.3.0  # Use the latest version or the one you prefer\n    hooks:\n      - id: black\n        language_version: python3\n</code></pre> <p>Then, install the pre-commit hooks:</p> <pre><code>pre-commit install\n</code></pre> <p>Now, Black will automatically format your code before each commit.</p>"},{"location":"APIs/testing/code-formating-and-linting/black/#continuous-integration-ci","title":"Continuous Integration (CI)","text":"<p>If you use a CI service (like GitHub Actions, GitLab CI, or others), you can add a step to run Black as part of your CI pipeline to ensure that all code is properly formatted before merging.</p> <p>Here\u2019s an example of a GitHub Actions workflow that runs Black:</p> <pre><code>name: Format Check\n\non: [push, pull_request]\n\njobs:\n  black:\n    runs-on: ubuntu-latest\n\n    steps:\n      - uses: actions/checkout@v2\n      - name: Set up Python\n        uses: actions/setup-python@v2\n        with:\n          python-version: '3.9'\n      - name: Install dependencies\n        run: |\n          pip install black\n      - name: Check code formatting\n        run: |\n          black --check .\n</code></pre> <p>This setup will ensure your Django project maintains a consistent style and follows best practices for code formatting.</p>"},{"location":"APIs/testing/code-formating-and-linting/black/#which-one-to-use-vs-code-or-command-line","title":"Which one to use : vs code <code>or</code> command line","text":"<p>Both methods you mentioned\u2014using the command line (black .) and the VS Code extension\u2014are effective ways to use Black, the popular Python code formatter. Your choice depends on your workflow preferences. Here\u2019s a breakdown of both approaches:</p>"},{"location":"APIs/testing/code-formating-and-linting/black/#using-black-via-command-line","title":"Using Black via Command Line","text":"<ol> <li> <p>Install Black: If you haven't already installed Black, you can do so using pip:</p> <pre><code>pip install black\npipenv install black --dev\n</code></pre> </li> <li> <p>Run Black from the Command Line: Navigate to the directory containing your Python files and run:</p> <pre><code>black .\n</code></pre> <p>This will format all Python files in the current directory and its subdirectories. You can also specify individual files or directories:</p> <pre><code>black file1.py file2.py\nblack src/\n</code></pre> </li> <li> <p>Optional Configuration: You can create a pyproject.toml file in your project root to customize Black's behavior. For example:</p> <pre><code>[tool.black]\nline-length = 88\n</code></pre> </li> </ol>"},{"location":"APIs/testing/code-formating-and-linting/black/#using-black-with-vs-code-extension","title":"Using Black with VS Code Extension","text":"<ol> <li> <p>Install the Black Extension: Open VS Code, go to the Extensions view (<code>Ctrl+Shift+X</code>), and search for \"Black Formatter\" or \"Python\". You might find it as part of the Python extension by Microsoft or as a standalone extension.</p> </li> <li> <p>Configure VS Code to Use Black:</p> <ul> <li>Open the Command Palette (<code>Ctrl+Shift+P</code>) and search for \"Preferences: Settings\".</li> <li>Search for \"Python Formatting Provider\" and set it to black.</li> <li>To format on save, search for \"Format On Save\" in the settings and ensure it is checked.</li> </ul> </li> <li> <p>Optional Configuration: Just like with the command line, you can create a <code>pyproject.toml</code> file to customize Black\u2019s behavior if needed.</p> </li> </ol> Choosing Between the Two <ul> <li> <p>Command Line:</p> <ul> <li>Suitable for batch processing or if you\u2019re working in a non-IDE environment.</li> <li>Provides flexibility and control, especially if you work in different editors or environments.</li> </ul> </li> <li> <p>VS Code Extension:</p> <ul> <li>Convenient for developers who prefer to stay within the VS Code environment.</li> <li>Automatically formats code on save, which can streamline your workflow.</li> </ul> </li> </ul> <p>Ultimately, using the extension may be more convenient for daily coding tasks if you\u2019re working primarily within VS Code, while the command line approach might be better for scripting or CI/CD pipelines. You can also use both methods in tandem, depending on your needs.</p>"},{"location":"APIs/testing/code-formating-and-linting/flake8/","title":"Flake8","text":"<p>To use <code>flake8</code> with your Python project in VSCode, you typically need to have both <code>flake8</code> and <code>pipenv</code> installed. Here\u2019s a breakdown of what you might need:</p> <ol> <li> <p>Flake8: This is a tool for checking the style guide enforcement in Python code. It needs to be installed in your Python environment. You can install it using pip:</p> <pre><code>pip install flake8\n</code></pre> </li> <li> <p>Pipenv: This is a tool for managing Python dependencies and virtual environments. If you're using <code>pipenv</code> to manage your project's dependencies, you should also install <code>flake8</code> within the pipenv environment:</p> <pre><code>pipenv install --dev flake8\n</code></pre> </li> <li> <p>VSCode Extension: The VSCode extension for Python can integrate with tools like <code>flake8</code>. You should install the Python extension for VSCode if you haven\u2019t already:</p> <ul> <li>Go to the Extensions view in VSCode (Ctrl+Shift+X or Cmd+Shift+X).</li> <li>Search for \"Python\" and install the extension provided by Microsoft.</li> </ul> <p>After installing the Python extension, you can configure it to use <code>flake8</code> by adding the following settings to your workspace or user settings (<code>.vscode/settings.json</code>):</p> <pre><code>{\n    \"python.linting.enabled\": true,\n    \"python.linting.flake8Enabled\": true\n}\n</code></pre> <pre><code>{\n    \"python.linting.enabled\": true,\n    \"python.linting.lintOnSave\": true,\n    \"python.linting.flake8Enabled\": true\n}\n</code></pre> </li> </ol> <p>In summary, you need to install both <code>flake8</code> and <code>pipenv</code> in your development environment, and you should also install and configure the Python extension in VSCode to use <code>flake8</code> for linting.</p>"},{"location":"APIs/testing/code-formating-and-linting/flake8/#configuration-file-precedence","title":"Configuration File Precedence","text":"<p><code>flake8</code> supports multiple configuration file formats, but it might have certain preferences or limitations. Here\u2019s how configuration files are typically read by flake8:</p> <ol> <li> <p>Configuration File Formats Supported by Flake8:</p> <ul> <li><code>.flake8</code> (specific configuration file for flake8)</li> <li><code>setup.cfg</code> (can contain [flake8] section)</li> <li><code>tox.ini</code> (can contain [flake8] section)</li> <li><code>pyproject.toml</code> (can contain [tool.flake8] section)</li> </ul> </li> <li> <p>Configuration File Precedence:</p> <ul> <li><code>.flake8</code> file typically takes precedence if it exists.</li> <li><code>setup.cfg</code> and tox.ini files are read if no .flake8 file is present.</li> <li><code>pyproject.toml</code> support is more recent and might not be recognized in older versions of flake8.</li> </ul> </li> </ol> <p>While <code>flake8</code> should theoretically support <code>pyproject.toml</code> configuration, <code>.flake8</code>, <code>setup.cfg</code>, and <code>tox.ini</code> are more commonly used and might be more reliable. If your <code>pyproject.toml</code> file isn\u2019t being recognized, double-check the flake8 version, file format, and placement of the configuration file. If needed, sticking with <code>.flake8</code> or <code>setup.cfg</code> might be a more straightforward solution.</p>"},{"location":"APIs/testing/code-quality/code-quality-package/","title":"Code Quality","text":"<ol> <li> <p>Code Formatting:</p> <ul> <li>Black: An opinionated code formatter that enforces a consistent code style. It's highly automated and minimizes the need for manual formatting decisions.</li> <li>isort: A tool to sort imports in a consistent way. It can be configured to work with Black.</li> </ul> </li> <li> <p>Linting and Style Checking:</p> <ul> <li>flake8: A tool that combines the functionality of pyflakes (for logical errors), pycodestyle (for style guide enforcement), and mccabe (for complexity checking). It helps identify potential issues in your code.</li> <li>pylint: A comprehensive tool that checks for coding standards, errors, and possible improvements. It\u2019s highly configurable but can be more verbose than flake8.</li> </ul> </li> <li> <p>Type Checking:</p> <ul> <li>mypy: A static type checker for Python. If you use type annotations, mypy can help ensure your code adheres to the specified types.</li> </ul> </li> <li> <p>Security:</p> <ul> <li>bandit: A tool designed to find common security issues in Python code.</li> </ul> </li> </ol> <p>Using these tools and practices will help you maintain high code quality and ensure that your Django and DRF APIs are well-tested and reliable.</p>"},{"location":"APIs/testing/code-quality/code-testing-package/","title":"Code Testing","text":"<ol> <li> <p>Testing Frameworks:</p> <ul> <li>pytest: A powerful testing framework with a rich ecosystem of plugins. It supports fixtures, parameterized testing, and has a simple syntax.</li> <li>unittest: The built-in testing framework that comes with Python. It\u2019s less feature-rich than pytest but is standard and well-integrated.</li> </ul> </li> <li> <p>Django and DRF Testing:</p> <ul> <li>pytest-django: A pytest plugin for Django. It provides Django-specific fixtures and helps run tests in a Django environment.</li> <li>pytest-factoryboy: An integration for <code>pytest</code> and <code>factory_boy</code>, which simplifies creating test data.</li> </ul> </li> <li> <p>Mocking and Fixtures:</p> <ul> <li>factory_boy: A flexible library for creating test fixtures and data.</li> <li>freezegun: A library to mock the passage of time in your tests, useful for testing time-based logic.</li> </ul> </li> <li> <p>Code Coverage:</p> <ul> <li>coverage.py: A tool for measuring code coverage of your tests. It helps identify parts of your code that are not covered by tests.</li> </ul> </li> <li> <p>API Testing:</p> <ul> <li>drf-spectacular: Generates OpenAPI 3.0 schemas for DRF, which can be useful for API documentation and testing.</li> <li>django-rest-framework: DRF's built-in test tools for API testing, including <code>APITestCase</code> for writing tests for your DRF views and serializers.</li> </ul> </li> </ol> <p>Using these tools and practices will help you maintain high code quality and ensure that your Django and DRF APIs are well-tested and reliable.</p>"},{"location":"APIs/testing/code-quality/coding-style-django/","title":"Coding Style","text":"Coding style <ul> <li>Pre-commit checks</li> <li>Python style</li> <li>Imports</li> <li>Template style</li> <li>View style</li> <li>Model style</li> <li>Use of django.conf.settings</li> <li>Miscellaneous</li> <li>JavaScript style</li> </ul>"},{"location":"APIs/testing/code-quality/coding-style-django/#coding-style","title":"Coding style","text":""},{"location":"APIs/testing/code-quality/coding-style-django/#pre-commit-checks","title":"Pre-commit checks","text":"<p>pre-commit is a framework for managing pre-commit hooks. These hooks help to identify simple issues before committing code for review. By checking for these issues before code review it allows the reviewer to focus on the change itself, and it can also help to reduce the number of CI runs.</p> <p>To use the tool, first install pre-commit and then the git hooks:</p> <pre><code>$ python -m pip install pre-commit\n$ pre-commit install\n</code></pre> <p>On the first commit pre-commit will install the hooks, these are installed in their own environments and will take a short while to install on the first run. Subsequent checks will be significantly faster. If an error is found an appropriate error message will be displayed. If the error was with black or isort then the tool will go ahead and fix them for you. Review the changes and re-stage for commit if you are happy with them.</p>"},{"location":"APIs/testing/code-quality/coding-style-django/#python-style","title":"Python style","text":"<ul> <li>All files should be formatted using the black auto-formatter. This will be run by pre-commit if that is configured.</li> </ul>"},{"location":"APIs/testing/code-quality/intro/","title":"Intro","text":"Code Quality and Testing: <ul> <li>Black: A code formatter for Python to enforce consistent code style.</li> <li>isort: A tool for sorting imports in Python files.</li> <li>flake8: A tool for checking the style guide enforcement.</li> <li>pytest: A framework for running tests; it can be used alongside Django\u2019s test framework.</li> <li>coverage: To measure code coverage for your tests.</li> </ul>"},{"location":"APIs/testing/code-quality/intro/#summary-of-commonly-used-packages","title":"Summary of Commonly Used Packages","text":"<ul> <li>Code Formatting: <code>black</code>, <code>isort</code></li> <li>Linting and Style Checking: <code>flake8</code>, <code>pylint</code></li> <li>Type Checking: <code>mypy</code></li> <li>Security: <code>bandit</code></li> <li>Testing Frameworks: <code>pytest</code>, <code>unittest</code></li> <li>Django and DRF Testing: <code>pytest-django</code>, <code>factory_boy</code></li> <li>Code Coverage: <code>coverage.py</code></li> <li>API Testing: <code>drf-spectacular</code></li> </ul> <p>These tools are widely adopted in the Django and DRF communities and are commonly used to ensure high code quality and effective testing in Python projects.</p> <p> </p>"},{"location":"APIs/testing/code-quality/intro/#guide","title":"Guide","text":"<p>Absolutely! For a beginner, it\u2019s important to start with tools that are straightforward to set up and use while gradually incorporating more advanced tools as you become more comfortable. Here\u2019s a step-by-step guide to getting started with linting and testing, and how to gradually improve:</p>"},{"location":"APIs/testing/code-quality/intro/#1-starting-with-basic-tools","title":"1.  Starting with Basic Tools","text":"Linting and Style Checking <ol> <li> <p>Flake8:</p> <ul> <li> <p>Why Start Here: <code>flake8</code> is user-friendly and combines multiple functionalities into one tool. It\u2019s excellent for beginners because it helps with both style and logical errors with minimal setup.</p> </li> <li> <p>Setup:</p> <pre><code>pip install flake8\n</code></pre> </li> <li> <p>Basic Configuration: Create a <code>.flake8</code> file in your project root (or use <code>setup.cfg</code>) to configure basic settings:</p> <pre><code>[flake8]\nmax-line-length = 79\n</code></pre> </li> <li> <p>Usage: Run <code>flake8</code> from the command line:</p> <pre><code>flake8\n</code></pre> </li> <li> <p>Integration: You can integrate <code>flake8</code> with your IDE or text editor to get real-time feedback on code style issues.</p> </li> </ul> </li> </ol>"},{"location":"APIs/testing/code-quality/intro/#2-pytest","title":"2. Pytest:","text":"Testing <ul> <li> <p>Why Start Here: <code>pytest</code> is widely used, has an easy-to-learn syntax, and provides powerful features for writing and running tests.</p> </li> <li> <p>Setup:</p> <pre><code>pip install pytest\n</code></pre> </li> <li> <p>Basic Test Example: Create a file named <code>test_example.py</code>:</p> <pre><code>def test_addition():\n    assert 1 + 1 == 2\n</code></pre> </li> <li> <p>Usage: Run tests with:</p> <pre><code>pytest\n</code></pre> </li> <li> <p>Integration: <code>pytest</code> is also compatible with many IDEs and text editors for running and debugging tests.</p> </li> </ul>"},{"location":"APIs/testing/code-quality/intro/#3-additional-tips","title":"3. Additional Tips","text":"<ul> <li>Use a <code>requirements.txt</code> or <code>Pipfile</code> to manage your dependencies, including <code>flake8</code>, <code>pytest</code>, <code>pylint</code>, and any other tools you add.</li> <li>Integrate with CI/CD: As you become more comfortable, set up continuous integration (CI) to automatically run your linting and tests.</li> <li>Automate with Pre-commit Hooks: Use <code>pre-commit</code> hooks to run linters and formatters before each commit, ensuring code quality is maintained.</li> </ul>"},{"location":"APIs/testing/code-quality/intro/#summary","title":"Summary","text":"<ul> <li>Start with Flake8 and Pytest for basic linting and testing.</li> <li>Add Pylint for more detailed code analysis once you're comfortable.</li> <li>Incorporate Coverage and Factory Boy as your tests and codebase grow.</li> </ul> <p>Gradually incorporating these tools will help you maintain code quality and ensure your Django projects are well-tested and reliable.</p>"},{"location":"APIs/testing/framework/basic-test-example/","title":"Basic 101","text":""},{"location":"APIs/testing/framework/basic-test-example/#debug-with-a-simplified-test","title":"Debug with a Simplified Test","text":"<p>Create a minimal test case to isolate the issue.</p> <pre><code># custom_apps/accounts/tests/test_basic.py\nfrom django.test import TestCase\n\nclass BasicTests(TestCase):\n    def test_basic(self):\n        self.assertTrue(True)\n</code></pre> <p>Run this test:</p> <pre><code>python3 manage.py test custom_apps.accounts.tests.test_basic\n</code></pre>"},{"location":"APIs/testing/framework/basic-test-example/#verify-import-paths","title":"Verify Import Paths","text":"<p>When running tests, Django uses the module path relative to your Django project\u2019s root directory. Ensure that you are using the correct path to the test module.</p> <p>Try running the test using the full module path:</p> <pre><code>python3 manage.py test custom_apps.accounts.tests.test_authentication\n</code></pre>"},{"location":"APIs/testing/framework/basic-test-example/#check-for-__init__py-files","title":"Check for <code>__init__.py</code> Files","text":"<p>Ensure that each directory in your app has an <code>__init__.py</code> file, including the <code>tests</code> directory. This file can be empty but is necessary for Python to recognize the directory as a package.</p> <p><code>accounts/tests/__init__.py</code>:</p> <pre><code># This file can be empty\n</code></pre>"},{"location":"APIs/testing/framework/basic-test-example/#test-djangos-shell-import","title":"Test Django\u2019s Shell Import","text":"<p>Try importing the <code>test_basic</code> module manually from Django\u2019s shell to verify that it can be loaded correctly.</p> <pre><code>python3 manage.py shell\n\n&gt;&gt;&gt; from custom_apps.accounts.tests.test_basic import BasicTests\n</code></pre> test_basic.py<pre><code># custom_apps/accounts/tests/test_basic.py\nfrom django.test import TestCase\n\n\nclass BasicTests(TestCase):\n    def test_basic(self):\n        self.assertTrue(True)\n</code></pre> <p>If the import fails, there might be an issue with the module path or the file itself.</p>"},{"location":"APIs/testing/framework/basic-test-example/#summary","title":"Summary","text":"<ul> <li>Verify Directory Structure: Ensure the <code>accounts</code> app and <code>tests</code> directory are correctly structured.</li> <li>Check <code>INSTALLED_APPS</code>: Confirm custom_apps.accounts is in <code>INSTALLED_APPS</code>.</li> <li>Use Correct Path: Run tests using the correct full module path.</li> <li>Ensure <code>__init__.py</code> Exists: Check that all directories have <code>__init__.py</code> files.</li> <li>Debug Imports: Use Django\u2019s shell to test imports manually.</li> <li>Simplify and Test: Create a minimal test case to isolate issues.</li> </ul> <p>By following these steps, you should be able to identify and resolve the issue preventing your test module from being imported and executed.</p>"},{"location":"APIs/testing/framework/django-testing-framework/","title":"Details","text":"<p>Django's testing framework is a set of tools and utilities provided by the Django web framework to help you test your Django applications. It's designed to make it easier to write, run, and manage tests for your Django projects, ensuring that your code behaves as expected and that you can catch bugs early in the development process.</p> <p>Here's a brief overview of what the Django testing framework offers:</p> <ol> <li> <p>Test Case Classes:</p> <p>Django provides a base class, <code>django.test.TestCase</code>, which you can use to create unit tests. These are subclasses of Python's built-in <code>unittest.TestCase</code>, but with additional Django-specific features.</p> </li> <li> <p>Test Client:</p> <p>Django includes a test client that simulates a web browser. This allows you to make requests to your application and test the responses, helping you verify that your views and templates are working correctly.</p> </li> <li> <p>Fixtures:</p> <p>You can use fixtures to load data into your test database before running your tests. Fixtures can be in various formats, such as JSON or XML, and are useful for setting up the initial state of your database.</p> </li> <li> <p>Database Isolation:</p> <p>Django\u2019s test framework uses a separate test database for running tests. This ensures that tests do not interfere with your production or development data. The test database is created and destroyed for each test case, providing a clean environment.</p> </li> <li> <p>Assertions:</p> <p>Django provides various assertion methods that you can use in your test cases to check the behavior of your application. These include standard assertions from <code>unittest.TestCase</code> as well as Django-specific assertions for checking things like the presence of a template or the status code of a response.</p> </li> <li> <p>Test Discovery:</p> <p>Django can automatically discover and run tests in your project. You can use management commands like <code>python manage.py test</code> to find and execute tests.</p> </li> <li> <p>Coverage Reporting:</p> <p>While not built into Django directly, you can use third-party tools like <code>coverage.py</code> in conjunction with Django's testing framework to measure how much of your code is covered by tests.</p> </li> </ol> <p>Overall, Django's testing framework aims to make it straightforward to test various aspects of your application, from individual units of code to the behavior of your entire application, ensuring robust and reliable software development.</p>"},{"location":"APIs/testing/framework/django-testing-framework/#code","title":"Code","text":"<pre><code>from django.test import TestCase, Client\n\nclass MyModelTest(TestCase):\n    def test_something(self):\n        # Your test code here\n</code></pre> <p>In Django\u2019s testing framework, there are several important classes and functions you\u2019ll frequently import to write effective tests. Here\u2019s a breakdown of the key classes and what they do:</p> Built-in functions and methods <ul> <li>Setup and Teardown: <code>setUp</code>, <code>tearDown</code></li> <li>Assertions: assertEqual, assertNotEqual, assertTrue, assertFalse, assertIn, assertNotIn, assertContains, assertNotContains, assertTemplateUsed, -  assertRedirects, assertFormError, assertNoFormError</li> <li>Exception Testing: <code>assertRaises</code></li> <li>URL Resolution: <code>reverse</code></li> <li>Settings Override: <code>override_settings</code></li> </ul> <ol> <li> <p>django.test.TestCase</p> ImportDescriptionUsage <pre><code>from django.test import TestCase\n</code></pre> <ul> <li>This is the base class for writing unit tests in Django.</li> <li>It extends Python\u2019s standard <code>unittest.TestCase</code> and provides additional Django-specific functionalities, such as setting up and tearing down a test database.</li> </ul> <pre><code>class MyModelTest(TestCase):\n    def setUp(self):\n        # Setup code here\n        pass\n\n    def test_something(self):\n        # Test code here\n        pass\n</code></pre> </li> <li> <p>django.test.Client</p> ImportDescriptionUsage <pre><code>from django.test import Client\n</code></pre> <ul> <li>The <code>Client</code> class simulates a web browser, allowing you to make HTTP requests and test the responses of your views.</li> </ul> <pre><code>class MyViewTest(TestCase):\n    def setUp(self):\n        self.client = Client()\n\n    def test_view(self):\n        response = self.client.get('/url/')\n        self.assertEqual(response.status_code, 200)\n</code></pre> </li> <li> <p>django.test.RequestFactory</p> ImportDescriptionUsage <pre><code>from django.test import RequestFactory\n</code></pre> <ul> <li><code>RequestFactory</code> allows you to create mock request objects for testing purposes without hitting the URL routing system.</li> </ul> <pre><code>class MyModelTest(TestCase):\n    def setUp(self):\n        self.factory = RequestFactory()\n\n    def test_view(self):\n        request = self.factory.get('/url/')\n        response = my_view(request)\n        self.assertEqual(response.status_code, 200)\n</code></pre> </li> <li> <p>django.test.SimpleTestCase</p> ImportDescriptionUsage <pre><code>from django.test import SimpleTestCase\n</code></pre> <ul> <li>A lighter version of <code>TestCase</code> that doesn\u2019t require database access. Use it when you\u2019re only testing views or forms and don\u2019t need a test database.</li> </ul> <pre><code>class MySimpleTest(SimpleTestCase):\n    def test_view(self):\n        response = self.client.get('/url/')\n        self.assertEqual(response.status_code, 200)\n</code></pre> </li> <li> <p>django.test.TransactionTestCase</p> ImportDescriptionUsage <pre><code>from django.test import TransactionTestCase\n</code></pre> <ul> <li>Extends <code>TestCase</code> and is used when you need to test code that requires transactions, such as database queries that are not rolled back between tests.</li> </ul> <pre><code>class MyTransactionTest(TransactionTestCase):\n    def test_transaction(self):\n        # Test code that involves database transactions\n        pass\n</code></pre> </li> <li> <p>django.test.LiveServerTestCase</p> ImportDescriptionUsage <pre><code>from django.test import LiveServerTestCase\n</code></pre> <ul> <li>This class sets up a live Django server that can be used for testing with Selenium or other tools that require a live server.</li> </ul> <pre><code>class MyLiveServerTest(LiveServerTestCase):\n    def test_live_server(self):\n        # Test code that interacts with the live server\n        pass\n</code></pre> </li> <li> <p>django.urls.reverse</p> ImportDescriptionUsage <pre><code>from django.urls import reverse\n</code></pre> <ul> <li><code>reverse</code> is used to obtain the URL of a view by reversing the URL pattern name. This helps in making tests more maintainable by using view names instead of hard-coded URLs.</li> </ul> <pre><code>class MyViewTest(TestCase):\n    def test_view(self):\n        url = reverse('view_name')\n        response = self.client.get(url)\n        self.assertEqual(response.status_code, 200)\n</code></pre> </li> <li> <p>django.test.override_settings</p> ImportDescriptionUsage <pre><code>from django.test import override_settings\n</code></pre> <ul> <li>A decorator to temporarily override settings during tests. Useful for changing settings like database configurations or email backends.</li> </ul> <pre><code>@override_settings(DEBUG=True)\nclass MyTest(TestCase):\n    def test_debug_setting(self):\n        # Test code here\n        pass\n</code></pre> </li> </ol>"},{"location":"APIs/testing/framework/django-testing-framework/#summary","title":"Summary","text":"<p>Here\u2019s a quick reference for imports and their purposes:</p> <ul> <li><code>TestCase</code>: Basic unit testing with Django-specific features.</li> <li><code>Client</code>: Simulate HTTP requests and responses.</li> <li><code>RequestFactory</code>: Create mock request objects.</li> <li><code>SimpleTestCase</code>: Lightweight tests without database interaction.</li> <li><code>TransactionTestCase</code>: Tests involving database transactions.</li> <li><code>LiveServerTestCase</code>: Tests that require a live server.</li> <li><code>reverse</code>: Resolve view names to URLs.</li> <li><code>override_settings</code>: Temporarily change settings for tests.</li> </ul> <p>By mastering these classes and tools, you\u2019ll be well-equipped to write thorough and effective tests for your Django applications.</p>"},{"location":"APIs/testing/framework/django-testing-framework/#question-1","title":"Question 1","text":"<p>Django's testing framework doesn\u2019t have a separate name; it's simply part of the Django framework and is integrated with Python's standard <code>unittest</code> module. The testing utilities and tools provided by Django extend and build upon <code>unittest</code> to offer Django-specific features.</p> Here\u2019s how it works <ul> <li> <p>Base Framework: Django\u2019s testing framework is based on Python\u2019s <code>unittest</code> module. This means it uses classes and methods from <code>unittest</code> for defining and running tests.</p> </li> <li> <p>Django Extensions: Django adds additional capabilities through its <code>django.test</code> module, which includes:</p> <ul> <li><code>django.test.TestCase</code>: A subclass of <code>unittest.TestCase</code> that provides additional features for testing Django applications.</li> <li>Test Client: Allows simulating HTTP requests to your Django application.</li> <li>Test Fixtures: Tools to load data into the test database.</li> <li>Django-specific Assertions: Methods to assert specific conditions related to Django\u2019s features.</li> </ul> </li> </ul> <p>In summary, while Django\u2019s testing framework is built on top of unittest, it doesn\u2019t have a unique name of its own. It is simply referred to as Django\u2019s testing tools or Django\u2019s testing framework, reflecting its integration with unittest and its additional Django-specific enhancements.</p>"},{"location":"APIs/testing/framework/django-testing-framework/#question-2","title":"Question 2","text":"<p>Django uses the built-in Python unittest framework for its testing, but it provides additional tools and utilities to enhance the testing experience. </p> <p>Here\u2019s a breakdown of the testing components and frameworks involved:</p> <ol> <li> <p>Python\u2019s unittest Framework</p> <p>Django\u2019s testing framework is built on top of Python\u2019s standard unittest module, which provides:</p> <ul> <li>Test Cases: Classes that inherit from <code>unittest.TestCase</code> to group related tests.</li> <li>Assertions: Methods to verify conditions (e.g., <code>assertEqual</code>, <code>assertTrue</code>).</li> </ul> </li> <li> <p>Django\u2019s Testing Tools</p> <p>Django extends unittest with its own testing utilities:</p> <ul> <li><code>django.test.TestCase</code>: A subclass of <code>unittest.TestCase</code> that sets up a test database and provides methods to simplify testing.</li> <li>Test Client: Allows you to simulate requests to your Django application and test responses.</li> <li>Fixtures: Tools to load initial data into the test database before running tests.</li> <li>Assertions: Django-specific assertions to check template usage, response content, etc.</li> </ul> </li> <li> <p>Additional Tools and Libraries</p> <p>To extend or complement Django\u2019s built-in testing capabilities, you might use other libraries:</p> <ul> <li> <p><code>pytest</code>: A popular third-party testing framework that can be used with Django for more advanced features, such as fixtures, parameterized tests, and a more readable test output.</p> <ul> <li>Integration: You can use <code>pytest-django</code> to integrate <code>pytest</code> with Django, allowing you to leverage pytest's features while writing Django tests.</li> </ul> </li> <li> <p><code>factory_boy</code>: A library for creating test fixtures and generating test data. It can be used to easily create model instances for testing.</p> </li> <li> <p><code>coverage.py</code>: Measures how much of your code is executed during testing. Useful for understanding test coverage and identifying untested parts of your application.</p> </li> <li> <p><code>mock</code>: Part of Python\u2019s standard library as <code>unittest.mock</code> for creating mock objects to simulate and test interactions with external services or components.</p> </li> </ul> </li> </ol>"},{"location":"APIs/testing/framework/intro/","title":"Intro","text":"<p>Welcome to the world of testing! Testing is a crucial part of software development, and it\u2019s great that you\u2019re diving into it. Here's a quick guide on testing in Django and Django REST Framework (DRF), along with some information on test-driven development (TDD).</p>"},{"location":"APIs/testing/framework/intro/#testing-in-django","title":"Testing in Django","text":"<ol> <li> <p>Understand Django\u2019s Testing Framework: Django comes with a built-in testing framework that extends Python's <code>unittest</code> module. This framework allows you to create test cases for your Django applications.</p> </li> <li> <p>Create Test Cases:</p> <ul> <li>Unit Tests: Test individual components, like models and functions, in isolation.</li> <li>Integration Tests: Test how different components work together, like testing views and their interaction with the database.</li> </ul> <pre><code>from django.test import TestCase\nfrom .models import MyModel\n\nclass MyModelTestCase(TestCase):\n    def setUp(self):\n        MyModel.objects.create(name=\"test\")\n\n    def test_model_str(self):\n        obj = MyModel.objects.get(name=\"test\")\n        self.assertEqual(str(obj), \"test\")\n</code></pre> </li> <li> <p>Use Django\u2019s Test Client: For testing views, you can use Django\u2019s <code>TestClient</code> to simulate requests and inspect responses.</p> <pre><code>from django.test import TestCase, Client\n\nclass MyViewTestCase(TestCase):\n    def setUp(self):\n        self.client = Client()\n\n    def test_view_status_code(self):\n        response = self.client.get('/my-url/')\n        self.assertEqual(response.status_code, 200)\n</code></pre> </li> <li> <p>Run Your Tests: Use the following command to run your tests:</p> <pre><code>python manage.py test\n</code></pre> </li> </ol>"},{"location":"APIs/testing/framework/intro/#testing-in-django-rest-framework-drf","title":"Testing in Django REST Framework (DRF)","text":"<ol> <li> <p>Use DRF\u2019s Testing Tools: DRF provides a set of tools for testing APIs, including the APITestCase class.</p> <pre><code>from rest_framework.test import APITestCase\nfrom rest_framework import status\n\nclass MyAPITestCase(APITestCase):\n    def test_get_endpoint(self):\n        response = self.client.get('/api/my-endpoint/')\n        self.assertEqual(response.status_code, status.HTTP_200_OK)\n</code></pre> </li> <li> <p>Test Your API Endpoints:</p> <ul> <li>GET Requests: Test retrieving data.</li> <li>POST Requests: Test creating new records.</li> <li>PUT/PATCH Requests: Test updating existing records.</li> <li>DELETE Requests: Test deleting records.</li> </ul> <pre><code>from rest_framework import status\nfrom rest_framework.test import APITestCase\n\nclass MyAPITestCase(APITestCase):\n    def test_create_record(self):\n        data = {'name': 'test'}\n        response = self.client.post('/api/my-endpoint/', data, format='json')\n        self.assertEqual(response.status_code, status.HTTP_201_CREATED)\n</code></pre> </li> </ol>"},{"location":"APIs/testing/framework/intro/#test-driven-development-tdd","title":"Test-Driven Development (TDD)","text":"<p>In TDD, you write your tests before writing the actual code. Here\u2019s a simplified process:</p> <ol> <li> <p>Write a Test: Start by writing a test for a new feature or functionality. Since your code doesn\u2019t exist yet, this test will fail initially.</p> </li> <li> <p>Write the Code: Implement the minimal amount of code needed to make the test pass.</p> </li> <li> <p>Run the Test: Run the test suite to see if your new test passes.</p> </li> <li> <p>Refactor: Clean up your code while ensuring all tests continue to pass.</p> </li> <li> <p>Repeat: Continue this cycle for each new feature or bug fix.</p> </li> </ol>"},{"location":"APIs/testing/framework/intro/#summary","title":"Summary","text":"<ul> <li>For Django: Use TestCase for unit and integration tests. Utilize Django\u2019s test client for view tests.</li> <li>For DRF: Use APITestCase for API endpoint testing.</li> <li>TDD: Write tests before the code, ensure they pass, and refactor.</li> </ul> <p>Starting with these basics will give you a strong foundation in testing your Django and DRF applications. As you get more comfortable, you can explore advanced testing techniques and tools. Happy testing!</p>"},{"location":"APIs/testing/framework/intro/#folder-structure","title":"Folder Structure","text":"<p>Here\u2019s a typical folder structure for a Django project with tests, including both Django and Django REST Framework (DRF) components.</p>"},{"location":"APIs/testing/framework/intro/#basic-folder-structure-for-django-testing","title":"Basic Folder Structure for Django Testing","text":"<p>Here\u2019s a typical folder structure for a Django project:</p> <pre><code>my_project/\n\u2502\n\u251c\u2500\u2500 my_app/\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 admin.py\n\u2502   \u251c\u2500\u2500 apps.py\n\u2502   \u251c\u2500\u2500 models.py\n\u2502   \u251c\u2500\u2500 tests/\n\u2502   \u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2502   \u251c\u2500\u2500 test_models.py\n\u2502   \u2502   \u251c\u2500\u2500 test_views.py\n\u2502   \u2502   \u251c\u2500\u2500 test_forms.py\n\u2502   \u2502   \u2514\u2500\u2500 test_utils.py\n\u2502   \u251c\u2500\u2500 urls.py\n\u2502   \u251c\u2500\u2500 views.py\n\u2502   \u2514\u2500\u2500 migrations/\n\u2502       \u2514\u2500\u2500 __init__.py\n\u2502\n\u251c\u2500\u2500 my_project/\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 settings.py\n\u2502   \u251c\u2500\u2500 urls.py\n\u2502   \u2514\u2500\u2500 wsgi.py\n\u2502\n\u251c\u2500\u2500 manage.py\n\u2514\u2500\u2500 requirements.txt\n</code></pre>"},{"location":"APIs/testing/framework/intro/#folder-structure-for-drf-testing","title":"Folder Structure for DRF Testing","text":"<p>When dealing with DRF, your <code>tests</code> directory might have a structure like this:</p> <pre><code>my_project/\n\u2502\n\u251c\u2500\u2500 my_app/\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 admin.py\n\u2502   \u251c\u2500\u2500 apps.py\n\u2502   \u251c\u2500\u2500 models.py\n\u2502   \u251c\u2500\u2500 views.py\n\u2502   \u251c\u2500\u2500 serializers.py\n\u2502   \u251c\u2500\u2500 urls.py\n\u2502   \u251c\u2500\u2500 tests/\n\u2502   \u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2502   \u251c\u2500\u2500 test_models.py\n\u2502   \u2502   \u251c\u2500\u2500 test_views.py\n\u2502   \u2502   \u251c\u2500\u2500 test_serializers.py\n\u2502   \u2502   \u251c\u2500\u2500 test_apis.py\n\u2502   \u2502   \u2514\u2500\u2500 test_permissions.py\n\u2502   \u2514\u2500\u2500 migrations/\n\u2502       \u2514\u2500\u2500 __init__.py\n\u2502\n\u251c\u2500\u2500 my_project/\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 settings.py\n\u2502   \u251c\u2500\u2500 urls.py\n\u2502   \u2514\u2500\u2500 wsgi.py\n\u2502\n\u251c\u2500\u2500 manage.py\n\u2514\u2500\u2500 requirements.txt\n</code></pre>"},{"location":"APIs/testing/framework/intro/#breakdown-of-testing-files","title":"Breakdown of Testing Files","text":"<ul> <li> <p><code>tests/__init__.py</code>: Makes the tests directory a Python package. This file can be empty.</p> </li> <li> <p><code>test_models.py</code>: Contains tests for your Django models, ensuring that the model methods and properties work as expected.</p> </li> <li> <p><code>test_views.py</code>: Contains tests for your Django views, including both class-based and function-based views. It often uses Django\u2019s test client to simulate requests.</p> </li> <li> <p><code>test_forms.py</code>: Contains tests for Django forms. Useful for checking form validation and rendering.</p> </li> <li> <p><code>test_utils.py</code>: Contains tests for utility functions or classes used throughout your app.</p> </li> <li> <p><code>test_serializers.py</code>: For DRF projects, this file contains tests for serializers to ensure they correctly serialize and deserialize data.</p> </li> <li> <p><code>test_apis.py</code>: Contains tests for DRF API endpoints, testing various HTTP methods (GET, POST, PUT, DELETE) and ensuring correct responses and status codes.</p> </li> <li> <p><code>test_permissions.py</code>: Contains tests for custom permissions or authentication mechanisms used in DRF.</p> </li> </ul> Tips for Organizing Tests <ul> <li>Group by Feature or Component: Group tests based on what they are testing (e.g., models, views, serializers) to keep related tests together.</li> <li>Keep Test Files Manageable: As your project grows, split large test files into smaller ones to maintain readability and manageability.</li> <li>Use Descriptive Names: Name your test files and functions descriptively to make it clear what functionality they are testing.</li> <li>Follow DRY Principle: Use fixtures, test factories, or utilities to avoid repetitive code in your test cases.</li> </ul> <p>This structure will help you keep your tests organized and ensure you can easily navigate and manage your test cases as your project grows.</p>"},{"location":"APIs/testing/framework/intro/#example","title":"Example","text":"ModelsViewsFormsSerializers (Drf)APIs (DRF)Middleware <ul> <li>Objective: Ensure that your model methods, properties, and validations work as expected.</li> <li>Test Cases to Consider:<ul> <li>Model field validations.</li> <li>Custom model methods.</li> <li>Model save and delete operations.</li> </ul> </li> </ul> <pre><code># my_app/tests/test_models.py\nfrom django.test import TestCase\nfrom .models import MyModel\n\nclass MyModelTestCase(TestCase):\n    def setUp(self):\n        self.model_instance = MyModel.objects.create(name='test')\n\n    def test_model_str(self):\n        self.assertEqual(str(self.model_instance), 'test')\n\n    def test_model_method(self):\n        result = self.model_instance.some_method()\n        self.assertEqual(result, expected_value)\n</code></pre> <ul> <li> <p>Objective: Verify that views return the correct HTTP responses and handle requests as expected.</p> </li> <li> <p>Test Cases to Consider:</p> <ul> <li>HTTP status codes (200 OK, 404 Not Found, 403 Forbidden, etc.).</li> <li>Response content and structure.</li> <li>Permissions and authentication.</li> </ul> </li> </ul> <pre><code># my_app/tests/test_views.py\nfrom django.test import TestCase, Client\nfrom django.urls import reverse\n\nclass MyViewTestCase(TestCase):\n    def setUp(self):\n        self.client = Client()\n        self.url = reverse('my_view_name')\n\n    def test_get_request(self):\n        response = self.client.get(self.url)\n        self.assertEqual(response.status_code, 200)\n        self.assertContains(response, 'Expected content')\n\n    def test_post_request(self):\n        response = self.client.post(self.url, {'key': 'value'})\n        self.assertEqual(response.status_code, 201)\n</code></pre> <ul> <li>Objective: Ensure that forms validate input correctly and handle form submissions properly.</li> <li>Test Cases to Consider:<ul> <li>Form validation (both valid and invalid data).</li> <li>Form field requirements and constraints.</li> </ul> </li> </ul> <pre><code># my_app/tests/test_forms.py\nfrom django.test import TestCase\nfrom .forms import MyForm\n\nclass MyFormTestCase(TestCase):\n    def test_form_validity(self):\n        form = MyForm(data={'field': 'value'})\n        self.assertTrue(form.is_valid())\n\n    def test_form_invalidity(self):\n        form = MyForm(data={'field': ''})\n        self.assertFalse(form.is_valid())\n</code></pre> <ul> <li>Objective: Ensure that serializers correctly handle data serialization and deserialization.</li> <li>Test Cases to Consider:<ul> <li>Serialization and deserialization of valid and invalid data.</li> <li>Field validations and transformations.</li> </ul> </li> </ul> <pre><code># my_app/tests/test_serializers.py\nfrom rest_framework.test import APITestCase\nfrom .serializers import MyModelSerializer\nfrom .models import MyModel\n\nclass MyModelSerializerTestCase(APITestCase):\n    def setUp(self):\n        self.model_instance = MyModel.objects.create(name='test')\n        self.serializer = MyModelSerializer(instance=self.model_instance)\n\n    def test_serializer_valid(self):\n        data = {'name': 'test'}\n        serializer = MyModelSerializer(data=data)\n        self.assertTrue(serializer.is_valid())\n\n    def test_serializer_invalid(self):\n        data = {'name': ''}\n        serializer = MyModelSerializer(data=data)\n        self.assertFalse(serializer.is_valid())\n</code></pre> <ul> <li>Testing APIs (DRF)</li> <li> <p>Objective: Verify that API endpoints return correct responses and handle requests properly.</p> </li> <li> <p>Test Cases to Consider:</p> <ul> <li>GET, POST, PUT/PATCH, DELETE requests.</li> <li>Authentication and permissions.</li> <li>Response status codes and data formats.</li> </ul> </li> </ul> <pre><code># my_app/tests/test_apis.py\nfrom rest_framework.test import APITestCase\nfrom rest_framework import status\nfrom .models import MyModel\n\nclass MyModelAPITestCase(APITestCase):\n    def setUp(self):\n        self.url = '/api/my-model/'\n        self.model_instance = MyModel.objects.create(name='test')\n\n    def test_get_model_list(self):\n        response = self.client.get(self.url)\n        self.assertEqual(response.status_code, status.HTTP_200_OK)\n        self.assertIn('test', response.data[0]['name'])\n\n    def test_create_model(self):\n        data = {'name': 'new_model'}\n        response = self.client.post(self.url, data, format='json')\n        self.assertEqual(response.status_code, status.HTTP_201_CREATED)\n        self.assertEqual(response.data['name'], 'new_model')\n</code></pre> <ul> <li>Testing Middleware and Utilities</li> <li> <p>Objective: Ensure that middleware and utility functions perform their intended roles.</p> </li> <li> <p>Test Cases to Consider:</p> <ul> <li>Middleware behavior (e.g., modifying requests/responses).</li> <li>Utility function outputs and edge cases.</li> </ul> </li> </ul> <pre><code># my_app/tests/test_utils.py\nfrom django.test import TestCase\nfrom .utils import my_utility_function\n\nclass MyUtilityFunctionTestCase(TestCase):\n    def test_function_output(self):\n        result = my_utility_function('input')\n        self.assertEqual(result, 'expected_output')\n</code></pre> Best Practices <ul> <li>Coverage: Aim to cover critical functionalities, edge cases, and potential failure points. Not every single line needs testing, but ensure key paths are well-tested.</li> <li>Modularity: Write modular tests that focus on one aspect of functionality per test case.</li> <li>Automation: Integrate tests into your CI/CD pipeline to ensure they run automatically with each code change.</li> </ul> <p>By following these guidelines, you ensure that your Django and DRF applications are thoroughly tested and reliable.</p>"},{"location":"APIs/testing/framework/intro/#unittest-module","title":"unittest module","text":"<p>The <code>unittest</code> module in Python is a built-in module that provides a framework for writing and running tests. It is a part of Python's standard library and is used to create and execute unit tests, which are tests focused on individual units of code (like functions or methods) to ensure they work as expected.</p>"},{"location":"APIs/testing/framework/intro/#django-and-unittest","title":"Django and unittest","text":"<p>Django\u2019s testing framework is built on top of Python\u2019s <code>unittest</code> module. This means that while Django provides additional features and conveniences for testing Django-specific components (like models, views, and forms), it still leverages the core functionality of <code>unittest</code>.</p> <p>Here\u2019s a quick overview of how unittest integrates with Django and how it\u2019s used within Django projects:</p>"},{"location":"APIs/testing/framework/intro/#key-features-of-unittest","title":"Key Features of unittest","text":"<ol> <li> <p>Test Case Classes:</p> <ul> <li>You create test cases by subclassing <code>unittest.TestCase</code>. Each method within the test case class represents a single test.</li> <li>Django\u2019s <code>django.test.TestCase</code> extends <code>unittest.TestCase</code> and adds additional functionality specific to Django.</li> </ul> <pre><code>import unittest\n\nclass MyTestCase(unittest.TestCase):\n    def test_addition(self):\n        self.assertEqual(1 + 1, 2)\n</code></pre> </li> <li> <p>Assertions:</p> <ul> <li>The <code>unittest</code> module provides various assertion methods to test conditions in your code, such as <code>assertEqual()</code>, <code>assertTrue()</code>, <code>assertFalse()</code>, and <code>assertRaises()</code>.</li> <li>Django\u2019s TestCase inherits these assertions and also provides Django-specific assertions.</li> </ul> <pre><code>self.assertEqual(a, b)\nself.assertTrue(condition)\n</code></pre> </li> <li> <p>Test Fixtures:</p> <ul> <li><code>unittest</code> allows you to set up and tear down resources before and after tests using <code>setUp()</code> and <code>tearDown()</code> methods.</li> <li>In Django, <code>django.test.TestCase</code> extends this with additional features, like setting up and tearing down a test database.</li> </ul> <pre><code>class MyTestCase(unittest.TestCase):\n    def setUp(self):\n        self.resource = setup_resource()\n\n    def tearDown(self):\n        teardown_resource(self.resource)\n</code></pre> </li> <li> <p>Test Suites:</p> <ul> <li>You can group multiple test cases into a test suite and run them together.</li> <li>Django\u2019s test runner can discover and execute all tests in a project automatically.</li> </ul> <pre><code>import unittest\n\ndef suite():\n    suite = unittest.TestSuite()\n    suite.addTest(MyTestCase('test_addition'))\n    return suite\n</code></pre> </li> <li> <p>Running Tests:</p> <p>You can run tests from the command line using <code>python -m unittest</code> or, in Django, using <code>python manage.py test</code>.</p> <pre><code>python -m unittest discover\npython manage.py test\n</code></pre> </li> </ol>"},{"location":"APIs/testing/framework/intro/#djangos-testcase-and-unittest-integration","title":"Django\u2019s TestCase and unittest Integration","text":"<p>Django\u2019s TestCase is a subclass of <code>unittest.TestCase</code> with added functionality specific to Django applications:</p> <ol> <li> <p>Database Integration:</p> <ul> <li>Django\u2019s <code>TestCase</code> uses a separate test database, ensuring that tests don\u2019t affect your development or production databases.</li> <li>It automatically creates and destroys the test database for each test.</li> </ul> <pre><code>from django.test import TestCase\n\nclass MyModelTestCase(TestCase):\n    def setUp(self):\n        # Setup code\n        pass\n\n    def test_model_method(self):\n        # Test code\n        pass\n</code></pre> </li> <li> <p>Test Client:</p> <ul> <li>Provides a way to simulate HTTP requests and interact with your Django application</li> </ul> <pre><code>from django.test import TestCase, Client\n\nclass MyViewTestCase(TestCase):\n    def setUp(self):\n        self.client = Client()\n\n    def test_get_view(self):\n        response = self.client.get('/my-url/')\n        self.assertEqual(response.status_code, 200)\n</code></pre> </li> <li> <p>Additional Assertions:</p> <ul> <li>Django\u2019s <code>TestCase</code> includes additional assertions useful for web applications, like <code>assertContains()</code>, <code>assertRedirects()</code>, and <code>assertTemplateUsed()</code>.</li> </ul> <pre><code>from django.test import TestCase\n\nclass MyViewTestCase(TestCase):\n    def test_view_contains_text(self):\n        response = self.client.get('/my-url/')\n        self.assertContains(response, 'Expected text')\n</code></pre> </li> </ol>"},{"location":"APIs/testing/framework/intro/#summary_1","title":"Summary","text":"<ul> <li><code>unittest</code> Module: Python\u2019s built-in framework for creating and running tests. It provides a standard way to write tests and includes various assertion methods.</li> <li>Django\u2019s <code>TestCase</code>: Extends <code>unittest.TestCase</code> with Django-specific features, including test database management, test clients, and additional assertions tailored for web applications.</li> </ul> <p>By leveraging <code>unittest</code> and Django\u2019s testing enhancements, you can write effective and comprehensive tests for your Django applications.</p>"},{"location":"APIs/testing/framework/intro/#which-to-choose","title":"Which to choose","text":"<ul> <li><code>pytest</code>: Use it for more flexibility, better syntax, and advanced features. It is suitable for any Python project needing sophisticated testing capabilities.</li> <li><code>pytest-django</code>: Use it when working on Django projects and you want to integrate pytest with Django\u2019s testing utilities and fixtures.</li> <li><code>pytest-factoryboy</code>: Use it when you need to create complex test data and want to leverage <code>factory_boy</code> with <code>pytest</code>.</li> </ul>"},{"location":"APIs/testing/framework/topic/","title":"Topic","text":""},{"location":"APIs/testing/framework/topic/#common-tools-for-automated-testing","title":"Common Tools for Automated Testing:","text":"<ul> <li>Unit Testing: <code>unittest</code>, <code>pytest</code> for Python.</li> <li>Integration and Functional Testing: <code>pytest</code>, Django\u2019s test framework, Selenium for web applications.</li> <li>End-to-End Testing: <code>Selenium</code>, <code>Cypress</code>.</li> <li>Performance Testing: <code>JMeter</code>, <code>Locust</code>.</li> </ul>"},{"location":"APIs/testing/pytest/intro/","title":"Intro","text":"<p>pytest is a popular testing framework for Python that provides a robust and flexible approach to testing. It is known for its simplicity, powerful features, and ease of use. </p> <p>pytest-django is a plugin for <code>pytest</code> that integrates Django with the pytest testing framework. It extends pytest to handle Django-specific testing tasks. </p>"},{"location":"APIs/testing/pytest/intro/#question","title":"Question","text":"<p>Can we use pytest instead of django unittest framework</p> <p>Yes, you can definitely use <code>pytest</code> with Django instead of Django's default unit test framework. In fact, many developers prefer <code>pytest</code> due to its powerful features and flexibility. Here\u2019s a step-by-step guide to help you get started:</p> <ol> <li> <p>Install <code>pytest</code> and <code>pytest-django</code>:</p> <p>First, you need to install <code>pytest</code> and the <code>pytest-django</code> plugin, which provides Django-specific functionalities.</p> <pre><code>pip install pytest pytest-django\n</code></pre> </li> <li> <p>Configure <code>pytest-django</code>:</p> <p>Create a file named <code>pytest.ini</code> in your project root (the same directory as <code>manage.py</code>). This file will configure pytest to work with Django.</p> <pre><code>[pytest]\nDJANGO_SETTINGS_MODULE = myproject.settings\n</code></pre> <p>Replace <code>myproject.settings</code> with the path to your Django settings module.</p> </li> <li> <p>Create a <code>conftest.py</code> file (optional):</p> <p>You can use this file to define fixtures and hooks that <code>pytest</code> can use. For example, you might configure database settings or set up common test data.</p> <pre><code># conftest.py\nimport pytest\nfrom django.urls import reverse\n\n@pytest.fixture\ndef sample_url():\n    return reverse('sample_view')\n</code></pre> </li> <li> <p>Write your tests:</p> <p>You can start writing tests using pytest syntax. Here\u2019s an example of a simple Django test using pytest:</p> <pre><code># test_models.py\nimport pytest\nfrom django.urls import reverse\nfrom django.test import Client\n\n@pytest.mark.django_db\ndef test_sample_view(sample_url):\n    client = Client()\n    response = client.get(sample_url)\n    assert response.status_code == 200\n</code></pre> <p>The <code>@pytest.mark.django_db decorator</code> is used to mark tests that require database access.</p> </li> <li> <p>Run your tests:</p> <p>You can run your tests using the pytest command in your terminal:</p> <pre><code>pytest\n</code></pre> </li> <li> <p>Use additional <code>pytest</code> features:</p> <p>You can take advantage of <code>pytest</code>\u2019s features such as fixtures, parametrization, and more to write effective tests. For more details, refer to the pytest documentation and pytest-django documentation.</p> </li> </ol> <p>By following these steps, you can effectively use pytest with Django and take advantage of pytest's advanced testing capabilities.</p>"},{"location":"APIs/testing/pytest/intro/#folder-structure","title":"Folder Structure","text":"<p>When using <code>pytest</code> with Django, your project structure can be flexible, but a common and recommended approach is to organize your tests in a way that aligns with Django's app structure. Below is an example of a typical folder structure for a Django project using <code>pytest</code>, with an emphasis on where you might place your test files:</p> Folder StructureExplanationNotes <pre><code>myproject/\n\u251c\u2500\u2500 myproject/\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 settings.py\n\u2502   \u251c\u2500\u2500 urls.py\n\u2502   \u2514\u2500\u2500 wsgi.py\n\u251c\u2500\u2500 myapp/\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 admin.py\n\u2502   \u251c\u2500\u2500 apps.py\n\u2502   \u251c\u2500\u2500 models.py\n\u2502   \u251c\u2500\u2500 tests/\n\u2502   \u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2502   \u251c\u2500\u2500 test_models.py\n\u2502   \u2502   \u251c\u2500\u2500 test_views.py\n\u2502   \u2502   \u251c\u2500\u2500 test_forms.py\n\u2502   \u2502   \u2514\u2500\u2500 conftest.py\n\u2502   \u251c\u2500\u2500 views.py\n\u2502   \u251c\u2500\u2500 urls.py\n\u2502   \u2514\u2500\u2500 migrations/\n\u2502       \u2514\u2500\u2500 __init__.py\n\u251c\u2500\u2500 manage.py\n\u2514\u2500\u2500 pytest.ini\n</code></pre> <ul> <li> <p>myproject/: The root directory of your Django project.</p> <ul> <li><code>myproject/</code>: This directory contains Django settings and configuration files.</li> <li><code>manage.py</code>: The command-line utility for managing your Django project.</li> <li><code>pytest.ini</code>: Configuration file for pytest.</li> <li><code>myapp/</code>: A Django application within your project.</li> </ul> </li> <li> <p>tests/: Directory for test files.</p> <ul> <li><code>__init__.py</code>: This file makes the tests directory a package.</li> <li><code>test_models.py</code>: Contains tests for your Django models.</li> <li><code>test_views.py</code>: Contains tests for your views.</li> <li><code>test_forms.py</code>: Contains tests for your forms (if any).</li> <li><code>conftest.py</code>: Optional file for defining pytest fixtures and hooks specific to this app.</li> </ul> </li> </ul> <ol> <li> <p>Organizing Tests:</p> <ul> <li>Models: Put tests related to Django models in <code>test_models.py</code>.</li> <li>Views: Place tests related to Django views in <code>test_views.py</code>.</li> <li>Forms: Put form-related tests in <code>test_forms.py</code>.</li> <li>You can add more test files as needed, organizing them by functionality.</li> </ul> </li> <li> <p>Fixtures:</p> <ul> <li>Define reusable fixtures in <code>conftest.py</code> for the specific app. This file can be used to set up any test data or configurations needed for your tests.</li> </ul> </li> <li> <p><code>pytest.ini</code> Configuration:</p> <ul> <li>The <code>pytest.ini</code> file at the root specifies the Django settings module and other configurations for <code>pytest</code>.</li> </ul> </li> </ol> <p>This structure helps keep tests organized and manageable, making it easier to maintain and scale as your project grows.</p>"},{"location":"APIs/testing/pytest/intro/#advanced-folder-structure","title":"Advanced Folder Structure","text":"<p>If you have organized your Django apps inside a <code>custom_apps</code> directory, you'll need to ensure that Django can find these apps correctly and that <code>pytest</code> can run the tests.</p> <p>Here\u2019s a step-by-step guide to create a simple <code>pytest</code> setup to test if everything is configured correctly:</p> <ol> <li> <p>Directory Structure</p> <p>Assuming your <code>custom_apps</code> directory is at the same level as <code>manage.py</code>, your project structure might look something like this:</p> <pre><code>myproject/\n\u251c\u2500\u2500 myproject/\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 settings.py\n\u2502   \u251c\u2500\u2500 urls.py\n\u2502   \u2514\u2500\u2500 wsgi.py\n\u251c\u2500\u2500 custom_apps/\n\u2502   \u251c\u2500\u2500 app1/\n\u2502   \u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2502   \u251c\u2500\u2500 models.py\n\u2502   \u2502   \u251c\u2500\u2500 views.py\n\u2502   \u2502   \u251c\u2500\u2500 tests/\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 test_sample.py\n\u2502   \u2502   \u2514\u2500\u2500 apps.py\n\u2502   \u2514\u2500\u2500 app2/\n\u2502       \u251c\u2500\u2500 __init__.py\n\u2502       \u251c\u2500\u2500 models.py\n\u2502       \u251c\u2500\u2500 views.py\n\u2502       \u251c\u2500\u2500 tests/\n\u2502       \u2502   \u251c\u2500\u2500 __init__.py\n\u2502       \u2502   \u2514\u2500\u2500 test_sample.py\n\u2502       \u2514\u2500\u2500 apps.py\n\u251c\u2500\u2500 manage.py\n\u2514\u2500\u2500 pytest.ini\n</code></pre> </li> <li> <p>Update <code>settings.py</code></p> <p>Ensure that your Django settings file (<code>settings.py</code>) is aware of the apps in <code>custom_apps</code>. You need to update the <code>INSTALLED_APPS</code> list to include the apps with their full path.</p> <pre><code># myproject/settings.py\nINSTALLED_APPS = [\n    ...\n    'custom_apps.app1',\n    'custom_apps.app2',\n]\n</code></pre> </li> <li> <p>Create a Simple Test</p> <p>Let\u2019s create a simple test case in one of your apps. We\u2019ll use <code>app1</code> for this example. In the <code>tests</code> directory of <code>app1</code>, create a file named <code>test_sample.py</code>.</p> <pre><code># custom_apps/app1/tests/test_sample.py\n\nimport pytest\n\ndef test_sample():\n    assert 1 + 1 == 2\n</code></pre> </li> <li> <p>Create <code>pytest.ini</code> Configuration</p> <p>Create or update the <code>pytest.ini</code> file in the root directory of your project to include the Django settings module.</p> <pre><code># pytest.ini\n\n[pytest]\nDJANGO_SETTINGS_MODULE = myproject.settings\npython_files = tests.py test_*.py *_test.py\n</code></pre> </li> <li> <p>Run the Tests</p> <p>Navigate to the root directory of your project (where <code>manage.py</code> and <code>pytest.ini</code> are located) and run <code>pytest</code>:</p> <pre><code>pytest\n</code></pre> </li> </ol> Summary <p>This setup ensures that pytest will discover and run the tests located in your custom_apps directory. If everything is configured correctly, you should see the output from pytest, indicating whether the tests passed or failed.</p> <p>If you encounter any issues:</p> <ul> <li>Ensure <code>pytest-django</code> is installed (<code>pip install pytest-django</code>).</li> <li>Make sure the Django settings module is correctly specified in <code>pytest.ini</code>.</li> <li>Verify that the apps are correctly listed in <code>INSTALLED_APPS</code>.</li> </ul> <p>This simple setup should help you confirm that <code>pytest</code> is running correctly with your Django project.</p>"},{"location":"APIs/testing/pytest/intro/#why-pytest","title":"Why pytest","text":"<p>While Django\u2019s default testing framework is perfectly adequate for many use cases, <code>pytest</code> with <code>pytest-django</code> has become the preferred choice for many developers due to its advanced features, ease of use, and extensibility. It offers a more modern and flexible approach to testing, making it a popular choice in the Django community.</p>"},{"location":"APIs/testing/pytest/intro/#reference","title":"Reference","text":"<ul> <li>pytest</li> <li>pytest-django.readthedocs.io</li> </ul>"},{"location":"APIs/throttling/intro/","title":"Intro","text":""},{"location":"APIs/throttling/intro/#standard-practice","title":"Standard Practice","text":"<ul> <li> <p>Login Endpoint: Apply a stricter throttle, such as allowing only a limited number of attempts per minute or hour (e.g., 5 attempts per minute).</p> </li> <li> <p>Signup Endpoint: You can also apply throttling here, but you might choose a more lenient rate depending on your user base and anticipated traffic (e.g., 10 signups per minute).</p> </li> </ul> Example Configuration <p>In your <code>settings.py</code>, you might set it up like this:</p> <pre><code>REST_FRAMEWORK = {\n    'DEFAULT_THROTTLE_CLASSES': [\n        'rest_framework.throttling.AnonRateThrottle',  # For anonymous users\n        'rest_framework.throttling.UserRateThrottle',  # For authenticated users\n    ],\n    'DEFAULT_THROTTLE_RATES': {\n        'anon': '5/minute',  # For login attempts\n        'user': '1000/day',  # For general authenticated user actions\n    },\n}\n</code></pre> <p>Implementing throttling on public endpoints like <code>login</code> and <code>signup</code> is essential for securing your application against common attacks while maintaining a good user experience.</p>"},{"location":"APIs/throttling/intro/#built-in-throlling-vs-django-ratelimit-package","title":"Built-in throlling <code>vs</code> django-ratelimit package","text":"<p>Both django-ratelimit and Django's built-in <code>throttling</code> (using Django Rest Framework's throttling) are used to control the rate at which requests are processed. However, they have different approaches and use cases. Here\u2019s a breakdown of the core differences:</p> django-ratelimitDjango Rest Framework Throttling <ul> <li>Functionality: It allows you to apply rate limiting on specific views by decorating them. You can specify limits based on various criteria (e.g., IP address, user, etc.).</li> <li>Granularity: Offers more fine-grained control over rate limits for individual views.</li> <li>Configuration: Requires decorators to be applied to each view you want to limit.</li> <li>Flexibility: You can set different limits for different views easily.</li> </ul> <ul> <li>Built-in Support: Throttling is integrated into DRF and can be configured globally or on a per-view basis using class-based views.</li> <li>Rate Limiters: It provides several built-in classes like AnonRateThrottle and UserRateThrottle, which can be customized for different user types.</li> <li>Settings-Based: Throttling limits can be defined in the settings, making it easy to manage across your application.</li> <li>Middleware-like Behavior: Throttling operates at a middleware level, meaning it's applied automatically based on the defined rules.</li> </ul>"},{"location":"APIs/throttling/intro/#which-one-to-use","title":"Which One to Use?","text":"<p>Use<code>django-ratelimit</code> if you need:</p> <ul> <li>More control over specific views or need to set different limits easily.</li> <li>Custom logic or more complex rate limiting scenarios.</li> </ul> <p>Use <code>DRF Throttling</code> if you prefer:</p> <ul> <li>A straightforward and integrated approach to limit requests across the entire API.</li> <li>A consistent and centralized configuration in your Django settings.</li> </ul> <p>Conclusion</p> <p>If you're building a DRF-based API, starting with DRF's <code>built-in</code> throttling might be the easier and more cohesive choice. For more complex or specific rate limiting needs, django-ratelimit offers additional flexibility.</p>"},{"location":"APIs/throttling/intro/#configuration","title":"Configuration","text":"Update SettingsApply Throttling to ViewsCustom Throttling (Optional) <p>In your <code>settings.py</code>, configure the throttling classes. You can set global throttling rules here:</p> <pre><code>REST_FRAMEWORK = {\n    'DEFAULT_THROTTLE_CLASSES': [\n        'rest_framework.throttling.AnonRateThrottle',  # For anonymous users\n        'rest_framework.throttling.UserRateThrottle',  # For authenticated users\n    ],\n    'DEFAULT_THROTTLE_RATES': {\n        'anon': '100/day',  # 100 requests per day for anonymous users\n        'user': '1000/day',  # 1000 requests per day for authenticated users\n    },\n}\n</code></pre> <p>You can apply throttling to specific views or viewsets using the <code>throttle_classes</code> attribute. Here's an example:</p> <pre><code>from rest_framework import viewsets\nfrom rest_framework.permissions import IsAuthenticated\nfrom rest_framework.throttling import UserRateThrottle, AnonRateThrottle\nfrom .models import YourModel\nfrom .serializers import YourModelSerializer\n\nclass YourModelViewSet(viewsets.ModelViewSet):\n    queryset = YourModel.objects.all()\n    serializer_class = YourModelSerializer\n    permission_classes = [IsAuthenticated]\n    throttle_classes = [UserRateThrottle]  # Apply user throttling to this view\n\n# For a different view with different throttling\nclass AnotherViewSet(viewsets.ModelViewSet):\n    queryset = YourModel.objects.all()\n    serializer_class = YourModelSerializer\n    throttle_classes = [AnonRateThrottle]  # Apply anonymous throttling to this view\n</code></pre> <p>If you need custom throttling logic, you can create a custom throttle class. Here's an example:</p> <pre><code>from rest_framework.throttling import SimpleRateThrottle\n\nclass CustomRateThrottle(SimpleRateThrottle):\n    scope = 'custom_user'\n\n    def get_cache_key(self, request, view):\n        return request.user.username if request.user.is_authenticated else None\n\n# Then, add your custom throttle class to settings.py\nREST_FRAMEWORK = {\n    'DEFAULT_THROTTLE_CLASSES': [\n        'path.to.CustomRateThrottle',\n    ],\n    'DEFAULT_THROTTLE_RATES': {\n        'custom_user': '10/minute',  # Example: 10 requests per minute\n    },\n}\n</code></pre>"},{"location":"backend/draft/","title":"draft","text":"<p>Django Folder Structure</p> <p>Django Naming Convention</p> <p>Boilerplate &amp; Scaffold</p> <p>Python</p> <p>Python</p> bash<pre><code># To run a Django server on a different port\n$ python manage.py runserver &lt;port_number&gt;\n$ python manage.py runserver 8001\n\n# To bind to a specific IP address\n$ python manage.py runserver &lt;ip_address&gt;:&lt;port_number&gt;\n$ python manage.py runserver 0.0.0.0:8001\n\n# This will make your Django server accessible on all network interfaces on port 8001.\n</code></pre> <p>django best practices</p> <p>django best practices: project vs apps</p> 2002, Can't connect to local MySQL server through socket <p>Q. django.db.utils.OperationalError: (2002, \"Can't connect to local MySQL server through socket '/var/run/mysqld/mysqld.sock' (2)\")</p> <p>=&gt; Use \"127.0.0.1\", instead of \"localhost\"</p> <pre><code>DATABASES = {\n      'default': {\n            'ENGINE': 'django.db.backends.mysql',\n            'NAME': 'django',\n            'USER': 'root',\n            'PASSWORD': '',\n            'HOST': '127.0.0.1',\n            'PORT': '3306',\n      }\n}\n</code></pre> Django MVT Architecture <p>In the context of the Django web framework, a \"view\" is not just a \"view\" in the traditional Model-View-Controller (MVC) sense. Instead, it is more aligned with the \"controller\" part of MVC. Django follows a slightly different design pattern known as Model-View-Template (MVT), where the view acts more like a controller.</p> <p>Here's a breakdown of the responsibilities in Django's MVT pattern:</p> <ul> <li> <p>Model:</p> <p>The model represents the data structure of your application. It typically consists of Python classes that define the fields and behavior of your data, including interactions with the database.</p> </li> <li> <p>View:</p> <p>In Django, a view is a Python function or class that receives HTTP requests and returns HTTP responses. It's responsible for processing requests, fetching data from the database (via QuerySets), and passing that data to templates for rendering.</p> </li> <li> <p>Template:</p> <p>Templates are HTML files containing placeholders and template tags. They are responsible for rendering the data received from the view into a user-readable format. Templates can include dynamic content using template tags and filters.</p> </li> </ul> <p>In <code>Django's MVT pattern</code>, the view acts as a controller that handles the business logic, database interactions, and data manipulation. It receives input from the user (HTTP requests), processes that input, interacts with the database through models and QuerySets, and passes the processed data to templates for rendering.</p> <p>So, while the view in Django is similar to the controller in traditional MVC architectures, it also incorporates some aspects of the \"view\" in terms of rendering data to the user. However, the primary responsibility of the view in Django is to handle request processing and data manipulation, making it more akin to the controller in MVC.</p> Registering Models with the Admin <p>We have to register out app's <code>model</code> such as MyEvent, MyUser with the <code>admin</code>.</p> <pre><code>from django.contrib import admin\nfrom .models import MyEvent, MyUser\n\nadmin.site.register(MyEvent)\nadmin.site.register(MyUser)\n</code></pre> <p>Q. Why do we need to register a model in Djano?</p> <p>When you register a model with the admin, you can use the admin to <code>add</code>, <code>edit</code> and <code>delete</code> model records.</p> Advanced models <p>Django QuertSet API provides a comprehensive array of methods and function for working with data.</p> <p>A Django <code>QuerySet</code> is a collection of database queries used to fetch data from the database and perform various operations on it. It represents a collection of objects retrieved from your database, typically filtered, ordered, and limited. QuerySets allow you to interact with your database in a Pythonic way, providing a powerful and expressive API for retrieving, manipulating, and querying data.</p> <p>## Basic Example</p> <pre><code>from myapp.models import Book\n\n# Retrieve all books\nall_books = Book.objects.all()\n\n# Filter books by a certain condition\nrecent_books = Book.objects.filter(published_date__year=2022)\n\n# Order books by a certain field\nsorted_books = Book.objects.order_by('title')\n\n# Retrieve a single book\nbook = Book.objects.get(title='Example Book')\n\n# Count the number of books\nnum_books = Book.objects.count()\n</code></pre> <p>Advanced Example:</p> <p>Suppose you have two models, <code>Author</code> and <code>Book</code>, where <code>Book</code> has a foreign key relationship with <code>Author</code>. Here's how you can use QuerySets for more complex operations:</p> <pre><code>from myapp.models import Author, Book\n\n# Retrieve all books by a specific author\nauthor = Author.objects.get(name='John Doe')\nbooks_by_author = Book.objects.filter(author=author)\n\n# Perform a join operation to get books published in a specific year by authors with a certain nationality\nbooks_published_in_2022 = Book.objects.filter(published_date__year=2022, author__nationality='American')\n\n# Retrieve the number of books written by each author\nfrom django.db.models import Count\nbooks_per_author = Author.objects.annotate(num_books=Count('book'))\n\n# Perform a complex query combining multiple conditions\ncomplex_query = Book.objects.filter(published_date__year=2022).exclude(author__nationality='British').order_by('-published_date')[:5]\n</code></pre> uWSGI (<code>Web Server Gateway Interface</code>) <p>Installation</p> <pre><code># installtion\npip install uwsgi\n\n# checking the version\nuwsg --version\n\n# running a web server\nuwsgi --http :8080 -w &lt;file&gt;:application\n</code></pre> project-level urls <code>vs</code> app-level urls <p>In Django, URL patterns can be defined at both the project level and the app level. Here's a brief explanation of each:</p> <ol> <li> <p>Project-level URLs:</p> <p>These are defined in the urls.py file at the project's root level. This file typically resides in the same directory as your settings.py file. Project-level URLs define the main URLs for your entire Django project. They are often used to include URLs from various apps within the project.</p> </li> <li> <p>App-level URLs:</p> <p>These are defined in the urls.py file within individual Django apps. Each app can have its own set of URLs, which are specific to the functionality provided by that app. App-level URLs are useful for organizing and encapsulating related views and functionality within the app.</p> </li> </ol> <p>Whether you should use both project-level and app-level URLs depends on the structure and complexity of your Django project:</p> <p>Small projects: For small projects with a limited number of apps and URLs, you might choose to define all URLs in the project-level urls.py file. This keeps the URL configuration simple and centralized.</p> <p>Medium to large projects: In larger projects with multiple apps and complex URL configurations, it's often beneficial to use both project-level and app-level URLs. Project-level URLs can serve as an entry point, including URLs from various apps, while each app can define its own URLs for its specific functionality.</p> <p>Here's an example of how you might structure your URLs in a Django project:</p> <pre><code>  project_name/\n  |-- manage.py\n  |-- project_name/\n  |   |-- __init__.py\n  |   |-- settings.py\n  |   |-- urls.py           # Project-level URLs\n  |   |-- wsgi.py\n  |-- app1/\n  |   |-- __init__.py\n  |   |-- models.py\n  |   |-- urls.py           # App-level URLs for app1\n  |   |-- views.py\n  |-- app2/\n  |   |-- __init__.py\n  |   |-- models.py\n  |   |-- urls.py           # App-level URLs for app2\n  |   |-- views.py\n</code></pre> <p>In this structure, the project-level urls.py file might include URLs from <code>app1.urls</code> and <code>app2.urls</code>, while each app (app1 and app2) has its own urls.py file defining URLs specific to that app's functionality. This approach allows for better organization and separation of concerns in larger projects.</p> <p>Programming</p> JS Functional Programming <p>The idea is not to throw away everything you\u2019ve learned and use and adopt a 100% functional way; rather, the guiding idea is evolution, not revolution.</p> <p>It\u2019s easy to apply a given function from some package or the other, but by coding everything out (<code>vanilla FP</code>, if you wish), it\u2019s my belief that you get to understand things more deeply.</p> OO design patterns Functional design patterns <ul> <li>Mastering JavaScript Functional Programming by Federico Kereki, 3rd Edition</li> </ul> What Is DevOps? <p>The term <code>DevOps</code> is derived from the combination of <code>two words</code>: developer and operations.</p> <p><code>DevOps</code> is used to define a movement born of the need for reducing barriers between the development and operations teams of a company. The goal of DevOps is to reduce time to market. This means adopting DevOps practices, to reduce the time needed, from the identification of a new requirement to the time it goes live for customers.</p> <p>The <code>DevOps</code> journey introduces such practices as continuous integration and continuous   delivery, which help to reduce time to market and produce better quality software.</p> <p>Common menus on websites often include:</p> <ol> <li>Home: The homepage of the website, typically linked to the logo in the header.</li> <li>About: Information about the company, organization, or website.</li> <li>Products/Services: If applicable, a menu item leading to a page showcasing the products or services offered.</li> <li>Blog/News: A section for articles, updates, or news related to the website's topic or industry.</li> <li>Contact: Contact information or a contact form for users to reach out.</li> <li>Portfolio/Projects: For showcasing past work or projects, often seen on agency or freelancer websites.</li> <li>FAQ: Frequently Asked Questions, if applicable.</li> <li>Testimonials: Customer testimonials or reviews, typically found on business websites.</li> <li>Events/Calendar: For listing upcoming events, conferences, or important dates.</li> <li>Resources: Links to downloadable resources, documents, or helpful tools.</li> <li>Search: A search bar to help users find specific content on the website.</li> <li>Login/Register: If the website requires user authentication, links to login or register for an account.</li> <li>Terms of Service/Privacy Policy: Legal pages outlining terms of use and privacy policies.</li> <li>Sitemap: A structured layout of the website's content, helpful for navigation and SEO.</li> <li>Social Media Links: Icons linking to the website's social media profiles.</li> </ol> <p>The specific menu items will vary depending on the purpose and content of the website. It's important to consider the needs of your audience and the goals of your website when determining which menu items to include. Additionally, the menu structure should be intuitive and easy to navigate for users.</p>"},{"location":"backend/draft/#making-fields-optional","title":"Making Fields Optional","text":"models.py<pre><code>class MyUserModal:\n  name = models.URLField(\"Web Address\", blank=True)\n</code></pre> <p>I have set the <code>blank</code> field to <code>True</code>. The default is <code>False</code>, which makes the field required.</p>"},{"location":"backend/draft/#django-debug-value","title":"Django <code>DEBUG</code> value","text":"<p>It looks like you're setting the DEBUG value to False in your .env file and then trying to retrieve it in your settings.py file using <code>os.environ.get('DEBUG')</code>. The code you've shown seems correct in terms of retrieving the <code>DEBUG</code> value from the environment variables.</p> <p>However, the issue might arise if the DEBUG value is not being retrieved correctly or if it's not being interpreted as a boolean value. Here are a few things you can check:</p> <ol> <li> <p>Ensure <code>.env</code> file is loaded: Make sure your <code>.env</code> file is being loaded properly by your application. Sometimes, this requires additional configuration, especially if you're using a framework like Django or Flask.</p> </li> <li> <p>Check DEBUG value: Verify that the DEBUG value in your <code>.env</code> file is set to either 'True' or 'False', and not any other string. It's case-sensitive, so 'True' and 'False' should be all uppercase.</p> </li> <li> <p>Convert DEBUG value to boolean: Since DEBUG is typically a boolean value in Django (True or False), you might want to explicitly convert it to a boolean in your <code>settings.py</code> file:</p> <pre><code>import os\n\nDEBUG = os.environ.get('DEBUG', '').lower() == 'true'\n</code></pre> <p>This code will set <code>DEBUG</code> to True if the DEBUG environment variable is set to <code>True</code> (case insensitive), and <code>False</code> otherwise.</p> </li> <li> <p>Fallback value: Provide a fallback value in case the DEBUG environment variable is not set in your .env file. For example:</p> <pre><code>    DEBUG = os.environ.get('DEBUG', 'False').lower() == 'true'\n</code></pre> <p>This will default <code>DEBUG</code> to <code>False</code> if the <code>DEBUG</code> environment variable is not set.</p> </li> <li> <p>Check for typos: Ensure there are no typos in your code or in your .env file. Even a small typo can cause issues.</p> </li> <li> <p>Restart your server: After making changes to your <code>.env</code> file or your settings.py file, make sure to restart your server to apply the changes.</p> </li> </ol> <p>If you've checked all of the above and are still facing issues, please provide more details or error messages for further assistance.</p>"},{"location":"backend/draft/#programming-jokes","title":"Programming Jokes","text":""},{"location":"backend/draft/#blogs","title":"Blogs","text":""},{"location":"backend/draft/#1-using-decorator-in-class-based-views-django","title":"1. Using decorator in Class-Based-Views Django","text":"<p>method_decorator is a function provided by Django's <code>django.utils.decorators</code> module. It serves as a bridge between function decorators and class-based views in Django. While decorators are typically used with functions, <code>method_decorator</code> enables their usage with class methods.</p> <p>How does it work?</p> <p>Consider a scenario where you have a class-based view in Django. Each method within the class corresponds to an HTTP request method (e.g., get, post, put). Sometimes, you might want to apply a decorator to one of these methods. This is where <code>method_decorator</code> comes into play.</p> <p>By decorating a method with <code>method_decorator</code>, you can apply any decorator to that method, just as you would with a regular function. This allows for cleaner, more modular code, as decorators can be applied directly to the methods they are intended to modify.</p> <p>When to use <code>method_decorator</code>?</p> <ol> <li> <p>DRY Principle: </p> <p>When you find yourself repeating the same decorator across multiple view methods, <code>method_decorator</code> can help you adhere to the Don't Repeat Yourself (DRY) principle by applying the decorator directly to the methods.</p> </li> <li> <p>Granular Control:</p> <p><code>method_decorator</code> provides granular control over which methods within a class-based view are decorated. This can be particularly useful when you need different decorators for different methods.</p> </li> <li> <p>Keeping Views Clean:</p> <p>Using <code>method_decorator</code> helps keep your views clean and focused on business logic by separating concerns related to request handling (e.g., <code>authentication</code>, <code>caching</code>) into decorators.</p> </li> </ol> Python<pre><code>from django.views.generic import View\nfrom django.http import HttpResponse\nfrom django.utils.decorators import method_decorator\nfrom django.contrib.auth.decorators import login_required\n\nclass MyView(View):\n\n    @method_decorator(login_required)\n    def get(self, request):\n        # Your view logic for handling GET requests\n        return HttpResponse(\"This view requires authentication.\")\n</code></pre> <p>In this example, the <code>login_required</code> decorator is applied directly to the get method of the MyView class using method_decorator. This ensures that the view requires authentication for GET requests.</p> <p>Conclusion:</p> <p><code>method_decorator</code> is a valuable tool in Django for applying decorators to class-based view methods. By leveraging this utility, developers can write cleaner, more modular code while maintaining granular control over the behavior of their views. Whether it's enforcing authentication, caching responses, or handling other cross-cutting concerns, <code>method_decorator</code> empowers developers to enhance the functionality and security of their Django applications with ease.</p>"},{"location":"backend/draft/#2-most-used-decorators-in-django","title":"2. Most used decorators in django","text":"<p>In Django, decorators play a crucial role in modifying the behavior of views, including class-based views (CBVs). Some of the most commonly used decorators in class-based views are:</p> <ol> <li> <p>@method_decorator:</p> <p>This is a utility provided by Django that allows decorators to be applied to class-based view methods. It's not a decorator itself but a tool for applying decorators to methods within a class-based view.</p> </li> <li> <p>@login_required:</p> <p>Ensures that the user must be authenticated to access the view. If the user is not authenticated, they are redirected to the login page.</p> </li> <li> <p>@permission_required:</p> <p>Requires that the user has specific permissions to access the view. If the user lacks the required permissions, they are redirected to a specified page.</p> </li> <li> <p>@csrf_exempt:</p> <p>Exempts the view from CSRF (Cross-Site Request Forgery) protection. This is useful for views that handle external POST requests or APIs.</p> </li> <li> <p>@cache_page:</p> <p>Caches the output of the view for a specified amount of time, improving performance by serving cached responses for subsequent requests.</p> </li> <li> <p>@transaction.atomic:</p> <p>Ensures that the database operations within the view are executed within a single transaction. Changes are rolled back if an exception occurs.</p> </li> <li> <p>@require_http_methods:</p> <p>Restricts the HTTP methods allowed for accessing the view. It ensures that only specific HTTP methods (e.g., GET, POST) are supported.</p> </li> <li> <p>@cache_control:</p> <p>Sets HTTP caching headers for the view response, controlling caching behavior in the client's browser or intermediary caches.</p> </li> <li> <p>@gzip_page:</p> <p>Compresses the response content using gzip compression, reducing bandwidth usage and improving page load times.</p> </li> <li> <p>@vary_on_headers:</p> <p>Specifies which request headers should be considered when caching responses, allowing for more granular cache control based on specific headers.</p> </li> </ol> <pre><code>from django.views.generic import View\nfrom django.http import HttpResponse\nfrom django.utils.decorators import method_decorator\nfrom django.contrib.auth.decorators import login_required\nfrom django.views.decorators.csrf import csrf_exempt\n\n# Define a class-based view\nclass MyView(View):\n\n    # Apply the login_required decorator to the dispatch method\n    @method_decorator(login_required)\n    def dispatch(self, *args, **kwargs):\n        return super().dispatch(*args, **kwargs)\n\n    # Apply the csrf_exempt decorator to the post method\n    @method_decorator(csrf_exempt)\n    def post(self, request):\n        # Handle POST request\n        return HttpResponse(\"This is a POST request.\")\n\n    def get(self, request):\n        # Handle GET request\n        return HttpResponse(\"This is a GET request.\")\n</code></pre> <p>These decorators provide a wide range of functionality for controlling access, performance, and behavior within class-based views in Django applications. Depending on your application's requirements, you can use these decorators to enforce security measures, optimize performance, and customize the behavior of your views.</p>"},{"location":"backend/draft/#3-dispatch-method-in-class-based-views-django","title":"3. dispatch method in Class-Based-Views django","text":"<p>In Django, <code>dispatch</code> is a method provided by the <code>View</code> class, which is the base class for all <code>class-based views</code> (CBVs). The dispatch method is responsible for routing incoming requests to the appropriate HTTP method handlers (<code>get</code>, <code>post</code>, <code>put</code>, etc.) based on the request's HTTP method.</p> <p>Overall, <code>dispatch</code> serves as the entry point for request handling in <code>class-based views</code>, providing a centralized mechanism for routing requests to the appropriate method handlers and enabling extensibility and integration with Django's middleware architecture.</p> <p>When to use dispatch</p> <p>You should use the <code>dispatch</code> method in Django when you are working with <code>class-based views</code> (CBVs) and need to customize or extend the default request-handling behavior.</p> <p>Here are some scenarios where you might use <code>dispatch</code>:</p> <ol> <li> <p>Authentication and Authorization:</p> <p>You might use <code>dispatch</code> to enforce authentication and authorization requirements for your views. For example, you could override dispatch to check whether the user is authenticated and redirect them to a login page if not.</p> </li> <li> <p>Custom Request Processing:</p> <p>If you need to perform custom processing on incoming requests before they are handled by the view's methods (<code>get</code>, <code>post</code>, etc.), you can override <code>dispatch</code> to add this logic. This could include validation, parsing request data, or logging.</p> </li> <li> <p>Error Handling:</p> <p><code>dispatch</code> can be used to implement custom error handling logic for specific types of errors that occur during request processing. For example, you could override dispatch to catch certain exceptions and return a custom error response.</p> </li> <li> <p>Middleware Integration:</p> <p>If you're working with Django middleware and need to interact with requests at an early stage of processing, you can override <code>dispatch</code> to integrate middleware functionality. Middleware can intercept requests before they reach the view methods.</p> </li> <li> <p>Request Routing:</p> <p>While Django's default dispatch implementation routes requests based on the HTTP method (<code>GET</code>, <code>POST</code>, etc.), you might need to implement custom request routing logic for specialized use cases. Overriding dispatch allows you to customize how requests are routed within your view.</p> </li> </ol> <pre><code>from django.views import View\nfrom django.http import HttpResponse\nfrom django.contrib.auth.decorators import login_required\nfrom django.utils.decorators import method_decorator\n\nclass ProtectedView(View):\n    @method_decorator(login_required)\n    def dispatch(self, *args, **kwargs):\n        return super().dispatch(*args, **kwargs)\n\n    def get(self, request):\n        return HttpResponse(\"This is a protected GET request.\")\n\n    def post(self, request):\n        return HttpResponse(\"This is a protected POST request.\")\n</code></pre> <p>In summary, you should use the dispatch method whenever you need to customize or extend the default request-handling behavior of class-based views in Django. It provides a centralized hook for implementing various request-processing features, making it a powerful tool for building flexible and feature-rich web applications.</p>"},{"location":"backend/draft/#ajax-with-django","title":"Ajax with Django","text":""},{"location":"backend/draft/#testing-active-link-ajax","title":"TESTING active link ajax","text":"<p>To remove the <code>active</code> class from the previously clicked link before adding it to the currently <code>clicked link</code>, you can store a reference to the previously clicked link and remove the active class from it before adding it to the currently clicked link.</p> business.html<pre><code>$(document).ready(function(){\n    var previousClickedLink = null;  // Reference to the previously clicked link\n\n    function getCookie(name) {\n        var cookieValue = null;\n        if (document.cookie &amp;&amp; document.cookie !== '') {\n            var cookies = document.cookie.split(';');\n            for (var i = 0; i &lt; cookies.length; i++) {\n                var cookie = cookies[i].trim();\n                if (cookie.substring(0, name.length + 1) === (name + '=')) {\n                    cookieValue = decodeURIComponent(cookie.substring(name.length + 1));\n                    break;\n                }\n            }\n        }\n        return cookieValue;\n    }\n    var csrftoken = getCookie('csrftoken');\n\n    $('.business-item-link').click(function(event) {\n        event.preventDefault();\n\n        var slug = $(this).data('slug');\n        var clickedLink = $(this);  // Reference to the clicked link\n\n        // Remove active class from the previously clicked link\n        if (previousClickedLink !== null) {\n            previousClickedLink.removeClass('active');\n        }\n\n        // AJAX GET request to fetch data\n        $.ajax({\n            url: '/business/' + slug + '/ajax/',\n            type: 'GET',\n            beforeSend: function(xhr, settings) {\n                xhr.setRequestHeader(\"X-CSRFToken\", csrftoken);\n            },\n            success: function(response){\n                if (response.hasOwnProperty('title')) {\n                    $('.bt__bussiness--title').text(response.title);\n                }\n                console.log(\"Response content: \", response.content);\n                if (response.hasOwnProperty('content')) {\n                    $('.business-item-content').html(response.content);\n                }\n\n                // Add active class to the clicked link\n                clickedLink.addClass('active');\n\n                // Store a reference to the currently clicked link as the previous clicked link\n                previousClickedLink = clickedLink;\n            },\n            error: function(xhr, errmsg, err){\n                console.error('Error fetching data:', errmsg);\n            }\n        });\n    });\n});\n</code></pre> views.py<pre><code>class BusinessItemView(TemplateView):\n    template_name = 'business/business-item.html'\n\n    def get_context_data(self, **kwargs):\n        context = super().get_context_data(**kwargs)\n        slug = kwargs['slug']\n        business_item = get_object_or_404(BusinessItem, slug=slug)\n        context['business_item'] = business_item\n\n        business_inner = BusinessInner.objects.first()\n        context['business_inner'] = business_inner\n\n        return context\n\n    def get_ajax_data(self, request, *args, **kwargs):\n        slug = kwargs['slug']\n        business_item = get_object_or_404(BusinessItem, slug=slug)\n\n        # Construct data to send in JSON response\n        print(\"business_item: \", business_item)\n\n        # Check if this is the active link\n        absolute_url = business_item.get_absolute_url()\n        is_active = True if request.path == absolute_url else False\n\n        print('absolute_url: ', absolute_url)\n        print('is_active: ', is_active)\n\n        data = {\n            'title': business_item.title,\n            'content': business_item.content,\n            'is_active': is_active\n            # Add more data as needed\n        }\n        return JsonResponse(data)\n\n    def dispatch(self, request, *args, **kwargs):\n        # Check if it's an AJAX request\n        # if request.is_ajax(): is depreciated\n        if request.META.get('HTTP_X_REQUESTED_WITH') == 'XMLHttpRequest':\n            # If yes, call the get_ajax_data method\n            return self.get_ajax_data(request, *args, **kwargs)\n        else:\n            # If not, call the parent dispatch method to handle the regular view\n            return super().dispatch(request, *args, **kwargs)\n</code></pre> models.py<pre><code>class BusinessItem(models.Model):\n    CHOICES = (\n        ('1', 'Product &amp; Services'),\n        ('2', 'Business Consulting'),\n        ('3', 'IT Services'),\n    )\n    title = models.CharField(max_length=120)\n    category = models.CharField(max_length=20, choices=CHOICES)\n    content = HTMLField(null=True, blank=True)\n    slug = AutoSlugField(populate_from='title', unique=True, blank=True, default=None, editable=True)\n\n    def get_absolute_url(self):\n        return reverse('business:item_ajax', kwargs={'slug': self.slug})\n\n    def __str__(self):\n        return self.title\n\n    class Meta:\n        db_table = \"ispl_business_item\"\n        verbose_name = 'Business Item'\n        verbose_name_plural = 'Business Items'\n</code></pre>"},{"location":"backend/draft/#conditonally-display-team-image","title":"Conditonally display Team Image","text":"JavascriptPython <pre><code>$(document).ready(function() {\n    // Assuming `slug` and `csrftoken` are defined elsewhere\n    $.ajax({\n        url: '/about/' + slug + '/ajax/',\n        type: 'GET',\n        beforeSend: function(xhr, settings) {\n            xhr.setRequestHeader(\"X-CSRFToken\", csrftoken);\n        },\n        success: function(response) {\n            console.log('console response', response);\n\n            if (response.hasOwnProperty('title')) {\n                $('.bt__bussiness--title').text(response.title);\n            }\n\n            if (response.hasOwnProperty('content')) {\n                $('.business-item-content').html(response.content);\n            }\n\n            if (slug === 'message') {\n                if (response.hasOwnProperty('team_item')) {\n                    var teamItems = JSON.parse(response.team_item);\n                    $('.team-img').empty();\n                    teamItems.forEach(function(teamItem) {\n                        var itemHtml = `\n                            &lt;div class=\"team-item\"&gt;\n                                &lt;img src=\"/media/${teamItem.fields.image}\" alt=\"${teamItem.fields.name}\"&gt;\n                                &lt;h3&gt;${teamItem.fields.name}&lt;/h3&gt;\n                                &lt;h4&gt;${teamItem.fields.position}&lt;/h4&gt;\n                                ${teamItem.fields.content}\n                            &lt;/div&gt;\n                        `;\n                        $('.team-img').append(itemHtml);\n                    });\n                } else {\n                    // If `team_item` does not exist, ensure the `.team-img` is empty\n                    $('.team-img').empty();\n                }\n            } else {\n                // If `slug` is not 'message', ensure the `.team-img` is empty\n                $('.team-img').empty();\n            }\n\n            clickedLink.addClass('active');\n            previousClickedLink = clickedLink;\n        },\n        error: function(xhr, errmsg, err) {\n            console.error('Error fetching data:', errmsg);\n        }\n    });\n});\n</code></pre> views.py<pre><code>from django.shortcuts import render, get_object_or_404\nfrom django.views.generic import TemplateView, DetailView\nfrom django.http import JsonResponse\nfrom django.core.serializers import serialize\nfrom .models import About, AboutInner, AboutItem\nfrom teams.models import TeamItem\n\nclass AboutItemView(DetailView):\n    model = AboutItem\n    template_name = \"about_us/item.html\"\n    context_object_name = \"about_items\"\n    slug_field = 'slug'\n\ndef get_ajax_data(self, request, *args, **kwargs):\n    slug = kwargs['slug']\n    about_item = self.get_object()\n\n    absolute_url = about_item.get_absolute_url()\n    is_active = True if request.path == absolute_url else False\n\n    team_item = TeamItem.objects.all()\n    team_item_serailize = serialize('json', team_item)\n\n    data = {\n        'title': about_item.title,\n        'content': about_item.content,\n        'is_active': is_active,\n        'team_item': team_item_serailize\n    }\n    return JsonResponse(data)\n\ndef dispatch(self, request, *args, **kwargs):\n    # Check if it's an AJAX request\n    if request.META.get('HTTP_X_REQUESTED_WITH') == 'XMLHttpRequest':\n        # If yes, call the get_ajax_data method\n        return self.get_ajax_data(request, *args, **kwargs)\n    else:\n        # If not, call the parent dispatch method to handle the regular view\n        return super().dispatch(request, *args, **kwargs)\n</code></pre>"},{"location":"backend/draft/#django-ajax-view","title":"DJANGO AJAX VIEW","text":"<p>The <code>{% if not request.is_ajax %}</code> line in a Django template is used to conditionally render content based on whether the request is an AJAX request or not. However, this syntax is not directly supported in Django templates out of the box. Instead, you typically handle AJAX requests in your views and use different templates or partial templates based on the request type. Understanding AJAX in Django Views</p> <p>To render different content based on whether the request is an AJAX request, you need to handle this logic in your Django view. Here's how you can achieve this:</p> <ol> <li> <p>Detecting AJAX Requests in the View:</p> <p>You can check if the request is an AJAX request in your view using request.is_ajax(). This method was deprecated in Django 3.1 and removed in Django 4.0. Instead, you should check the HTTP_X_REQUESTED_WITH header directly.</p> </li> <li> <p>Handling AJAX and Non-AJAX Requests:</p> <p>Based on the request type, you can render different templates or return JSON responses.</p> <p>Example Implementation</p> ViewDjango TemplateJavaScript for AJAX <p>First, create a view that handles both AJAX and non-AJAX requests.</p> Django View<pre><code>from django.http import JsonResponse\nfrom django.core.serializers import serialize\nfrom django.views.generic.detail import DetailView\nfrom teams.models import TeamItem\nfrom about.models import AboutItem  # Adjust according to your actual model import\n\nclass AboutItemView(DetailView):\n    model = AboutItem\n    template_name = \"about_us/item.html\"\n    context_object_name = \"about_items\"\n    slug_field = 'slug'\n\n    def get_context_data(self, **kwargs):\n        context = super().get_context_data(**kwargs)\n        context['team_items'] = TeamItem.objects.all()\n        return context\n\n    def get_ajax_data(self, request, *args, **kwargs):\n        about_item = self.get_object()\n        team_items = TeamItem.objects.all()\n        team_items_serialized = serialize('json', team_items)\n\n        data = {\n            'title': about_item.title,\n            'content': about_item.content,\n            'team_item': team_items_serialized,\n        }\n        return JsonResponse(data)\n\n    def dispatch(self, request, *args, **kwargs):\n        if request.headers.get('x-requested-with') == 'XMLHttpRequest':\n            return self.get_ajax_data(request, *args, **kwargs)\n        return super().dispatch(request, *args, **kwargs)\n</code></pre> <p>In your template, you do not need to use <code>{% if not request.is_ajax %}</code>. Instead, you prepare the template to display the data properly. Here\u2019s an example:</p> <pre><code>&lt;div class=\"col-md-9\"&gt;\n    &lt;h5 class=\"bt__bussiness--title bt-sec-title\"&gt;{{ about_items.title }}&lt;/h5&gt;\n    &lt;div class=\"business-item-content\"&gt;{{ about_items.content | safe }}&lt;/div&gt;\n    &lt;div class=\"team-img\"&gt;\n        {% for team_item in team_items %}\n            &lt;div class=\"team-item\"&gt;\n                &lt;img src=\"{{ team_item.image.url }}\" alt=\"{{ team_item.name }}\"&gt;\n                &lt;h3&gt;{{ team_item.name }}&lt;/h3&gt;\n                &lt;h4&gt;{{ team_item.position }}&lt;/h4&gt;\n                {{ team_item.content | safe }}\n            &lt;/div&gt;\n        {% endfor %}\n    &lt;/div&gt;\n&lt;/div&gt;\n</code></pre> <p>Ensure your JavaScript handles the AJAX request correctly and updates the DOM if the request is an AJAX request.</p> <pre><code>$(document).ready(function() {\n    $.ajax({\n        url: '/about/' + slug + '/ajax/',\n        type: 'GET',\n        beforeSend: function(xhr, settings) {\n            xhr.setRequestHeader(\"X-CSRFToken\", csrftoken);\n        },\n        success: function(response) {\n            if (response.hasOwnProperty('title')) {\n                $('.bt__bussiness--title').text(response.title);\n            }\n\n            if (response.hasOwnProperty('content')) {\n                $('.business-item-content').html(response.content);\n            }\n\n            if (slug === 'message' &amp;&amp; response.hasOwnProperty('team_item')) {\n                var teamItems = JSON.parse(response.team_item);\n                $('.team-img').empty();\n                teamItems.forEach(function(teamItem) {\n                    var itemHtml = `\n                        &lt;div class=\"team-item\"&gt;\n                            &lt;img src=\"/media/${teamItem.fields.image}\" alt=\"${teamItem.fields.name}\"&gt;\n                            &lt;h3&gt;${teamItem.fields.name}&lt;/h3&gt;\n                            &lt;h4&gt;${teamItem.fields.position}&lt;/h4&gt;\n                            ${teamItem.fields.content}\n                        &lt;/div&gt;\n                    `;\n                    $('.team-img').append(itemHtml);\n                });\n            } else {\n                $('.team-img').empty();\n            }\n        },\n        error: function(xhr, errmsg, err) {\n            console.error('Error fetching data:', errmsg);\n        }\n    });\n});\n</code></pre> </li> </ol>"},{"location":"backend/draft/#summary","title":"Summary","text":"<ul> <li>View: Handles both AJAX and non-AJAX requests, returning JSON for AJAX requests and rendering the full template for non-AJAX requests.</li> <li>Template: Designed to display the necessary data without conditional AJAX checks.</li> <li>JavaScript: Properly handles the AJAX request and updates the DOM based on the response.</li> </ul> <p>By structuring your view and template this way, you can cleanly separate the handling of AJAX and non-AJAX requests.</p>"},{"location":"backend/draft/#plugins-ui","title":"Plugins UI","text":"<ul> <li>jQuery Flip</li> </ul>"},{"location":"backend/draft/#js","title":"JS","text":"<p>How to see the JavaScrit methods in the console.</p> <p>Tips</p> <ul> <li><code>console.log(obj)</code>: Logs the entire object to the console, showing properties and methods.</li> <li><code>Object.keys(obj)</code>: Returns an array of enumerable properties directly on the object.</li> <li><code>Object.getOwnPropertyNames(obj)</code>: Returns an array of all properties directly on the object.</li> <li><code>for...in loop</code>: Iterates over all enumerable properties, including inherited ones.</li> <li><code>Reflect.ownKeys(obj)</code>: Returns an array of all property keys on the object.</li> <li><code>Object.getOwnPropertyNames(Object.getPrototypeOf(obj))</code>: Returns an array of properties on the object's prototype, which includes methods.</li> </ul>"},{"location":"backend/draft/#ideas","title":"IDEAS","text":"<p>Django Project </p> <ol> <li>Multi Mullingual Database (MMDB)</li> </ol>"},{"location":"backend/draft/#translating-our-static-content","title":"Translating our static content","text":"<p>To translate strings that are used in templates, Django provides us with a trans template tag.</p>"},{"location":"backend/draft/#daintree-an-e-commerce-site","title":"<code>Daintree</code> \u2013 an E-commerce Site","text":"<p>A basic <code>e-commerce</code> site has one main purpose: to help users find and buy products from the online store. Django alone can be used to build an e-commerce site quickly, using database queries to allow searches across product range, but this doesn't scale well. Databases are designed to quickly save and retrieve rows of data, but they are not optimized to search across the entire dataset (or a subset). Once the traffic of your site starts to increase, you'll see the search speed go down very quickly. On top of that, there are some features that are very difficult to build with a database.</p> <p>Instead, we will use a search server. A search server is very much like a database.You give it some data to store and then you can retrieve it later. It also has features specifically built to help you add searching to your applications. You might wonder that if a search server can store our data like a database, then can we not just get rid of the database? We can, but usually it's not recommended. Why? Well, because the search server is designed for a different use case. While it can store your data, a database provides a lot of guarantees about the storage that a search server usually doesn't. For example, a good database (such as MySQL or PostgreSQL) gives you a guarantee that if you try to save something and the database returns a successful response, your data will not be lost in case of a crash or power outage or some other problem. This is called durability. A search server does not provide this guarantee because that's not what they are designed for. It is usually a good idea to keep our data in a database and use the search server just to search across our data.</p> <p>For the application that we will develop in this chapter, we will be using Elasticsearch, one of the most popular and perhaps easy-to-use search servers available. It's also open source and available for free. So let's get started. This is going to be an exciting chapter!</p> <p>To load the test data, run the following command after the <code>migrate</code> command:</p> <pre><code>python manage.py loaddata main/fixtures/initial.json\n</code></pre> <p>This should fill your database with a thousand sample products and give us enough data to play around with.</p>"},{"location":"backend/draft/#searching-from-python","title":"Searching from Python","text":"<p>The library that we will be using here is <code>elasticsearch_dsl</code>.</p> <pre><code>pip install elasticsearch_dsl\n</code></pre> <pre><code>&gt; python manage.py shell\n&gt; from elasticsearch_dsl import Search\n&gt; from elasticsearch_dsl.connections import connections\n&gt; connections.create_connection(hosts=['localhost:9200'])\n&lt;Elasticsearch([{u'host': u'localhost', u'port': 9200}])&gt;\n&gt; Search(index='daintree').query('match', name='django').execute().\nto_dict()\n{   \n    u'_shards': {u'failed': 0, u'successful': 5, u'total': 5},\n    u'hits': {u'hits': [{u'_id': u'1',\n    u'_index': u'daintree',\n    u'_score': 0.19178301,\n    u'_source': {u'category': u'Book',\n    u'name': u'Django Blueprints',\n    u'price': 50,\n    u'tags': [u'django', u'python', u'web applications']},\n    u'_type': u'products'}],\n    u'max_score': 0.19178301,\n    u'total': 1},\n    u'timed_out': False,\n    u'took': 2\n}\n</code></pre> <p>Let's take a look at each line. The first two lines simply import the library. The third line is important. It uses the create_connection method to define a default connection. This is the connection that will be used whenever we try to do a search using this library with the default settings.</p>"},{"location":"backend/draft/#elasticsearch-django","title":"Elasticsearch Django","text":"<p>watch this blog How to Use ElasticSearch With Django: medium</p> <ul> <li>Elasticsearch DSL: readthedocs</li> <li>elasticsearch-dsl 0.0.2 : pypi</li> <li>How to Use Elasticsearch with Django?</li> <li>How to Use ElasticSearch With Django: medium</li> </ul>"},{"location":"backend/draft/#signals","title":"Signals","text":"<p>Introduction</p> <p>There are 3 types of signals:</p> <ul> <li>pre_save/post_save: This signal works before/after the method <code>save()</code>.</li> <li>pre_delete/post_delete: This signal works before after deleting a model\u2019s instance (method <code>delete()</code>) this signal is thrown.</li> <li>pre_init/post_init: This signal is thrown before/after instantiating a model (<code>__init__()</code> method).</li> </ul> BasicIntermediate <p>How to Create and Use Signals in Django ?</p> <p>Example</p> <p>Sure! Let\u2019s walk through a simple example of using Django signals to automatically update a user profile's <code>post_count</code> field whenever a new <code>BlogPost</code> is created. This will demonstrate how to use Django signals in a real-world scenario.</p> <p>Step-by-Step Guide</p> <ol> <li> <p>Define the Models</p> <p>Create BlogPost and UserProfile models in your models.py file:</p> <pre><code># models.py\nfrom django.db import models\nfrom django.contrib.auth.models import User\n\nclass UserProfile(models.Model):\n    user = models.OneToOneField(User, on_delete=models.CASCADE)\n    post_count = models.PositiveIntegerField(default=0)\n\n    def __str__(self):\n        return self.user.username\n\nclass BlogPost(models.Model):\n    title = models.CharField(max_length=100)\n    content = models.TextField()\n    author = models.ForeignKey(User, on_delete=models.CASCADE)\n    created_at = models.DateTimeField(auto_now_add=True)\n\n    def __str__(self):\n        return self.title\n</code></pre> </li> <li> <p>Create the Signal Handler</p> <p>Create a <code>signals.py</code> file in your app directory and define the signal handler to update the <code>post_count</code>:</p> <pre><code># signals.py\nfrom django.db.models.signals import post_save\nfrom django.dispatch import receiver\nfrom .models import BlogPost, UserProfile\n\n@receiver(post_save, sender=BlogPost)\ndef update_post_count(sender, instance, created, **kwargs):\n    if created:\n        profile = UserProfile.objects.get(user=instance.author)\n        profile.post_count = BlogPost.objects.filter(author=instance.author).count()\n        profile.save()\n</code></pre> </li> <li> <p>Connect the Signal</p> <p>Ensure that the signal handler is connected by modifying the <code>apps.py</code> file of your app to import the signal handlers when the app is ready:</p> <pre><code># apps.py\nfrom django.apps import AppConfig\n\nclass YourAppConfig(AppConfig):\n    name = 'your_app'\n\n    def ready(self):\n        import your_app.signals\n</code></pre> </li> <li> <p>Ensure UserProfile is Created</p> <p>Make sure that a <code>UserProfile</code> is created whenever a new <code>User</code> is created. You can do this by using another signal:</p> <pre><code># signals.py (add this to the existing file)\nfrom django.db.models.signals import post_save\nfrom django.contrib.auth.models import User\nfrom django.dispatch import receiver\nfrom .models import UserProfile\n\n@receiver(post_save, sender=User)\ndef create_user_profile(sender, instance, created, **kwargs):\n    if created:\n        UserProfile.objects.create(user=instance)\n</code></pre> </li> <li> <p>Migrate Your Database</p> <p>Run the migrations to apply the changes to your database:</p> <pre><code>python manage.py makemigrations\npython manage.py migrate\n</code></pre> </li> <li> <p>Create and Save a Blog Post</p> <p>Now, create a new BlogPost instance and see the post_count update automatically:</p> <pre><code># Use the Django shell to test\npython manage.py shell\n\n&gt;&gt;&gt; from django.contrib.auth.models import User\n&gt;&gt;&gt; from your_app.models import BlogPost, UserProfile\n\n# Create a user and profile\n&gt;&gt;&gt; user = User.objects.create_user(username='testuser', password='password')\n&gt;&gt;&gt; user_profile = UserProfile.objects.get(user=user)\n\n# Create a new blog post\n&gt;&gt;&gt; new_post = BlogPost.objects.create(title='My First Post', content='This is the content of my first post.', author=user)\n\n# Check the updated post count\n&gt;&gt;&gt; user_profile.refresh_from_db()\n&gt;&gt;&gt; user_profile.post_count\n1\n</code></pre> </li> </ol> <p>Summary</p> <ol> <li>Models: Define BlogPost and UserProfile models in models.py.</li> <li>Signal Handler: Create signal handlers in signals.py to update the post count and create user profiles.</li> <li>App Configuration: Connect the signal in apps.py.</li> <li>Database Migrations: Run migrations to apply model changes.</li> <li>Usage: Create a BlogPost instance and observe the automatic update to the post_count.</li> </ol> <p>This example demonstrates how to use Django signals to perform an action (updating a profile\u2019s post count) in response to an event (creating a new blog post).</p>"},{"location":"backend/draft/#django-widgets","title":"Django widgets","text":"<p>Tip</p> <p>Django widgets have several attributes and methods that can be utilized for customization and functionality</p>"},{"location":"backend/draft/#common-attributes","title":"Common Attributes:","text":"<ul> <li> <p>attrs: A dictionary containing HTML attributes to be rendered with the widget, such as <code>{'class': 'form-control', 'placeholder': 'Enter your name'}</code>.</p> </li> <li> <p>template_name: Specifies the template used to render the widget. It allows you to customize the HTML markup of the widget.</p> </li> <li> <p>is_hidden: A boolean attribute indicating whether the widget should be rendered as hidden or not.</p> </li> <li> <p>choices: For choice-based widgets (like Select), it specifies the choices available for selection.</p> </li> <li> <p>required: Specifies whether the field is required or not.</p> </li> </ul>"},{"location":"backend/draft/#common-methods","title":"Common Methods:","text":"<ul> <li> <p>render: Renders the HTML markup of the widget. This method is called automatically when the widget is rendered in a template.</p> </li> <li> <p>value_from_datadict(data, files, name): Retrieves the value of the widget from the data dictionary.</p> </li> <li> <p>format_value(value): Formats the value of the widget before rendering.</p> </li> <li> <p>get_context(name, value, attrs): Returns a dictionary containing the context data used for rendering the widget template.</p> </li> <li> <p>id_for_label(id_): Returns the ID to be used for the  element associated with the widget.</p> </li> <li> <p>use_required_attribute(initial): Determines whether the widget should use the HTML required attribute based on the initial value.</p> </li> <li> <p>build_attrs(base_attrs, extra_attrs=None): Combines the base attributes with any extra attributes specified and returns a dictionary of HTML attributes.</p> </li> </ul>"},{"location":"backend/draft/#pcep-certifications","title":"PCEP Certifications","text":""},{"location":"backend/draft/#reference","title":"Reference","text":"<ul> <li>svgviewer.dev</li> <li> <p>svgtopng.com</p> </li> <li> <p>quote: you either die a hero or live long enough to see yourself become the villain</p> </li> </ul>"},{"location":"backend/intro/","title":"Intro","text":"<p>Backend</p> <ul> <li> <p> Django</p> </li> <li> <p> FastAPI</p> </li> </ul> <p>Solved Error in Ubuntu while instaling <code>mysqlclient</code></p> <pre><code>sudo apt-get install python3-dev default-libmysqlclient-dev build-essential\n\n# or\n\n# pkg-config: not found is a major hint at the problem and the solution - \n# you're missing build # tools and you need to install them.\n\napt-get install pkg-config build-essential libmysqlclient-dev\n</code></pre> <ul> <li> <p>Mysqlclient cannot install via pip, cannot find pkg-config name in Ubuntu</p> </li> <li> <p>Can not install apache-airflow-providers-mysql: pkg-config error</p> </li> </ul> <p>2002, \"Can't connect to local MySQL server through socket</p> <p>Use \"127.0.0.1\", instead of \"localhost\"</p> <ul> <li>2002, \"Can't connect to local MySQL server through socket '/var/run/mysqld/mysqld.sock' (2)\"</li> </ul> Danger <p>Could not build wheels for ...</p> <p>$ pip install --upgrade pip setuptools wheel</p> <ul> <li>build wheel error</li> </ul> <pre><code># Swagger Settings\n# SWAGGER_SETTINGS = {\n#     'SECURITY_DEFINITIONS': None,\n#     'USE_SESSION_AUTH': False,\n# }\n</code></pre>"},{"location":"backend/intro/#the-contrib-packages","title":"The contrib packages","text":"<p>The contrib packages are a part of Django that contain some very useful applications that the Django developers decided should be shipped with Django.</p> <p>The included applications provide an impressive set of features, including some that we'll be using in this application:</p> <ul> <li> <p>Admin is a full featured CMS that can be used to manage the content of a Django site. The Admin application is an important reason for the popularity of Django. We'll use this to provide an interface for site administrators to moderate and manage the data in our application.</p> </li> <li> <p>Auth provides user registration and authentication without requiring us to do any work. We'll be using this module to allow users to sign up, sign in, and manage their profiles in our application.</p> </li> </ul> <p>Django comes with a couple of <code>contrib</code> packages that speed up our work considerably.</p> Note <p>There are a lot more goodies in the contrib module. I suggest you take a look at the complete list at docs.djangoproject.com. </p> <p>I usually end up using at least three of the contrib packages in all my Django projects. They provide often-required features like <code>user registration</code> and <code>management</code>, and free you to work on the core parts of your project, providing a solid foundation to build upon.</p>"},{"location":"backend/intro/#reference","title":"Reference","text":"<ul> <li>Django Project Blueprints by Asad Jibran Ahmed, 2016 Packt Publishing</li> </ul>"},{"location":"backend/topic/","title":"Topic","text":"<p>To master backend frameworks, you'll need to cover a variety of topics that span programming languages, frameworks, and general backend development principles. Here\u2019s a comprehensive list to guide your learning:</p> Note IntroDetail <p>Mastering backend programming involves understanding a range of core concepts and technologies that are common across different backend languages and frameworks. Here\u2019s a comprehensive list of topics and common practices that you should be familiar with to become proficient in backend development, regardless of the specific language or framework:</p> <ol> <li> <p>Programming Languages</p> <ul> <li>Syntax and Semantics: Understanding the basic syntax and constructs of the language.</li> <li>Data Structures and Algorithms: Proficiency in data structures (arrays, lists, maps, sets) and algorithms for efficient problem-solving.</li> </ul> </li> <li> <p>Frameworks and Libraries</p> <ul> <li>Framework Architecture: Understanding how the framework structures an application (e.g., <code>MVC</code>, <code>MVP</code>, <code>MVVM</code>).</li> <li>Routing: Handling HTTP requests and directing them to appropriate controllers or handlers.</li> <li>Middleware: Using middleware for tasks like authentication, logging, and error handling.</li> </ul> </li> <li> <p>Databases</p> <ul> <li>Database Design: Designing relational schemas or NoSQL collections and understanding normalization.</li> <li>CRUD Operations: Performing Create, Read, Update, and Delete operations on databases.</li> <li>ORMs: Using Object-Relational Mappers to interact with databases (e.g., Django ORM, SQLAlchemy, Sequelize).</li> </ul> </li> <li> <p>APIs</p> <ul> <li>RESTful Services: Designing and implementing RESTful APIs, understanding HTTP methods (<code>GET</code>, <code>POST</code>, <code>PUT</code>, <code>DELETE</code>).</li> <li>GraphQL: Understanding GraphQL for more flexible and efficient querying of data.</li> <li>API Authentication: Implementing authentication mechanisms (e.g., <code>JWT</code>, <code>OAuth</code>).</li> </ul> </li> <li> <p>Security</p> <ul> <li>Authentication and Authorization: Implementing user authentication (e.g., sessions, tokens) and authorization (e.g., roles, permissions).</li> <li>Data Encryption: Protecting data in transit (SSL/TLS) and at rest (encryption algorithms).</li> <li>Vulnerabilities: Awareness of common security issues (e.g., SQL Injection, Cross-Site Scripting (XSS), Cross-Site Request Forgery (CSRF)).</li> </ul> </li> <li> <p>Performance Optimization</p> <ul> <li>Caching: Using caching strategies to improve performance (e.g., in-memory caching, distributed caching).</li> <li>Load Balancing: Distributing incoming traffic across multiple servers to ensure reliability and performance.</li> <li>Profiling and Monitoring: Analyzing performance bottlenecks and monitoring application health (e.g., logging, metrics).</li> </ul> </li> <li> <p>Scalability and Deployment</p> <ul> <li>Horizontal and Vertical Scaling: Techniques to scale applications (adding more servers or upgrading existing ones).</li> <li>Containerization: Using Docker to package applications and dependencies.</li> <li>Orchestration: Managing containerized applications with tools like Kubernetes.</li> </ul> </li> <li> <p>Testing</p> <ul> <li>Unit Testing: Writing tests for individual components or functions.</li> <li>Integration Testing: Testing interactions between components or systems.</li> <li>End-to-End Testing: Validating the complete workflow of the application.</li> </ul> </li> <li> <p>Version Control</p> <ul> <li>Git: Using version control systems to manage code changes, branches, and collaborations.</li> </ul> </li> <li> <p>Documentation</p> <ul> <li>Code Documentation: Writing clear, maintainable code with appropriate comments and documentation.</li> <li>API Documentation: Documenting APIs for users (e.g., using Swagger/OpenAPI).</li> </ul> </li> <li> <p>DevOps Practices</p> <ul> <li>Continuous Integration/Continuous Deployment (CI/CD): Automating the build, test, and deployment processes.</li> <li>Infrastructure as Code: Managing infrastructure using code (e.g., Terraform, Ansible).</li> </ul> </li> <li> <p>Soft Skills</p> <ul> <li>Problem Solving: Efficiently debugging and solving problems.</li> <li>Communication: Effectively communicating with team members and stakeholders.</li> <li>Project Management: Managing time and tasks efficiently, understanding agile methodologies.</li> </ul> </li> </ol> <p>By mastering these core topics, you will have a strong foundation in backend programming and be able to adapt to various languages and frameworks effectively.</p> <ol> <li> <p>Programming Languages</p> <ul> <li>JavaScript/TypeScript (for Node.js)</li> <li>Python (for Django, Flask)</li> <li>Ruby (for Ruby on Rails)</li> <li>Java (for Spring Boot)</li> <li>C# (for ASP.NET)</li> <li>PHP (for Laravel, Symfony)</li> <li>Go (for Go frameworks like Gin)</li> <li>Kotlin (for Ktor, Spring Boot)</li> </ul> </li> <li> <p>Framework Fundamentals</p> <ul> <li>Node.js (Express, Koa, NestJS)</li> <li>Django (Python)</li> <li>Flask (Python)</li> <li>Ruby on Rails (Ruby)</li> <li>Spring Boot (Java)</li> <li>ASP.NET Core (C#)</li> <li>Laravel (PHP)</li> <li>Symfony (PHP)</li> <li>Gin/Gorilla (Go)</li> <li>Ktor (Kotlin)</li> </ul> </li> <li> <p>Database Management</p> <ul> <li>Relational Databases (MySQL, PostgreSQL, SQL Server, SQLite)</li> <li>NoSQL Databases (MongoDB, Cassandra, Redis, DynamoDB)</li> <li>ORMs (Object-Relational Mappers) like Sequelize (Node.js), SQLAlchemy (Python), Hibernate (Java), Entity Framework (C#)</li> </ul> </li> <li> <p>API Design and Development</p> <ul> <li>RESTful APIs (HTTP methods, status codes, routing)</li> <li>GraphQL (Schema design, queries, mutations)</li> <li>Authentication &amp; Authorization (JWT, OAuth, API keys)</li> <li>Versioning (URL versioning, header versioning)</li> </ul> </li> <li> <p>Server Management</p> <ul> <li>Web Servers (Nginx, Apache)</li> <li>Application Servers (Gunicorn, uWSGI)</li> <li>Containerization (Docker, Kubernetes)</li> <li>Serverless Architectures (AWS Lambda, Azure Functions)</li> </ul> </li> <li> <p>Security Practices</p> <ul> <li>Data Encryption (SSL/TLS)</li> <li>Secure Coding Practices (SQL Injection, Cross-Site Scripting)</li> <li>Vulnerability Management (Regular security updates, Penetration testing)</li> </ul> </li> <li> <p>Performance Optimization</p> <ul> <li>Caching (Redis, Memcached)</li> <li>Load Balancing (Nginx, HAProxy)</li> <li>Profiling &amp; Monitoring (New Relic, Prometheus)</li> </ul> </li> <li> <p>Development Practices</p> <ul> <li>Version Control (Git)</li> <li>CI/CD (Continuous Integration/Continuous Deployment)</li> <li>Testing (Unit testing, Integration testing, End-to-end testing)</li> <li>Documentation (API documentation, code comments)</li> </ul> </li> <li> <p>DevOps and Cloud Services</p> <ul> <li>Cloud Providers (AWS, Azure, Google Cloud)</li> <li>Infrastructure as Code (Terraform, Ansible)</li> <li>Monitoring and Logging (ELK stack, Grafana)</li> </ul> </li> <li> <p>Soft Skills and Best Practices</p> <ul> <li>Code Quality (Code reviews, refactoring)</li> <li>Collaboration (Teamwork, communication)</li> <li>Problem Solving (Debugging, optimizing)</li> </ul> </li> </ol>"},{"location":"backend/topic/#learning-path","title":"Learning Path","text":"<ol> <li>Start with a Single Language and Framework: Get comfortable with one language and its associated framework.</li> <li>Learn Databases and APIs: Understand how to interact with databases and build APIs.</li> <li>Explore Other Frameworks: Once you're proficient, explore other frameworks and languages to broaden your knowledge.</li> <li>Practice Security and Performance: Apply best practices for security and performance in your projects.</li> <li>Master Deployment and DevOps: Learn how to deploy your applications and manage infrastructure effectively.</li> </ol> <p>By focusing on these areas, you\u2019ll gain a well-rounded understanding of backend development and be able to work with various frameworks and technologies.</p>"},{"location":"backend/topic/#topic-2","title":"Topic 2","text":"<p>Once you have a solid understanding of STATIC_ROOT and MEDIA_ROOT, you're well on your way to mastering Django's file handling and static files management. Here are some advanced topics and areas to focus on to deepen your expertise and become proficient in Django:</p> <ol> <li> <p>Advanced Static and Media Files Handling</p> <p>a.  Static Files Storage Backends</p> <ul> <li>Explore Different Storage Options: Learn about various storage backends for static and media files, such as cloud storage solutions (Amazon S3, Google Cloud Storage) or custom storage backends.</li> <li>Custom Storage Classes: Implement custom storage classes if you need to customize how files are stored.</li> </ul> <p>b.  Static Files Compression and Optimization</p> <ul> <li>Compress Static Files: Use tools like <code>django-compressor</code> or <code>whitenoise</code> to minify and compress CSS and JavaScript files.</li> <li>Cache Busting: Implement cache-busting techniques by using hashed file names to ensure clients always receive the latest version of static files.</li> </ul> </li> <li> <p>Deployment and Production Configuration</p> <p>a.  Web Server Configuration</p> <ul> <li>Serve Static and Media Files: Configure web servers like Nginx or Apache to serve static and media files efficiently in a production environment.</li> <li>Reverse Proxy: Set up a reverse proxy for handling requests and serving static content.</li> </ul> <p>b. Database and File Storage</p> <ul> <li>Database Optimization: Learn how to optimize database settings and queries for performance.</li> <li>File Storage Solutions: Set up and manage external file storage solutions (e.g., using Amazon S3 for media files).</li> </ul> </li> <li> <p>Security Practices</p> <p>a.  Secure File Handling</p> <ul> <li>File Upload Security: Implement security practices for handling file uploads to prevent malicious files from being uploaded.</li> <li>Access Controls: Restrict access to media files and directories to authorized users only.</li> </ul> <p>b.  Django Security Settings -   Security Middleware: Configure Django\u2019s security middleware to protect against common security threats. -   HTTPS: Ensure your application uses HTTPS to secure data in transit.</p> </li> <li> <p>Performance Optimization</p> <p>a.  Caching</p> <ul> <li>Implement Caching: Learn about caching strategies for improving performance, including file-based caching, database caching, and caching with external services like Redis or Memcached.</li> <li>Cache Static Files: Implement caching headers and strategies for static and media files.</li> </ul> <p>b.  Asynchronous Processing</p> <ul> <li>Background Tasks: Use tools like Celery for handling background tasks and processing long-running jobs.</li> <li>Asynchronous Views: Learn about Django\u2019s support for asynchronous views and handling high-concurrency scenarios.</li> </ul> </li> <li> <p>Internationalization and Localization</p> <p>a.  Translations</p> <ul> <li>Manage Translations: Learn how to manage and provide translations for different languages in your Django application.</li> <li>Localize Static and Media Content: Handle localization of static files if your application supports multiple languages.</li> </ul> </li> <li> <p>Advanced Template Management</p> <p>a.  Template Inheritance</p> <ul> <li>Use Template Inheritance: Master template inheritance to create reusable and maintainable templates.</li> </ul> <p>b.  Template Tags and Filters</p> <ul> <li>Custom Tags and Filters: Write custom template tags and filters to extend Django\u2019s templating capabilities.</li> </ul> </li> <li> <p>Testing and Quality Assurance</p> <p>a.  Write Tests</p> <ul> <li>Unit and Integration Tests: Write comprehensive unit and integration tests for your views, models, and static/media file handling.</li> <li>Test Static and Media Handling: Ensure your file handling is thoroughly tested, including edge cases and error scenarios.</li> </ul> <p>b.  Continuous Integration</p> <ul> <li>CI/CD Pipelines: Set up continuous integration and deployment pipelines to automate testing and deployment.</li> </ul> </li> <li> <p>Project Structure and Best Practices</p> <p>a.  Organize Project Files</p> <ul> <li>Project Organization: Learn best practices for organizing Django projects and applications to maintain a clean and scalable codebase.</li> </ul> <p>b.  Django Conventions -   Follow Conventions: Adhere to Django\u2019s conventions and best practices for code quality and maintainability.</p> </li> </ol> <p>By delving into these areas, you\u2019ll gain a comprehensive understanding of Django\u2019s capabilities and become adept at building robust, scalable, and secure web applications.</p>"},{"location":"backend/topic/#django-conventions","title":"Django Conventions","text":"<p>b. Django Conventions</p> <ol> <li> <p>Follow Django\u2019s Conventions</p> <ul> <li> <p>Naming Conventions: Use consistent naming conventions. For instance, name your models using CamelCase (e.g., <code>Book</code>), and use snake_case for file names (e.g., <code>my_model.py</code>).</p> </li> <li> <p>Views and URLs: Organize your views in a way that aligns with Django\u2019s best practices. For example, use class-based views (CBVs) or function-based views (FBVs) consistently within an application. Define your URL patterns in a <code>urls.py</code> file, and consider using Django\u2019s include() function to include URL configurations from individual applications.</p> </li> <li> <p>Templates and Static Files: Use the <code>templates</code> directory for your HTML templates and the static directory for static files. Ensure that you use template inheritance and reusable components to avoid duplication.</p> </li> </ul> </li> <li> <p>Code Quality</p> <ul> <li>DRY Principle: Don\u2019t Repeat Yourself. Avoid code duplication by creating reusable components, functions, or classes.</li> <li>Modular Design: Break down large applications into smaller, manageable pieces. For example, create separate apps for different functionalities.</li> <li>Documentation: Document your code with docstrings and comments where necessary. This helps others understand your code and contributes to maintainability.</li> </ul> </li> <li> <p>Testing</p> <ul> <li>Unit Tests: Write unit tests for your models, views, and other critical parts of your application. Use Django\u2019s testing framework and place your tests in <code>tests.py</code> within each application.</li> <li>Integration Tests: Ensure your application\u2019s components work together as expected by writing integration tests.</li> </ul> </li> <li> <p>Security</p> <ul> <li>Keep Secret Keys Secret: Store sensitive information like Django secret keys in environment variables or a secure configuration file.</li> <li>Use Django\u2019s Built-in Security Features: Enable security features like CSRF protection, XSS protection, and SQL injection prevention.</li> </ul> </li> <li> <p>Performance</p> <ul> <li>Database Indexing: Use indexes on frequently queried fields to improve performance.</li> <li>Caching: Implement caching strategies to speed up your application, especially for frequently accessed data.</li> </ul> </li> </ol> <p>By adhering to these best practices and conventions, you can ensure that your Django project remains organized, maintainable, and scalable as it grows.</p>"},{"location":"backend/core/designpatterns/intro/","title":"Design Pattern","text":""},{"location":"backend/core/designpatterns/model-mixins-patterns/","title":"Model Mixins Pattern","text":"<p>This is under structural pattern.</p>"},{"location":"backend/core/designpatterns/model-mixins-patterns/#pattern-a-model-mixins","title":"Pattern a model mixins","text":"<ul> <li>Problem: Distinct models have the same fields and/or methods duplicated violating the DRY principle.</li> <li>Solution: Extract common fields and methods into various reusable model mixins.</li> </ul> <p>Model mixins</p> <p>Model mixins are abstract classes that can be added as a parent class of a model. Python supports multiple inheritances, unlike other languages such as Java. Hence, you can list any number of parent classes for a model.</p> <p>Smaller mixins are better. Whenever a mixin becomes large and violates the single responsibility principle, consider refactoring it into smaller classes. Let a mixin do one thing and do it well. </p> <p>In our previous example, the model mixin used to update DSFBUFE and NPEJGJFE time can be easily factored out, as shown in the following code:</p> models.py<pre><code>class TimeStampModel(models.Model):\n    created = models.DateTimeField(auto_now_add=True)\n    modified = models.DateTimeField(auto_now=True)\n\n    class Meta:\n        abstract = True\n\nclass Postable(TimeStampModel):\n    message = models.TextField(max_length=500)\n\n    class Meta:\n        abstract = True\n\nclass Post(Postable):\n    ...\n\nclass Comment(Postable):\n    ...\n</code></pre> <p>We have two base classes now. However, the functionality is clearly separated. The mixin can be separated into its own module and reused in other contexts.</p>"},{"location":"backend/core/designpatterns/template-patterns/","title":"Template Patterns","text":""},{"location":"backend/core/designpatterns/template-patterns/#template-patterns","title":"Template patterns","text":"<p>Django's template language is quite simple. However, you can save a lot of time by following some elegant template design patterns.</p>"},{"location":"backend/core/designpatterns/template-patterns/#pattern-the-active-link","title":"Pattern - <code>the active link</code>","text":"<p>Solution</p> <p>There are several solutions to determine the active link. Excluding JavaScript-based approaches, they can be mainly grouped into <code>template-only</code> and <code>custom tag-based</code> solutions.</p> A template-only SolutionCustom tags <pre><code>&lt;ul class=\"nav\"&gt;\n    &lt;li class=\"{% if request.path == '/' %}active{% endif %}\"&gt;\n        &lt;a href=\"/\"&gt;Home&lt;/a&gt;\n    &lt;/li&gt;\n    &lt;li class=\"{% if request.path == '/about/' %}active{% endif %}\"&gt;\n        &lt;a href=\"/about/\"&gt;About&lt;/a&gt;\n    &lt;/li&gt;\n&lt;/ul&gt;\n</code></pre> nav.py<pre><code>from django.urls import resolve\nfrom django import template\n\nregister = template.Library()\n\n@register.simple_tag\ndef active_nav(request, url):\n    url_name = resolve(request.path).url_name\n\n    print(\"url :\", urls , \" , url_name: \", url_name)\n\n    if url_name == url:\n        return \"active\"\n    return \"\"\n\n# slighly advanced\n@register.simple_tag\ndef active_nav(request, *urls):\n    url_name = resolve(request.path).url_name\n\n    print(\"url :\", urls , \" , url_name: \", url_name)\n\n    if url_name in urls:\n        return \"active\"\n    return \"\"\n</code></pre> Note <p>In Django, it's standard practice to keep custom template tags within the app they belong to, usually in a templatetags directory within the app's directory structure. This convention helps maintain a clear separation of concerns and promotes modularity and reusability.</p> <p>While it's technically possible to place templatetags outside of the app, it's generally not recommended unless there's a compelling reason to do so. Placing templatetags outside of the app may lead to a less organized codebase and make it harder for developers to understand the relationships between different components.</p> <p>However, if you have templatetags that are generic and reusable across multiple apps or even across different projects, you might consider creating a separate reusable Django app specifically for those templatetags. This approach allows you to centralize reusable functionality while still maintaining modularity and encapsulation.</p>"},{"location":"backend/core/designpatterns/template-patterns/#reference","title":"Reference","text":"<ul> <li>Django Design Patterns and Best Practices :pg-102</li> </ul>"},{"location":"backend/core/designpatterns/user-profile-patterns/","title":"User Profile Pattern","text":"<p>This pattern is under structural</p>"},{"location":"backend/core/designpatterns/user-profile-patterns/#pattern-a-user-profiles","title":"Pattern a user profiles","text":"<p>Note</p> <ul> <li>Problem: Every website stores a different set of user profile details. However, Django's built-in user model is meant for authentication details.</li> <li>Solution: Create a user profile class with a one-to-one relation with the user model.</li> </ul>"},{"location":"backend/core/designpatterns/user-profile-patterns/#problem-details","title":"Problem details","text":"<p>Out of the box, Django provides a pretty decent user model. You can use it when you create a super user or login to the admin interface. It has a few basic fields, such as full name, username, and email.</p> <p>However, most real-world projects keep a lot more information about users, such as their address, favorite movies, or their superpower abilities. From Django 1.5 onwards, the default user model can be extended or replaced. However, official docs strongly recommend storing only authentication data even in a custom user model (it belongs to the BVUI app, after all).</p> <p>Certain projects need multiple types of users. For example, SuperBook can be used by superheroes and non-superheroes. There might be common fields and some distinctive fields based on the type of user.</p>"},{"location":"backend/core/designpatterns/user-profile-patterns/#solution-details","title":"Solution details","text":"<p>The officially recommended solution is to create a user profile model. It should have a <code>one-to-one</code> relation with your user model. All the additional user information is stored in this model:</p> <p>Tip</p> models.py<pre><code>class Profile(models.Model):\n    user = models.OneToOneField(settings.AUTH_USER_MODEL, on_delete=models.CASCADE, primary_key=True)\n</code></pre> <p>It is recommended that you set the <code>primary_key</code> explicitly to <code>True</code> to prevent concurrency issues in some database backends such as PostgreSQL. The rest of the model can contain any other user details, such as birth-date, favorite color, and so on.</p> <p>While designing the profile model, it is recommended that all the profile detail fields must be <code>nullable</code> or contain <code>default</code> values. Intuitively, we can understand that a user cannot fill out all their profile details while signing up. Additionally, we will ensure that the signal handler also doesn't pass any initial parameters while creating the profile instance.</p>"},{"location":"backend/core/designpatterns/user-profile-patterns/#signals","title":"Signals","text":"<p>Ideally, every time a user model instance is created, a corresponding user profile instance must be created as well. This is usually done using signals.</p> <p>For example, we can listen for the <code>post_save</code> signal from the user model using the following signal handler in <code>profiles/signals.py</code>:</p> <p>Tip</p> models.py<pre><code>from django.db.models.signals import post_save\nfrom django.dispatch import receiver\nfrom django.conf import settings\nfrom .models\n\n@receiver(post_save, sender=settings.AUTH_USER_MODEL)\ndef create_profile_handler(sender, instance, created, **kwargs):\n    if not created:\n        return\n\n    # Create the profile object, only if it is newly created\n    profile = models.Profile(user=instance)\n    profile.save()\n</code></pre> <p>The <code>profile</code> model has passed no additional initial parameters except for the <code>user=instance</code>.</p> <p>Previously, there was no specific place for initializing the signal code. Typically, they were imported or implemented in <code>models.py</code> (which was unreliable). However, with app-loading refactor in Django 1.7, the application initialization code location is well defined.</p> <p>First, subclass the <code>ProfileConfig</code> method in <code>apps.py</code> within the profiles app and set up the signal in the ready method:</p> <p>Tip</p> apps.py<pre><code>from django.apps import AppConfig\n\nclass ProfilesConfi(AppConfig):\n    name = \"profiles\"\n    verbose_name = 'User Profiles'\n\n    def ready(self):\n        from . import signals\n</code></pre> <p>Next, change the line mentioning profiles in your <code>INSTALLED_APPS</code> to a dotted path pointing to this <code>AppConfig</code>. So your settings should look as follows:</p> settings.py<pre><code>INSTALLED_APPS = [\n    'profiles.apps.ProfilesConfig',\n    'posts',\n    ...\n]\n</code></pre> <p>With your signals set up, accessing <code>user.profile</code> should return a <code>Profile</code> object to all users, even the newly created ones.</p>"},{"location":"backend/core/designpatterns/user-profile-patterns/#admin","title":"Admin","text":"<p>Now, a user's details will be in two different places within the admin: the authentication details in the usual user admin page, and the same user's additional profile details in a separate profile admin page. This gets very cumbersome.</p> <p>For convenience, the profile admin can be made inline to the default user admin by defining a custom <code>UserAdmin</code> in <code>profiles/admin.py</code> as follows:</p> <p>Tip</p> admin.py<pre><code>from django.contrib import admin\nfrom django.contrib.auth.admin imort UserAdmin\nfrom .models import Profile\nfrom django.contrib.auth.models import User\n\nclass UserProfileInline(admin.StackedInline):\n    model = Profile\n\nclass NewUserAdmin(UserAdmin):\n    inlines = [UserProfileInline]\n\nadmin.site.unregister(User)\nadmin.site.register(User, NewUserAdmin)\n</code></pre>"},{"location":"backend/core/designpatterns/user-profile-patterns/#multiple-profile-types","title":"Multiple profile types","text":"<p>Assume that you need several kinds of users and their corresponding profiles in your application - there needs to be a field to track which type of profile the user has. The <code>Profile</code> data itself needs to be stored in separate models or a unified model.</p> <p>An aggregate <code>Profile</code> approach is recommended since it gives the flexibility to change the <code>Profile</code> types without loss of <code>Profile</code> details and minimizes complexity. In this approach, the <code>Profile</code> model contacins a superset of all profile fields from all <code>Profile</code> types.</p> <p>For example, SuperBook will need a superhero type profile and an ordinary (non-superhero) profile. It can be implemented using a single unified profile model as follows:</p> <p>Tip</p> models.py<pre><code>class BaseProfile(models.Model):\n\n    USER_TYPES = (\n        (0, 'Ordinary'),\n        (1, 'SuperHero'),\n    )\n\n    user = models.OneToOneField(settings.AUTH_USER_MODEL, primary_key=True)\n    user_type = models.IntegerField(max_length=1, null=True, choices=USER_TYPES)\n    bio = models.CharField(max_length=200, blank=True, null=True)\n\n    def __str__(self):\n        return \"{}: {:.20\".format(self.user, self.bio or \"\")\n\n    class Meta:\n        abstract = True\n\n\nclass SuperHeroProfile(models.Model):\n    origin = models.CharField(max_length=100, blank=True, null=True)\n\n    class Meta:\n        abstract = True\n\n\nclass OrdinaryProfile(models.Model):\n    address = models.CharField(max_length=200, blank=True, null=True)\n\n    class Meta:\n        abstract = True\n\n\n\nclass Profile(SuperHeroProfile, OrdinaryProfile, BaseProfile):\n    pass\n</code></pre> <p>We grouped the profile details into several abstract base classes to separate concerns. The <code>BaseProfile</code> class contains all the common profile details irrespective of the user type. It also has a <code>user_type</code> field that keeps track of the user's active profile.</p> <p>The <code>SuperHeroProfile</code> class and <code>OrdinaryProfile</code> class contain the <code>Profile</code> details specific to superhero and non-hero users, respectively. Finally, the <code>Profile</code> class derives from all these base classes to create a superset of profile details.</p> <p>Some details to take care of while using this approach are as follows:</p> <ul> <li>All <code>Profile</code> fields that belong to the class or its abstract bases classes must be nullable or with defaults.</li> <li>This approach might consume more database space per user, but gives immense flexibility.</li> <li>The active and inactive fields for a <code>Profile</code> type need to be managed outside the model. For example, a form to edit the profile must show the appropriate fields based on the currently active user type.</li> </ul>"},{"location":"backend/core/designprinciple/design-principle/","title":"Design Principle","text":""},{"location":"backend/core/designprinciple/design-principle/#design-principle","title":"Design Principle","text":"<p>Design principles in Python, like in any programming language, help create clean, maintainable, and efficient code. Here are some key design principles with examples:</p> <p></p>"},{"location":"backend/core/designprinciple/design-principle/#reference","title":"Reference","text":"<ul> <li>Design Principles in Python/Django</li> </ul>"},{"location":"backend/core/server/web-server/","title":"Web Server","text":""},{"location":"backend/core/server/web-server/#gunicorn-green-unicorn","title":"Gunicorn <code>(Green Unicorn)</code>","text":"<p>Gunicorn is a WSGI server for Python applications, well known for its advanced process management features.</p> <p></p> <p>If you have Python 3.5 and later, you can install Gunicorn using pip:</p> <p>Tip</p> bash<pre><code>$ pip install gunicorn\n</code></pre>"},{"location":"backend/core/server/web-server/#uvicorn","title":"Uvicorn","text":"<p>Uvicorn is an ASGI server implementation for Python.</p> <p>Tip</p> bash<pre><code>$ pip install uvicorn[standard] \n# includes installation of optional and Cython-based dependencies\n</code></pre>"},{"location":"backend/core/server/web-server/#daphne","title":"Daphne","text":"<p>Daphne is one of the first ASGI server implementations used as a reference for ASGI server implementations.</p> <p>Tip</p> bash<pre><code>$ pip install daphne\n</code></pre>"},{"location":"backend/core/server/web-server/#reference","title":"Reference","text":"<ul> <li>9 Python Web Servers to Try for Your Next Project </li> </ul>"},{"location":"backend/course/course/","title":"Course","text":"<p>Example Learning Plan: Learning a New Programming Language Week 1: Basics</p> <pre><code>Day 1-2: Read introductory material and understand the language\u2019s syntax and basic constructs.\nDay 3-4: Work through basic tutorials and exercises.\nDay 5-7: Complete simple practice problems and review basics.\n</code></pre> <p>Week 2: Intermediate Concepts</p> <pre><code>Day 1-2: Learn about data structures and algorithms in the new language.\nDay 3-4: Implement intermediate-level exercises.\nDay 5-7: Start a mini-project to apply intermediate concepts.\n</code></pre> <p>Week 3: Advanced Topics</p> <pre><code>Day 1-2: Explore advanced features or libraries of the language.\nDay 3-4: Work on advanced exercises or problems.\nDay 5-7: Develop a more complex project or contribute to an open-source project.\n</code></pre> <p>Week 4: Review and Real-World Application</p> <pre><code>Day 1-2: Review what you\u2019ve learned and identify areas for improvement.\nDay 3-4: Refactor and enhance your projects based on feedback.\nDay 5-7: Apply your knowledge to solve real-world problems or complete a significant project.\n</code></pre> <p>Tips for Effective Learning</p> <pre><code>Stay Consistent: Regular, focused study sessions are more effective than sporadic, lengthy ones.\nBe Adaptable: Adjust your plan based on progress and feedback.\nDocument Learning: Keep notes or a journal to track what you\u2019ve learned and reflect on your progress.\nEngage with the Community: Participate in forums, attend meetups, or join study groups to stay motivated and gain insights.\n</code></pre> <p>By following a structured plan, you\u2019ll be able to learn new programming topics systematically and effectively.</p>"},{"location":"backend/course/intro/","title":"Intro","text":""},{"location":"backend/course/intro/#site","title":"Site","text":"<ul> <li>Meta Course: tutsnode.org</li> </ul>"},{"location":"backend/course/intro/#frontend-course","title":"Frontend Course","text":"<ul> <li>Courses :legacy.reactjs.org</li> <li>Meta Front-End Developer Professional Certificate</li> </ul>"},{"location":"backend/course/intro/#backend-course","title":"Backend Course","text":""},{"location":"backend/course/planning/","title":"Planning","text":"<p>weekly planning</p>"},{"location":"backend/django/context-processors/","title":"Context Processors","text":"<p>Context processors</p> <p>A context processor is a Python function that takes the request object as an argument and returns a dictionary that gets added to the request context. Context processors come in handy when you need to make something available globally to all templates.</p> <p>Django 4 by Example <code>pg: 363</code></p>"},{"location":"backend/django/context-processors/#other-topic","title":"Other Topic","text":"question Example 1Example 2 <p>Django mixins and context processors serve different purposes and are used in different parts of a Django application:</p> <p>For sharing common elements like headers and footers across multiple templates in Django, using context processors is typically the more appropriate approach.</p> <p>Here's why:</p> <ol> <li> <p>Scope:</p> <ul> <li>Context processors operate at the template level, meaning they affect the rendering of templates across the entire project. By using context processors, you can ensure that the header and footer data is available in every template without explicitly passing it from every view.</li> <li>Mixins, on the other hand, are used within the context of views or models. While they can encapsulate common functionality, they're not designed for injecting data into templates.</li> </ul> </li> <li> <p>Purpose:</p> <ul> <li>Context processors are specifically designed for injecting global context variables into templates. They are intended for providing data like headers, footers, site-wide settings, or user authentication status that need to be available in multiple templates.</li> <li>Mixins are used to extend the functionality of views or models. While you could potentially use mixins to share code related to rendering headers and footers, it would be less straightforward and less conventional than using context processors for this purpose.</li> </ul> </li> <li> <p>Ease of Use:</p> <ul> <li>Context processors provide a simple and consistent way to inject data into templates without requiring modification of every view function or class.</li> <li>Using mixins to achieve a similar result would involve inheritance and potentially coupling the logic for rendering headers and footers with the behavior of specific views, which can make the code less modular and harder to maintain.</li> </ul> </li> </ol> <p>Therefore, for sharing header and footer templates across all templates in your Django project, using context processors is the recommended approach. This allows you to keep your templates clean and DRY (Don't Repeat Yourself) by centralizing the header and footer logic in one place.</p>"},{"location":"backend/django/context-processors/#1-mixins","title":"1.  Mixins:","text":"<ul> <li>Mixins are classes that provide additional functionality to Django class-based views (CBVs) or models.</li> <li>They are used to encapsulate reusable pieces of code that can be mixed into multiple views or models.</li> <li>Mixins are primarily used to add common behavior, such as authentication, - permissions, or extra methods, to multiple views or models without duplicating code.</li> <li>Mixins are applied by inheriting from them in view classes or model classes.</li> <li>Mixins are typically used within the scope of handling HTTP requests and responses, allowing you to extend and customize the behavior of views or models.</li> </ul>"},{"location":"backend/django/context-processors/#2-context-processors","title":"2. Context Processors:","text":"<ul> <li>Context processors are functions that add additional data to the context of Django templates.</li> <li>They are used to inject global context variables into all templates across your Django project.</li> <li>Context processors are invoked each time a template is rendered and allow you to include dynamic data or data that is common to multiple templates without explicitly passing it from every view.</li> <li>Context processors are typically used to provide data such as user authentication status, site-wide settings, or dynamic content that needs to be available to all templates.</li> <li>Context processors operate at a higher level than mixins, influencing the rendering of templates rather than the behavior of views or models.</li> </ul> <p>In summary, mixins are used to extend the functionality of views or models by adding methods, properties, or behaviors, while context processors are used to inject additional data into the context of Django templates. Mixins are applied within the scope of views or models, while context processors affect the rendering of templates across the entire project.</p>"},{"location":"backend/django/decorator/","title":"Decorators","text":"<p>Before <code>class-based</code> views, decorators were the only way to change the behavior of <code>function-based</code> views. </p> <p>Being wrappers around a function, they cannot change the inner working of the view, and thus effectively treat them as black boxes.</p> <p>A decorator is a function that takes a function and returns the decorated function.</p> <p>Use the annotation notation <code>@</code>, as shown in the following <code>login_required</code> decorator example:</p> <pre><code>@login_required\ndef simple_view(request):\n    return HttpResponse()\n</code></pre> <p>The following code is exactly the same as the preceding:</p> <pre><code>def simple_view(request):\n    return HttpResponse()\n\nsimple_view = login_required(simple_view)\n</code></pre> <p>Decorators are less flexible than mixins. However, they are simpler. You can use both decorators and mixins in Django. In fact, many mixins are implemented with decorators.</p>"},{"location":"backend/django/django-404/","title":"django 404","text":"<p>Sure, I can guide you through how an experienced Django developer might implement a custom 404 page using class-based views. In Django, you can customize error pages like 404 (page not found), 500 (server error), etc., to match the look and feel of your website.</p> <p>Here's how you could do it using class-based views:</p> <p>Create a Custom 404 View Class: First, you'll need to create a view class for handling the 404 error. You can do this by subclassing Django's TemplateView or any other relevant class-based view. Override the get() Method: In the custom view class, override the get() method to customize what happens when the view is accessed. You can render a specific template or perform any other actions you want. Set Up URL Configuration: You'll need to wire up this custom view to the URL pattern for 404 errors in your Django project's URL configuration.</p> <p>Note</p> views.pyurls.py <pre><code>from django.views.generic import TemplateView\n\nclass Custom404View(TemplateView):\n    template_name = '404.html'  # Path to your custom 404 template\n\n    def get(self, request, *args, **kwargs):\n        context = self.get_context_data(**kwargs)\n        # You can add additional context data here if needed\n        return self.render_to_response(context)\n</code></pre> <pre><code>from django.urls import path\nfrom .views import Custom404View\n\n# Other URL patterns...\n\n# Define the custom 404 page URL\nurlpatterns = [\n    # Other URL patterns...\n    path('404/', Custom404View.as_view(), name='404'),\n]\n\n# or\n\nfrom django.urls import path\nfrom django.conf.urls import handler404\nfrom yourapp.views import Custom404View\n\nurlpatterns = [\n    # Your other URL patterns...\n]\n\nhandler404 = Custom404View.as_view()\n</code></pre> <p>In this configuration:</p> <ul> <li>The <code>handler404</code> setting specifies the view that Django should use when it encounters a 404 error.</li> <li>Here, we set it to <code>Custom404View.as_view()</code>, which means Django will use your custom 404 view (<code>Custom404View</code>) to render the response for 404 errors.</li> </ul>"},{"location":"backend/django/django-404/#reference","title":"Reference","text":"<ul> <li>Django 404 (page not found) :w3schools</li> </ul>"},{"location":"backend/django/django-form/","title":"django form","text":""},{"location":"backend/django/django-form/#basic","title":"Basic","text":"<p>Types of Form in Django</p> <p>1. Form</p> <p>Django Forms (<code>django.forms.Form</code>)</p> <p>2. ModelForm</p> <p>Model Forms (<code>django.forms.ModelForm</code>)</p> Django Forms library <p></p> <pre><code>#from django.forms import Form, ModelForm\n</code></pre>"},{"location":"backend/django/django-form/#the-django-forms-library","title":"The Django Forms library","text":"<p>The Django Forms library allows you to quickly define a form using a Python class. This is done by creating a <code>subclass</code> of the base <code>Django Form class</code>.</p> <ul> <li>We refer to our classes as forms, similar to how we subclass Django Models to create Model classes. </li> <li>Forms contain one or more fields of a certain type (such as text fields, number fields, or email fields). </li> <li>You\u2019ll notice this sounds like Django Models, and forms are similar to Models but use different field classes.</li> </ul> <pre><code>from django import forms\n\nclass ExampleForm(forms.Form):\n    text_input = forms.CharField()\n    password_input =\n    forms.CharField(widget=forms.PasswordInput)\n</code></pre> <p>Web Development with Django by Bharath Chandra K S - 2nd, 2023</p>"},{"location":"backend/django/django-form/#working-with-form-views","title":"Working with <code>form views</code>","text":"<p>A form view is just like any other view class, except that a form view class is designed to process and handle form objects and form submissions. </p> <p>Django offers four main form view classes, listed here:</p> <ul> <li>FormView</li> <li>CreateView</li> <li>UpdateView</li> <li>DeleteView</li> </ul> <p>These can all be found in the <code>django.views.generic.edit</code> library.</p>"},{"location":"backend/django/django-form/#advanced","title":"Advanced","text":""},{"location":"backend/django/django-form/#example","title":"Example","text":"<p>Website Contact Section</p> viewsmodelscontactcontact successurl Conf <p>In your ContactFormView in <code>form_valid()</code> method, you're trying to call <code>form.save(commit=False)</code>. But <code>commit=False</code> is used in model forms, not in regular forms. </p> <p>Since you're using a regular form, you won't have this attribute available. Here's the corrected version:</p> views.py<pre><code># contact/views.py\nfrom django.shortcuts import render, redirect\nfrom django.views.generic import FormView, TemplateView\nfrom .forms import ContactForm\nfrom .models import ContactMessage\n\nclass ContactFormView(FormView):\n    template_name = 'contacts/contact.html'\n    form_class = ContactForm\n    success_url = '/contact/success/'\n\n    def form_valid(self, form):\n        name = form.cleaned_data['name']\n        email = form.cleaned_data['email']\n        message = form.cleaned_data['message']\n\n        # Create and save ContactMessage instance\n        contact_message = ContactMessage.objects.create(name=name, email=email, message=message)\n\n        return super().form_valid(form)\n\nclass ContactSuccessView(TemplateView):\n    template_name = 'contact/contact_success.html'\n</code></pre> models.py<pre><code># contact/models.py\nfrom django.db import models\n\nclass ContactMessage(models.Model):\n    name = models.CharField(max_length=100)\n    email = models.EmailField()\n    message = models.TextField()\n    timestamp = models.DateTimeField(auto_now_add=True)\n\n    def __str__(self):\n        return self.name\n</code></pre> contact.html<pre><code>&lt;!-- contact/templates/contact/contact.html --&gt;\n&lt;form method=\"post\"&gt;\n{% csrf_token %}\n{{ form.as_p }}\n&lt;button type=\"submit\"&gt;Submit&lt;/button&gt;\n&lt;/form&gt;\n</code></pre> contact_success.html<pre><code>&lt;!-- contact/templates/contact/contact_success.html --&gt;\n&lt;h2&gt;Message sent successfully!&lt;/h2&gt;\n</code></pre> urls.py<pre><code># myproject/urls.py\nfrom django.urls import path\nfrom django.conf import settings\nfrom django.conf.urls.static import static\nfrom contact.views import ContactFormView, ContactSuccessView\n\nurlpatterns = [\n    path('contact/', ContactFormView.as_view(), name='contact'),\n    path('contact/success/', ContactSuccessView.as_view(), name='contact_success'),\n] + static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)\n</code></pre> <p>Success</p> <p>To implement the contact section in the Django admin dashboard, you need to register the <code>ContactMessage</code> model with the admin site. Here's how you can do it:</p> <pre><code>from django.contrib import admin\nfrom .models import ContactMessage\n\n@admin.register(ContactMessage)\nclass ContactMessageAdmin(admin.ModelAdmin):\n    list_display = ('name', 'email', 'message', 'timestamp')\n    search_fields = ('name', 'email', 'message')\n</code></pre> <p>In this code:</p> <ul> <li>@admin.register(ContactMessage) is a decorator that registers the <code>ContactMessage</code> model with the admin site.</li> <li><code>ContactMessageAdmin</code> is a class that inherits from <code>admin.ModelAdmin</code>, allowing you to customize the appearance and behavior of the model in the admin interface.</li> <li><code>list_display</code> specifies which fields should be displayed in the list view of contact messages in the admin interface.</li> <li><code>search_fields</code> specifies the fields by which the contact messages can be searched in the admin interface.</li> </ul> <p>With this setup, you can now access and manage contact form submissions in the Django admin dashboard. When you run your Django server and navigate to the admin site (<code>/admin</code> by default), you should see the Contact Messages section where you can view, search, and manage contact form submissions.</p>"},{"location":"backend/django/django-form/#other-topic","title":"Other Topic","text":"Registering a Model with the Django Admin Interface <p>Both admin.site.register(ContactMessage) and @admin.register(ContactMessage) are used to register a model with the Django admin interface, but they differ in syntax and usage style. Here's a breakdown of each:</p> 1. Old Approach2. Decorator Approachdecorator <p>1. admin.site.register(ContactMessage):</p> <p>This method is the traditional way of registering models with the Django admin interface. It's used by directly accessing the <code>site</code> attribute of the <code>admin</code> module. This method is still perfectly valid and widely used, especially in older Django projects or when registering multiple models.</p> python<pre><code>from django.contrib import admin\nfrom .models import ContactMessage\n\nadmin.site.register(ContactMessage)\n</code></pre> <p>2. @admin.register(ContactMessage):</p> <p>This method is a decorator-based approach introduced in Django 1.7. It provides a more convenient and readable way to register models with the admin interface. It's generally preferred for its clarity and brevity, especially for registering a single model.</p> python<pre><code>from django.contrib import admin\nfrom .models import ContactMessage\n\n@admin.register(ContactMessage)\nclass ContactMessageAdmin(admin.ModelAdmin):\n    # Customization for the admin interface\n    pass\n</code></pre> <ul> <li>@admin.register(ModelName)</li> <li>@admin.display()</li> <li>@admin.action()</li> <li>@admin.fieldsets()</li> </ul> <p>Both methods achieve the same result of registering the <code>ContactMessage</code> model with the admin interface. The choice between them often comes down to personal preference, team conventions, and the complexity of your project.</p> <p>For simple cases, where you're just registering a model without any additional customization, the @admin.register() decorator provides a concise and clear syntax. However, if you have more complex customization needs or if you're registering multiple models, using admin.site.register() might be more appropriate.</p> <p>To disable or hide the add button in admin dashboard</p> python<pre><code>from django.contrib import admin\nfrom .models import ContactMessage\n\nclass ContactMessageAdmin(admin.ModelAdmin):\n    # Customize the admin interface for ContactMessage model\n    def has_add_permission(self, request):\n        # Disable the ability to add new contacts\n        return False\n\n# Register the ContactMessage model with the customized admin interface\nadmin.site.register(ContactMessage, ContactMessageAdmin)\n</code></pre> <p>This approach ensures that users cannot add new contacts via the admin interface while still allowing them to view and manage existing contact entries. Adjust the code as needed to fit your specific requirements and project structure.</p> <p>{{ form.as_p }}</p> BasicIntermediateAdvanced <pre><code>&lt;form method=\"post\"&gt;\n    {% csrf_token %}\n    {{ form.as_p }}\n    &lt;button type=\"submit\"&gt;Submit&lt;/button&gt;\n&lt;/form&gt;\n</code></pre> <p>In Django templates, {{ form.as_p }} is a shortcut for rendering each form field as a paragraph (</p><p> element). Each form field label and input element pair will be wrapped in a </p><p> tag. This is a simple way to render a form in HTML.</p> <p>If you want to use Bootstrap for styling your form, you can integrate Bootstrap classes directly into your template. Here's how you can modify your template to use Bootstrap classes for layout:</p> <pre><code>&lt;div class=\"col-md-12\"&gt;\n    &lt;h5&gt;Contact&lt;/h5&gt;\n    &lt;form method=\"post\" class=\"form\"&gt;\n        {% csrf_token %}\n        &lt;div class=\"form-group\"&gt;\n            {{ form.name.label_tag }}\n            {{ form.name }}\n        &lt;/div&gt;\n        &lt;div class=\"form-group\"&gt;\n            {{ form.email.label_tag }}\n            {{ form.email }}\n        &lt;/div&gt;\n        &lt;div class=\"form-group\"&gt;\n            {{ form.message.label_tag }}\n            {{ form.message }}\n        &lt;/div&gt;\n        &lt;button type=\"submit\" class=\"btn btn-primary\"&gt;Submit&lt;/button&gt;\n    &lt;/form&gt;\n&lt;/div&gt;\n</code></pre> <p>In this modified template:</p> <ul> <li>Each form field is wrapped in a  element with the class <code>form-group</code>, which is a Bootstrap class used for styling form elements. <li>The form label (<code>{{ form.field.label_tag }}</code>) and input element (<code>{{ form.field }}</code>) are placed within the same form-group div.</li> <li>The submit button is styled using Bootstrap's <code>btn</code> and <code>btn-primary</code> classes to make it a Bootstrap-styled button.</li> <p>This layout adheres to Bootstrap's styling conventions and ensures that your form is styled consistently with the rest of your Bootstrap-based website. Adjust the classes and styling as needed to fit your specific design requirements.</p> <pre><code>&lt;form method=\"post\"&gt;\n    {% csrf_token %}\n\n    &lt;div class=\"mb-3\"&gt;\n        {{ form.name.label_tag }}\n        &lt;input type=\"{{ form.name.field.widget.input_type }}\" name=\"{{ form.name.html_name }}\" id=\"{{ form.name.id_for_label }}\" class=\"form-control\"&gt;\n    &lt;/div&gt;\n    &lt;div class=\"mb-3\"&gt;\n        {{ form.email.label_tag }}\n        &lt;input type=\"{{ form.email.field.widget.input_type }}\" name=\"{{ form.email.html_name }}\" id=\"{{ form.email.id_for_label }}\" class=\"form-control\"&gt;\n    &lt;/div&gt;\n    &lt;div class=\"mb-3\"&gt;\n        {{ form.message.label_tag }}\n        &lt;textarea name=\"{{ form.message.html_name }}\" id=\"{{ form.message.id_for_label }}\" class=\"form-control\"&gt;&lt;/textarea&gt;\n    &lt;/div&gt;\n    &lt;button type=\"submit\" class=\"btn btn-primary\"&gt;Submit&lt;/button&gt;\n&lt;/form&gt;\n</code></pre> </li></ul> <p>Danger</p> <p>Q: Can't save a form in Django (object has no attribute 'save')</p> <p>A: save is available only for <code>ModelForm</code> by default, not for <code>forms.Form</code></p> <p>Example</p> htmlContactForm classform_class <pre><code>&lt;!-- Render the contact form --&gt;\n&lt;form method=\"post\"&gt;\n    {% csrf_token %}\n    {{ form.as_p }}\n    &lt;button type=\"submit\"&gt;Submit&lt;/button&gt;\n&lt;/form&gt;\n</code></pre> views.py<pre><code>from django.views.generic import TemplateView\nfrom .forms import ContactForm\n\nclass ContactIndexView(TemplateView):\n    template_name = 'index.html'\n\n    def get_context_data(self, **kwargs):\n        context = super().get_context_data(**kwargs)\n        # Include an instance of your form in the context\n        context['form'] = ContactForm()\n        return context\n</code></pre> views.py<pre><code>from django.views.generic import TemplateView\nfrom .forms import ContactForm\n\nclass ContactIndexView(TemplateView):\n    template_name = 'index.html'\n    # Add this line to reference the form class\n    form_class = ContactForm\n\n    def get_context_data(self, **kwargs):\n        context = super().get_context_data(**kwargs)\n\n        # Include an instance of your form in the context\n        context['form'] = self.form_class()\n\n        return context\n</code></pre> <p><code>TemplateView</code> and <code>FormView</code></p> <p>TemplateView and FormView are both <code>class-based views</code> provided by Django, but they serve different purposes.</p> <p>TemplateView:</p> <ul> <li>TemplateView is used when you want to display a template without any form processing involved.</li> <li>It's typically used for rendering static content or content that doesn't require any data processing or form submissions.</li> <li>It doesn't handle form submissions or provide methods for processing form data.</li> <li>You can use TemplateView to render templates and pass context data to the template, but it doesn't include any form handling logic.</li> </ul> <p>FormView:</p> <ul> <li>FormView is used when you want to display a form, process submitted form data, and handle form validation.</li> <li>It's designed to handle form submissions, validate form data, and perform actions based on the form submission, such as saving data to a database.</li> <li>It provides built-in methods for handling form submission (<code>form_valid()</code> and <code>form_invalid()</code>), which allow you to define custom logic for what happens when the form is submitted successfully or contains errors.</li> <li>FormView typically works with Django forms (<code>django.forms.Form</code> or <code>django.forms.ModelForm</code>) and is suitable for scenarios where you need to handle form submissions and perform form validation.</li> </ul> <p>In your case, if the form is displaying correctly with FormView but not with <code>TemplateView</code>, it suggests that there might be an issue with how you're setting up the TemplateView or how you're including the form in the template. Make sure that the ContactForm instance is correctly included in the context of the <code>TemplateView</code> and that the template is rendering the form properly. If the form is not displaying with <code>TemplateView</code>, it might indicate that the form instance is not being passed to the template context correctly or that there might be an issue with the template rendering logic.</p> Mixins Approach 1Approach 2 <p>To display the <code>ContactFormView</code> form in both <code>contacts/contact.html</code> and <code>index.html</code>, you have a couple of options. One common approach is to reuse the same view class (<code>ContactFormView</code>) for both URLs, but specify different template names for each URL pattern. Here's how you can achieve this:</p> viewurlscontacts/contact.htmlindex html views.py<pre><code>from django.urls import reverse_lazy\nfrom django.views.generic import FormView\nfrom .forms import ContactForm\nfrom .models import ContactMessage\n\nclass ContactFormView(FormView):\n    template_name = 'contacts/contact.html'\n    form_class = ContactForm\n    success_url = reverse_lazy('contact_success')\n\n    def form_valid(self, form):\n        name = form.cleaned_data['name']\n        email = form.cleaned_data['email']\n        message = form.cleaned_data['message']\n\n        # Create and save ContactMessage instance\n        contact_message = ContactMessage.objects.create(name=name, email=email, message=message)\n\n        self.request.session.pop('form_data', None)\n\n        return super().form_valid(form)\n</code></pre> urls.py<pre><code>from django.urls import path\nfrom .views import ContactFormView\n\nurlpatterns = [\n    path('contact/', ContactFormView.as_view(), name='contact'),\n    path('', ContactFormView.as_view(template_name='index.html'), name='index'),\n]\n</code></pre> contact.html<pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;title&gt;Contact Form&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;h1&gt;Contact Form&lt;/h1&gt;\n    &lt;form method=\"post\"&gt;\n        {% csrf_token %}\n        {{ form.as_p }}\n        &lt;button type=\"submit\"&gt;Submit&lt;/button&gt;\n    &lt;/form&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre> index.html<pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;title&gt;Index&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;h1&gt;Index Page&lt;/h1&gt;\n    &lt;p&gt;This is the index page.&lt;/p&gt;\n\n    &lt;!-- Include the same contact form here --&gt;\n    &lt;form method=\"post\"&gt;\n        {% csrf_token %}\n        {{ form.as_p }}\n        &lt;button type=\"submit\"&gt;Submit&lt;/button&gt;\n    &lt;/form&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <p>Another approach to displaying the same form in multiple templates while keeping your views DRY (Don't Repeat Yourself) is by using a mixin. Mixins allow you to share common functionality among different views.</p> viewsurl views.py<pre><code>from django.views.generic.edit import FormMixin\nfrom .forms import ContactForm\n\nfrom django.urls import reverse_lazy\nfrom django.views.generic import TemplateView\nfrom .models import ContactMessage\n\nclass ContactFormMixin(FormMixin):\n    form_class = ContactForm\n    success_url = reverse_lazy('contact_success')\n    template_name = 'contacts/contact.html'\n\n    def form_valid(self, form):\n        name = form.cleaned_data['name']\n        email = form.cleaned_data['email']\n        message = form.cleaned_data['message']\n\n        # Create and save ContactMessage instance\n        contact_message = ContactMessage.objects.create(name=name, email=email, message=message)\n\n        self.request.session.pop('form_data', None)\n\n        return super().form_valid(form)\n\nclass ContactFormView(ContactFormMixin, FormView):\n    pass\n\nclass ContactSuccessView(TemplateView):\n    template_name = 'contacts/contact_success.html'\n\nclass IndexView(ContactFormMixin, TemplateView):\n    template_name = 'index.html'\n</code></pre> urls.py<pre><code>from django.urls import path\nfrom .views import ContactFormView, ContactSuccessView, IndexView\n\nurlpatterns = [\n    path('', IndexView.as_view(), name='index'),\n    path('contact/', ContactFormView.as_view(), name='contact'),\n    path('contact/success/', ContactSuccessView.as_view(), name='contact_success'),\n]\n</code></pre> <p>project <code>vs</code> apps <code>guidelines</code></p> <p>Defining URL patterns in Django involves organizing them in a structured manner, both at the project level and the app level. Here are some guidelines and best practices for managing project URLs and app URLs:</p> Project URLs:App URLs: <p>1. Use <code>include()</code> for App URLs: Use Django's <code>include()</code> function to include URLs from individual apps in your project's <code>urls.py</code>. This keeps the project URLs modular and allows you to organize them by functionality.</p> python<pre><code>from django.urls import path, include\n\nurlpatterns = [\n    path('admin/', admin.site.urls),\n    path('myapp/', include('myapp.urls')),\n    # Other app URLs included here\n]\n</code></pre> <p>2.Prefix App URLs: Prefix URLs for each app with a common path to avoid conflicts and provide clarity. For example, if you have an app for managing contacts, prefix its URLs with <code>contacts/</code>.</p> <p>1. Use Namespaced URLs: Use namespaced URLs within your app to avoid conflicts with other apps. Define a unique app_name in your app's <code>urls.py</code> and use it to namespace your URLs.</p> urls.py<pre><code>app_name = 'myapp'\n\nurlpatterns = [\n    path('some-url/', views.some_view, name='some_view'),\n    # Other URLs...\n]\n</code></pre> <p>2. Group URLs by Functionality: Organize URLs within your app's <code>urls.py</code> based on their functionality or resource. For example, group all user-related URLs together, all product-related URLs together, etc.</p> <p>3. Use Class-based Views: Prefer using <code>class-based views</code> over <code>function-based views</code> as they provide better code organization and reuse. Use as_view() to convert class-based views to callable views in your URL patterns.</p> <p>General Tips:</p> <ul> <li> <p>Comments and Documentation: Add comments and documentation to your URLs to explain their purpose, especially if the project is complex or involves multiple developers.</p> </li> <li> <p>Consistency: Maintain consistency in URL naming conventions, URL structure, and URL organization across your project. Consistency makes it easier to understand and navigate the codebase.</p> </li> <li> <p>Avoid Hardcoding URLs: Use Django's <code>reverse()</code> or <code>reverse_lazy()</code> functions to reverse-resolve URLs instead of hardcoding them. This makes your code more robust and easier to maintain if URLs change in the future.</p> </li> <li> <p>Keep URLs Concise and Descriptive: Use concise yet descriptive URLs that clearly convey the purpose of the resource or view being accessed.</p> </li> </ul> <p>By following these guidelines and best practices, you can effectively manage and organize your project URLs, making your codebase more maintainable and understandable.</p> What is Namespace URLS in <code>django</code> apps <p>Namespaced URLs in Django allow you to organize URLs within your app and avoid conflicts with URLs from other apps. Here's what it means and how to use it:</p> <p>What are Namespaced URLs?</p> <p>In Django, a namespace is a way to group a set of URL patterns under a common name. This is particularly useful when you have multiple apps in your project, each with its own set of URL patterns. By namespacing the URLs, you can ensure that URLs from different apps don't clash with each other. How to Use Namespaced URLs?</p> <p>To use namespaced URLs, you need to follow these steps:</p> <p>1. Define an app_name in <code>urls.py</code>: In your app's <code>urls.py</code> file, define an <code>app_name</code> variable to specify the namespace for the URLs in that app.</p> python<pre><code>app_name = 'myapp'\n</code></pre> <p>2. Specify Namespaced URLs: When defining URL patterns in your app's <code>urls.py</code>, use the <code>app_name</code> specified earlier as the namespace for the URLs.</p> python<pre><code>from django.urls import path\nfrom . import views\n\napp_name = 'myapp'\n\nurlpatterns = [\n    path('some-url/', views.some_view, name='some_view'),\n    # Other URLs...\n]\n</code></pre> <p>3. Referencing Namespaced URLs: When referencing URLs in templates or views, use the <code>{% url %}</code> template tag or <code>reverse()</code> function, specifying the namespace along with the URL name.</p> <ul> <li>Using the <code>{% url %}</code> template tag:</li> </ul> html<pre><code>&lt;a href=\"{% url 'myapp:some_view' %}\"&gt;Some View&lt;/a&gt;\n</code></pre> <ul> <li>Using the <code>reverse()</code> function in views:</li> </ul> python<pre><code>from django.urls import reverse\n\nurl = reverse('myapp:some_view')\n</code></pre> <p>When to Use Namespaced URLs?</p> <p>Namespaced URLs are particularly useful when:</p> <ul> <li>You have multiple apps in your Django project.</li> <li>Your project structure involves reusable apps that can be used in different projects.</li> <li>You want to organize URLs within each app and avoid conflicts between URL names.</li> </ul> <p>Namespaced URLs help keep your codebase organized, maintainable, and less error-prone, especially in larger projects with multiple apps. They also provide a clear and concise way to reference URLs within templates and views.</p> <p>Warning</p> <pre><code>from django.shortcuts import redirect\n\nclass IndexView(TemplateView):\n    template_name = 'index.html'\n\n    def get_context_data(self, **kwargs):\n        context = super().get_context_data(**kwargs)\n        context['form'] = ContactForm()\n        return context\n\n    def post(self, request, *args, **kwargs):\n        form = ContactForm(request.POST)\n        if form.is_valid():\n            name = form.cleaned_data['name']\n            email = form.cleaned_data['email']\n            message = form.cleaned_data['message']\n            contact_message = ContactMessage.objects.create(name=name, email=email, message=message)\n            # Redirect to contact success URL\n            return redirect('contact_success')\n        return render(request, self.template_name, {'form': form})\n</code></pre> <p>Bugs</p> <p>In the ContactIndexView, context['form'] = ContactForm() and context['contact_messages'] = ContactMessage.objects.all() are two separate lines that serve different purposes:</p> <ul> <li> <p>context['form'] = ContactForm(): This line creates an instance of the ContactForm class and assigns it to the key <code>form</code> in the context dictionary. This form instance will be used in the template to render the contact form.</p> </li> <li> <p>context['contact_messages'] = ContactMessage.objects.all(): This line fetches all instances of the ContactMessage model using <code>ContactMessage.objects.all()</code> and assigns them to the key <code>contact_messages</code> in the context dictionary. These contact messages will be used in the template to display the existing messages.</p> </li> </ul> <p>In summary:</p> <p><code>context['form']</code> is used to pass a form instance to the template for rendering the form.</p> <p><code>context['contact_messages']</code> is used to pass a queryset of ContactMessage instances to the template for displaying existing messages.</p> <p>Both are important for rendering the complete view in the template: the form for users to submit new messages and the existing messages for users to view.</p> <p>Danger</p> <p>Whether to use the model or the form in the context depends on what you want to achieve in your view and template.</p> <p>Here's a breakdown:</p> <p>1. Model (ContactMessage.objects.all()):</p> <ul> <li>If you want to display existing contact messages in your template, you would typically use the model queryset (ContactMessage.objects.all()). This allows you to access all instances of the <code>ContactMessage model</code> from your database.</li> <li>You would use the model queryset to iterate over existing messages and display them in your template.</li> </ul> <p>2.Form (ContactForm()):</p> <ul> <li>If you want to include a form in your template for users to submit new contact messages, you would use the form instance (<code>ContactForm()</code>).</li> <li>You would use the form instance to render the form fields in your template and handle user input (<code>submission</code>) when the form is submitted.</li> </ul> <p>In most cases, you would want to include both the model queryset and the form in your context:</p> <ul> <li>Use the model queryset to display existing messages.</li> <li>Use the form instance to render the form for users to submit new messages.</li> </ul> <p>This allows your template to provide both functionalities: displaying existing messages and enabling users to submit new messages.</p> <p>Here's how you might include both in your view:</p> <pre><code>class ContactIndexView(TemplateView):\ntemplate_name = 'index.html'\n\ndef get_context_data(self, **kwargs):\n    context = super().get_context_data(**kwargs)\n    context['form'] = ContactForm()  # Form for user submission\n    context['contact_messages'] = ContactMessage.objects.all()  # Existing messages\n    return context\n</code></pre> <p>And in your template, you would use <code>{{ form }}</code> to render the form fields and iterate over <code>{{ contact_messages }}</code> to display existing messages.</p>"},{"location":"backend/django/django-form/#reference","title":"Reference","text":""},{"location":"backend/django/django-mail/","title":"django mail","text":""},{"location":"backend/django/django-mail/#django-email-configuration","title":"Django Email Configuration","text":"<p>Django is a Python-based web framework that allows more control for sending emails using functions and expressions.</p> settings.py<pre><code>EMAIL_BACKEND = 'django.core.mail.backends.smtp.EmailBackend'\nEMAIL_HOST = 'smtp.gmail.com'\nEMAIL_USE_TLS = True\nEMAIL_PORT = 587\nEMAIL_HOST_USER = #sender's email-id\nEMAIL_HOST_PASSWORD = #password associated with above email-id\n</code></pre>"},{"location":"backend/django/django-mail/#less-secure-apps-gmail","title":"Less Secure apps gmail","text":"<ol> <li>Go to myaccount.google.com</li> <li>Go to security, ande enable 2FA</li> <li>If the App Password is not shown inside the 2FA, then</li> <li>Search App Password in the search bar</li> <li>Select the App Password and created a new app password.</li> <li>Finally you can see the App Password visible inside the Security.</li> </ol>"},{"location":"backend/django/django-mail/#reference","title":"Reference","text":"<ul> <li>setup-sending-email-in-django-project</li> <li>creating-google-app-password-for-django-project</li> </ul>"},{"location":"backend/django/django-middleware/","title":"django middleware","text":"<p>Middleware is a framework of hooks into Django\u2019s request/response processing. It\u2019s a light, low-level \u201cplugin\u201d system for globally altering Django\u2019s input or output.</p> Note"},{"location":"backend/django/django-middleware/#a-primer-on-middlewares","title":"A Primer on Middlewares","text":"<p>Middlewares are one of the core concepts of Django. Just like ogres and onions, Django also has layers that your request and response goes through when they enter and exit your application. The centerpiece of this layered system is the view function and the class based view itself. Consider Figure 2-6.</p> <p></p> <p>Here you can see that when a request comes into your application, it enters the various middleware layers that can do plenty of things with them. A couple of examples for middlewares:</p>"},{"location":"backend/django/django-middleware/#authenticationmiddleware","title":"AuthenticationMiddleware:","text":"<p>Ensures that the request.user object exists and you can access it. If the user is logged in then it will be populated with the user object. If not, then an anonymous user will be sitting on this attribute. Oftentimes it is sery convenient to subclass this middleware and extend it with other user related data, such as from the UserProfile which we mentioned earlier.</p>"},{"location":"backend/django/django-middleware/#securitymiddleware","title":"SecurityMiddleware:","text":"<p>Provides various security related features, such as HTTPS redirects, redirect blocking, xss protection.</p>"},{"location":"backend/django/django-middleware/#commonmiddleware","title":"CommonMiddleware:","text":"<p>Provides some basic functionalities that are chores to implement. Such as sending away banned user-agents and making sure that the URL ends with a slash.</p> <p>As you can see, middlewares have a wide variety of uses, be cautious with what you put in the codebase of a middleware, though. Since all requests in your service will enter that middleware, computation intensive and network operations might slow down your application significantly.</p>"},{"location":"backend/django/django-middleware/#redirect-authenticated-users","title":"Redirect Authenticated Users","text":"<p>Yes, it is generally a good practice to redirect users away from the login and signup pages if they are already authenticated (logged in). This practice ensures a better user experience and aligns with common usability patterns across web applications.</p>"},{"location":"backend/django/django-middleware/#reasons-to-redirect-authenticated-users","title":"Reasons to Redirect Authenticated Users:","text":"<ul> <li> <p>Avoid Confusion: Users who are already logged in might be confused if they land on a login or signup page again. They might wonder if they've been logged out or if there's a problem with their session.</p> </li> <li> <p>Security: Prevents authenticated users from performing unnecessary actions that don't apply to them, such as attempting to log in again or sign up for a new account.</p> </li> <li> <p>Simplifies Navigation: Keeps navigation straightforward by presenting relevant options based on the user's current authentication status. For example, redirecting them to a dashboard, profile page, or the main application interface.</p> </li> </ul>"},{"location":"backend/django/django-middleware/#how-to-implement-redirects-in-django","title":"How to Implement Redirects in Django:","text":"<p>In Django, you can handle redirection in several ways:</p> <p>Tip</p> Middleware Approach (Recommended):Views Approach: <p>Create a middleware to redirect authenticated users away from the login and signup pages.</p> middleware.py<pre><code>from django.conf import settings\nfrom django.shortcuts import redirect\nfrom django.urls import reverse\n\nclass RedirectIfAuthenticatedMiddleware:\n    def __init__(self, get_response):\n        self.get_response = get_response\n\n    def __call__(self, request):\n        if request.user.is_authenticated:\n            if request.path in [reverse('login'), reverse('signup')]:\n                return redirect(settings.LOGIN_REDIRECT_URL)  # Redirect to desired URL after login\n        response = self.get_response(request)\n        return response\n</code></pre> <p>Ensure to include this middleware in your Django settings:</p> settings.py<pre><code>MIDDLEWARE = [\n    # Other middleware...\n    'yourapp.middleware.RedirectIfAuthenticatedMiddleware',\n    # Other middleware...\n]\n</code></pre> views.py<pre><code>from django.shortcuts import redirect\nfrom django.urls import reverse\n\ndef login_view(request):\n    if request.user.is_authenticated:\n        return redirect(reverse('home'))  # Replace 'home' with your desired redirect URL\n    # Handle login logic...\n\ndef signup_view(request):\n    if request.user.is_authenticated:\n        return redirect(reverse('home'))  # Replace 'home' with your desired redirect URL\n    # Handle signup logic...\n</code></pre> <p>Summary:</p> <ul> <li>Middleware: Recommended for global rules and ensuring consistency across the application. Suitable for enforcing authentication-related policies universally.</li> <li>Views: Provide flexibility and granularity for specific redirection logic within individual views. Useful for scenarios where different views require unique handling based on context.</li> </ul> <p>Breakdown</p> <ol> <li> <p>Constructor (<code>__init__</code> method):</p> <ul> <li>get_response: This parameter is a function that will be called with the request to get the response. It's used to handle the request further down the middleware chain or to the view.</li> </ul> </li> <li> <p><code>__call__</code> method:</p> <ul> <li>This method allows the class instance to be callable like a function, making it a middleware. It takes <code>request</code> as an argument.</li> </ul> </li> <li> <p>Logic Explanation:</p> <ul> <li>Authenticated Check: if request.user.is_authenticated: checks if the user is logged in.</li> <li>Path Check: if request.path in [reverse('login'), reverse('signup')] checks if the current request path is either the login or signup page.</li> <li>Redirect: If both conditions are met (user is authenticated and the path is <code>login/signup</code>), <code>redirect(settings.LOGIN_REDIRECT_URL)</code> redirects the user to the URL specified in <code>settings.LOGIN_REDIRECT_URL</code>.</li> <li>Pass-through: If the user is not authenticated or is visiting a different path, self.get_response(request) allows the request to continue through the middleware chain and eventually to the view.</li> </ul> </li> </ol> <p>Package-Level Initialization</p> <p><code>__init__.py</code> indicates that the directory should be treated as a package. </p> ExamplePackage Versioning and Metadata <pre><code># mypackage/__init__.py\nfrom .module1 import ClassA\nfrom .module2 import function_b\n</code></pre> <p>This allows users to do:</p> <pre><code>from mypackage import ClassA, function_b\n</code></pre> <p>instead of:</p> <pre><code>from mypackage.module1 import ClassA\nfrom mypackage.module2 import function_b\n</code></pre> <p><code>__init__.py</code> can be used to store package metadata, such as version information. For example:</p> <pre><code># mypackage/__init__.py\n__version__ = \"1.0.0\"\n__author__ = \"Your Name\"\n</code></pre>"},{"location":"backend/django/django-middleware/#separate-logout-urls-for-admin-and-user-accounts","title":"Separate Logout URLs for Admin and User Accounts","text":"<p>Abstract</p> <ol> <li> <p>Admin Logout</p> <p>For the Django admin interface, the logout behavior is handled internally by Django's admin site. By default, the admin logout URL is <code>/admin/logout/</code>. You typically don't need to customize this unless you have specific requirements.</p> </li> <li> <p>User Accounts Logout</p> <p>For user accounts, you can define a separate logout URL (<code>/accounts/logout/</code>) and implement custom logout views for additional functionalities or redirects.</p> </li> </ol> Implementation Steps <ol> <li> <p>Define Admin Logout URL</p> <p>Django admin handles admin logout internally. Users are redirected to <code>/admin/logout/</code> by default. You generally do not need to modify this behavior unless you have specific requirements.</p> </li> <li> <p>Define User Accounts Logout URL</p> <p>Define a custom URL pattern for user logout (<code>/accounts/logout/</code>) in your Django project's urls.py:</p> myproject/urls.py<pre><code>from django.urls import path\nfrom django.contrib.auth import views as auth_views\n\nurlpatterns = [\n    # Admin URLs\n    path('admin/', admin.site.urls),\n\n    # User Accounts URLs\n    path('accounts/logout/', auth_views.LogoutView.as_view(), name='logout'),\n    path('accounts/profile/', ProfileView.as_view(), name='profile'),\n    path('accounts/signup/', SignupView.as_view(), name='signup'),\n    path('accounts/', include('django.contrib.auth.urls')),\n\n    # other app URLs\n]\n</code></pre> <ul> <li>Use LogoutView.as_view() provided by Django's authentication views (<code>django.contrib.auth.views</code>) to handle user logout. This view takes care of logging the user out and can also handle custom redirects or actions if needed.</li> </ul> </li> <li> <p>Customize User Logout Behavior (Optional)</p> <p>If you need to customize the logout behavior for user accounts (e.g., redirecting to a specific page after logout), you can subclass LogoutView and override its behavior:</p> views.py<pre><code>from django.contrib.auth.views import LogoutView\nfrom django.urls import reverse_lazy\nfrom django.shortcuts import redirect\n\nclass CustomLogoutView(LogoutView):\n    def get_next_page(self):\n        # Customize the redirect URL after logout\n        return reverse_lazy('home')  # Example: Redirect to home page after logout\n</code></pre> <p>Then, use <code>CustomLogoutView.as_view()</code> in your URL configuration:</p> urls.py<pre><code>path('accounts/logout/', CustomLogoutView.as_view(), name='logout'),\n</code></pre> </li> <li> <p>Update LOGOUT_REDIRECT_URL Setting</p> <p>In your Django project's <code>settings.py</code>, specify where users should be redirected after logging out from user accounts:</p> settings.py<pre><code>LOGOUT_REDIRECT_URL = '/accounts/login/'  # Example: Redirect to login page after logout\n</code></pre> </li> </ol> <p>Abstract</p>"},{"location":"backend/django/django-middleware/#benefits-of-separate-logout-urls","title":"Benefits of Separate Logout URLs","text":"<ul> <li> <p>Role-Based Navigation: Provides a clear distinction between logout actions for admin users and regular users, aligning with their respective roles and permissions.</p> </li> <li> <p>Customization Flexibility: Allows customization of logout behavior and redirects based on specific user roles or application requirements.</p> </li> <li> <p>Security and User Experience: Enhances security by ensuring users are redirected appropriately after logging out, improving overall user experience and system usability.</p> </li> </ul> <p>By following these practices, you can effectively manage and customize logout functionalities for admin users and regular users in your Django application, ensuring a clear and intuitive user experience tailored to different user roles.</p>"},{"location":"backend/django/django-middleware/#reference","title":"Reference","text":"<ul> <li>Django Middleware</li> <li>Designing Microservices with Django by Akos Hochrein</li> </ul>"},{"location":"backend/django/django-model/","title":"django model (orm)","text":""},{"location":"backend/django/django-model/#models-relations-inheritance","title":"Models, Relations, &amp; Inheritance","text":""},{"location":"backend/django/django-model/#django-models","title":"Django Models","text":"<p>In Django, the model is the object mapped to the database.</p> picture <p></p> <p><code>Book</code> : Mastering Django by Nigel George - 2022</p> Supported Databases <p><code>Django 3.0</code> and higher officially supports five databases:</p> <ul> <li>PostgreSQL</li> <li>MySQL</li> <li>SQLite</li> <li>Oracle</li> <li>MariaDB</li> </ul> <p>There are also several third-party applications available if you need to connect to an unofficially supported database.</p>"},{"location":"backend/django/django-model/#model","title":"Model","text":""},{"location":"backend/django/django-model/#working-with-model-field-relationships","title":"Working with model field relationships","text":"<p>Django provides three relationship types for linking tables:</p> <ul> <li>Many\u2013to\u2013one</li> <li>Many\u2013to\u2013many</li> <li>One\u2013to\u2013one</li> </ul> <p>A <code>many-to-one</code> relationship is defined by using a <code>ForeignKey</code> field, and the other two relationship types are defined using the self-explanatory <code>ManyToManyField</code> and <code>OneToOneField</code>. These fields are named appropriately after the relationship type that they represent.</p> <p>The three field types \u2014 <code>ForeignKey</code>, <code>ManyToManyField</code>, and <code>OneToOneField</code>.</p> ForeignKeyForeignKeyManyToManyField <pre><code># /becoming_a_django_entdev/chapter_3/models.py\n...\nclass Vehicle(models.Model):\n    ...\n    vehicle_model = models.ForeignKey(\n        VehicleModel,\n        on_delete = models.CASCADE,\n        verbose_name = 'Model',\n        related_name = 'model_vehicle',\n        blank = True,\n        null = True,\n    )\n    engine = models.ForeignKey(\n        Engine,\n        on_delete = models.CASCADE,\n        verbose_name = 'Engine',\n        related_name = 'engine_vehicle',\n        blank = True,\n        null = True,\n    )\n</code></pre> <pre><code># /becoming_a_django_entdev/chapter_3/models.py\n...\nclass Engine(models.Model):\n    ...\n    vehicle_model = models.ForeignKey(\n        VehicleModel,\n        on_delete = models.CASCADE,\n        verbose_name = 'Model',\n        related_name = 'model_engine',\n        blank = True,\n        null = True,\n    )\n</code></pre> <pre><code># /becoming_a_django_entdev/chapter_3/models.py\n...\nclass Seller(models.Model):\n    name = models.CharField(\n        verbose_name = 'Seller Name',\n        max_length = 150,\n        blank = True,\n        null = True,\n    )\n    vehicle = models.ManyToManyField(\n        Vehicle,\n        verbose_name = 'Vehicles',\n        related_name = 'vehicle_sellers',\n        related_query_name = 'vehicle_seller',\n        blank = True,\n    )\n</code></pre>"},{"location":"backend/django/django-model/#customizing-models","title":"Customizing models","text":"<p>Writing methods</p> <p>Writing a model method is similar to writing a Meta subclass, except instead of writing a class, we are now writing a function inside that class using the <code>def</code> keyword.</p> <p>The four most helpful and most used methods are defined here:</p> <ul> <li><code>def save(self, *args, **kwargs)</code></li> <li><code>def delete(self, *args, **kwargs)</code></li> <li><code>def get_absolute_url(self)</code></li> <li><code>def __str__(self)</code></li> </ul>"},{"location":"backend/django/django-model/#decorators","title":"Decorators","text":"<p>A decorator is a standard Python design pattern that allows developers to extend the functionality of an object without permanently changing the behavior of that object. The concept of decorators can be applied to virtually any class or method that exists in a project.</p> <ul> <li> <p><code>@property</code></p> <p>A @property decorator allows us to write a method to act as a regular property of a model instance, rather than act as a function. </p> </li> </ul>"},{"location":"backend/django/django-model/#extending-models","title":"Extending models","text":"<p>Extending a model is a way to write a set of fields and methods that can be shared in many different classes. This is also known as inheritance, which is a fundamental principle of the Python language, letting us write code once and reuse it over and over again. It is also a way to reuse or modify a class provided by Django itself, such as the built-in User model, which is a very common model to extend.</p>"},{"location":"backend/django/django-model/#using-the-django-shell","title":"Using the Django shell","text":""},{"location":"backend/django/django-model/#generating-a-secret_key-variable","title":"Generating a SECRET_KEY variable","text":"<p>A <code>SECRET_KEY</code> variable in Django is used as a hash to secure things, such as your <code>sessions</code>, <code>cookie storage</code>, <code>password tokenization</code>, and all other methods of cryptographic signing that act to secure your site. Instead of using an online tool to generate this key, where the transmission either to or from that source could be compromised, you could generate your own using the Django shell.</p> <pre><code>$ python3 manage.py shell\n$ from secret_key_generator import secret_key_generator\n$ print(secret_key_generator.generate())\n</code></pre>"},{"location":"backend/django/django-model/#using-the-meta-subclass","title":"Using the Meta subclass","text":"<p>Model metadata is an inner class of a model called Meta. </p> <p>It is not required and completely optional but it does make using Django much more useful when it is included in your models. Metadata provides all of the \"other\" information that is not defined in model field arguments. The settings that are defined inside this class are called meta options, and there are quite a lot to choose from.</p> <pre><code>from django.db import models\n\nclass MyModel(models.Model):\n    # Model fields here\n\n    class Meta:\n        verbose_name = \"Custom Singular Name\"\n        verbose_name_plural = \"Custom Plural Name\"\n        ordering = ['field1', '-field2']\n        unique_together = ['field1', 'field2']\n        indexes = [\n            models.Index(fields=['field1'], name='field1_idx'),\n            models.Index(fields=['field2'], name='field2_idx'),\n        ]\n        permissions = [\n            ('can_view', 'Can view records'),\n            ('can_edit', 'Can edit records'),\n        ]\n</code></pre> <p>Django <code>auto_now</code> vs <code>auto_now_add</code></p> <p>In Django, auto_now and auto_now_add are options for DateTimeField and DateField fields in models. They are used to automatically set the field to the current date and time when an object is created or updated. Here's the difference between the two:</p> <p>1. auto_now: When this option is set to <code>True</code>, the field will be updated with the current date and time every time the model's save() method is called. This means that the field will always reflect the most recent time the object was saved to the database.</p> <p>2. auto_now_add: When this option is set to <code>True</code>, the field will be set to the current date and time when the object is first created, and it will not be updated subsequently. This is useful for fields that should have a fixed creation timestamp.</p> <p>Here's an example of how they can be used in a Django model:</p> <pre><code>from django.db import models\n\nclass MyModel(models.Model):\n    created_at = models.DateTimeField(auto_now_add=True)\n    updated_at = models.DateTimeField(auto_now=True)\n    # Other fields...\n</code></pre> <p>In this example, <code>created_at</code> will be set to the current timestamp when an instance of MyModel is created, and <code>updated_at</code> will be updated with the current timestamp every time the instance is saved.</p> <p>When to use <code>auto_now</code> and <code>auto_now_add</code> depends on the specific requirements of your application:</p> <ul> <li> <p>Use auto_now_add when you want to record the time when an object was created and you don't want this field to be updated later.</p> </li> <li> <p>Use auto_now when you want to keep track of the last time an object was updated.</p> </li> </ul> <p>However, there are situations where you might not want to use these options:</p> <ul> <li> <p>Avoid using <code>auto_now</code> and <code>auto_now_add</code> if you need to manually set these fields in some cases. For example, if you're importing data and need to set specific creation or update timestamps, using these options will override your manual settings.</p> </li> <li> <p>Avoid using <code>auto_now</code> if you have cases where you want to update other fields without updating the timestamp field.</p> </li> </ul> <p>In summary, <code>auto_now</code> and <code>auto_now_add</code> are useful shortcuts for handling timestamp fields in Django models, but you should consider your application's specific requirements and potential edge cases when deciding whether to use them.</p> Example of auto_now and auto_add_now <p>In a typical blog model scenario, you would want to record both the creation date of the blog post and the last modification date. For this purpose, you can use both auto_now_add and auto_now options for DateTimeField.</p> <p>Here's how you might implement it:</p> <pre><code>from django.db import models\n\nclass Blog(models.Model):\n    title = models.CharField(max_length=100)\n    content = models.TextField()\n    created_at = models.DateTimeField(auto_now_add=True)\n    updated_at = models.DateTimeField(auto_now=True)\n</code></pre> <p>In this model:</p> <ul> <li><code>created_at</code> will automatically store the date and time when the blog post is first created.</li> <li><code>updated_at</code> will automatically update to the current date and time whenever the blog post is saved.</li> </ul> <p>This setup ensures that you have both the creation date and the last modification date stored for each blog post. It's a common and efficient approach for most blog applications.</p> <p>If you only need the creation date and don't care about the last modification date, you can just use <code>auto_now_add=True</code> for the <code>created_at</code> field:</p> <pre><code>class Blog(models.Model):\n    title = models.CharField(max_length=100)\n    content = models.TextField()\n    created_at = models.DateTimeField(auto_now_add=True)\n</code></pre> <p>This simplifies the model, but you lose the ability to track when the post was last updated.</p> <p>Ultimately, the best option depends on your specific requirements. If you need both creation and modification dates, the first approach is appropriate. If you only need the creation date, you can use the simplified version.</p>"},{"location":"backend/django/django-model/#modeladmin-class","title":"ModelAdmin class","text":"<p>In Django admin, readonly_fields and fields are attributes of the ModelAdmin class that allow you to customize which fields are displayed and whether they are editable in the admin interface.</p> <p>attributes</p> <ol> <li>fields</li> <li>readonly_fields</li> <li>list_display</li> <li>ordering</li> <li>list_per_page</li> </ol> <p>Django Category</p> <p>Static choices</p> <pre><code>from django.db import models\n\nclass YourModel(models.Model):\n    CHOICES = (\n        ('option1', 'Option 1'),\n        ('option2', 'Option 2'),\n        ('option3', 'Option 3'),\n    )\n\n    your_field = models.CharField(max_length=20, choices=CHOICES)\n</code></pre>"},{"location":"backend/django/django-model/#advanced-model","title":"Advanced Model","text":"<p><code>Mastering Django by Nigel George 2022, chapter 9</code></p> <p>Django\u2019s QuerySet API provides a comprehensive array of methods and functions for working with data.</p>"},{"location":"backend/django/django-model/#methods-that-return-querysets","title":"Methods that return QuerySets","text":""},{"location":"backend/django/django-model/#methods-that-dont-return-querysets","title":"Methods that Don't return QuerySets","text":""},{"location":"backend/django/django-model/#model-managers","title":"Model Managers","text":"<p>A Manager is a Django class that provides the interface between database query operations and a Django model. Each Django model is provided with a default Manager named <code>objects</code>.</p> <p>Tips</p> <pre><code>newevent = Event.objects.get(name=\"Xmas Barbeque\")\njoneses = MyClubUser.objects.filter(last_name='Jones')\n</code></pre> <p>In each example, <code>objects</code> is the default <code>Manager</code> for the model instance.</p>"},{"location":"backend/django/django-model/#model-methods","title":"Model Methods","text":"<p>Django\u2019s Model class comes with many built-in methods. We have already used some of them \u2014 <code>save()</code>, <code>delete()</code>, <code>__str__()</code> and others. Where manager methods add table-level functionality to Django\u2019s models, model methods add row-level functions that act on individual instances of the model.</p> <p>There are two common cases where you want to play with model methods:</p> <ol> <li>When you want to add business logic to the model by adding custom model methods; and</li> <li>When you want to override the default behavior of a built-in model method.</li> </ol>"},{"location":"backend/django/django-model/#reference","title":"Reference","text":"<p>Becoming an Enterprise Django Developer by Michael Dinder (pg-122)</p> <ul> <li>Blog</li> <li>Working with Django Models in Python: Best Practices </li> <li>Best practices working with Django models in python</li> <li>Django Tips #22 Designing Better Models</li> </ul>"},{"location":"backend/django/django-reset-password/","title":"django reset password","text":""},{"location":"backend/django/django-reset-password/#django-reset-admin-password","title":"Django Reset Admin Password","text":"<p>The admin\u2019s recommended use is limited to an organization\u2019s internal management tool. It\u2019s not intended for building your entire front end around.</p>"},{"location":"backend/django/django-reset-password/#adding-a-password-reset-feature-in-django","title":"Adding a password reset feature in django","text":"<p>note</p> reset <p>You can add a password reset feature to the admin site by adding a few lines to your URLconf. Specifically, add these four patterns:</p> <pre><code>from django.contrib import admin\nfrom django.contrib.auth import views as auth_views\n\npath(\n    \"password_reset/\",\n    auth_views.PasswordResetView.as_view(\n        extra_context={\"site_header\": admin.site.site_header}\n    ),\n    name=\"admin_password_reset\",\n),\npath(\n    \"password_reset/done/\",\n    auth_views.PasswordResetDoneView.as_view(\n        extra_context={\"site_header\": admin.site.site_header}\n    ),\n    name=\"password_reset_done\",\n),\npath(\n    \"reset/&lt;uidb64&gt;/&lt;token&gt;/\",\n    auth_views.PasswordResetConfirmView.as_view(\n        extra_context={\"site_header\": admin.site.site_header}\n    ),\n    name=\"password_reset_confirm\",\n),\npath(\n    \"reset/done/\",\n    auth_views.PasswordResetCompleteView.as_view(\n        extra_context={\"site_header\": admin.site.site_header}\n    ),\n    name=\"password_reset_complete\",\n),\n</code></pre> <p>(This assumes you\u2019ve added the admin at <code>admin/</code> and requires that you put the URLs starting with <code>^admin/</code> before the line that includes the admin app itself).</p> <p>The presence of the <code>admin_password_reset</code> named URL will cause a \u201cforgotten your password?\u201d link to appear on the default admin log-in page under the password box.</p>"},{"location":"backend/django/django-reset-password/#django-hardening","title":"Django Hardening","text":"<p>To dynamically adjust the admin URL based on the <code>DEBUG</code> setting and include the password reset URLs with dynamic admin URLs, you can structure your urlpatterns as follows:</p> <p>settings.py</p> BasicAdvanced <pre><code>from django.conf import settings\nfrom django.contrib import admin\nfrom django.urls import path, include\nfrom django.contrib.auth import views as auth_views\n\nurlpatterns = []\n\n# Check if DEBUG mode is enabled\nif settings.DEBUG:\n    admin_url = 'admin/'  # Use 'admin/' in DEBUG mode\nelse:\n    admin_url = 'utd-admin/'  # Use 'utd-admin/' in production\n\n# Admin URLs\nurlpatterns += [\n    path(admin_url, admin.site.urls),\n]\n\n# Password reset URLs\nurlpatterns += [\n    path(\n        'password_reset/',\n        auth_views.PasswordResetView.as_view(\n            extra_context={\"site_header\": admin.site.site_header}\n        ),\n        name=\"admin_password_reset\",\n    ),\n    path(\n        'password_reset/done/',\n        auth_views.PasswordResetDoneView.as_view(\n            extra_context={\"site_header\": admin.site.site_header}\n        ),\n        name=\"password_reset_done\",\n    ),\n    path(\n        'reset/&lt;uidb64&gt;/&lt;token&gt;/',\n        auth_views.PasswordResetConfirmView.as_view(\n            extra_context={\"site_header\": admin.site.site_header}\n        ),\n        name=\"password_reset_confirm\",\n    ),\n    path(\n        'reset/done/',\n        auth_views.PasswordResetCompleteView.as_view(\n            extra_context={\"site_header\": admin.site.site_header}\n        ),\n        name=\"password_reset_complete\",\n    ),\n]\n\n# Include Django auth URLs if needed\n# urlpatterns += [\n#     path('accounts/', include('django.contrib.auth.urls')),\n# ]\n\n# Your other urlpatterns...\n</code></pre> <pre><code>from django.conf import settings\nfrom django.contrib import admin\nfrom django.urls import path, include, re_path\nfrom django.views.static import serve\nfrom django.contrib.auth import views as auth_views\nfrom django.conf.urls.static import static\nfrom views.home_views import HomeView\n\nurlpatterns = [\n    path('', HomeView.as_view(), name='home'),\n    path('about/', include('myapps.abouts.urls')),\n    path('fixture/', include('myapps.fixtures.urls')),\n    path('news/', include('myapps.news.urls')),\n    path('gallery/', include('myapps.galleries.urls')),\n    path('contact/', include('myapps.contacts.urls')),\n    path('tinymce/', include('tinymce.urls')),\n]\n\n# Check if DEBUG mode is enabled\nif settings.DEBUG:\n    admin_url = 'utd-admin/'  # Use 'utd-admin/' in DEBUG mode\n    urlpatterns += static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)\n    urlpatterns += [path('__debug__/', include('debug_toolbar.urls'))]\nelse:\n    admin_url = 'admin/'  # Use 'admin/' in production\n    urlpatterns += [\n        re_path(r'^static/(?P&lt;path&gt;.*)$', serve, {'document_root': settings.STATIC_ROOT}),\n        re_path(r'^media/(?P&lt;path&gt;.*)$', serve, {'document_root': settings.MEDIA_ROOT}),\n    ]\n\n# Admin URLs\nurlpatterns += [\n    path(admin_url, admin.site.urls),\n    path(\n        'password_reset/',\n        auth_views.PasswordResetView.as_view(\n            extra_context={\"site_header\": admin.site.site_header}\n        ),\n        name=\"admin_password_reset\",\n    ),\n    path(\n        'password_reset/done/',\n        auth_views.PasswordResetDoneView.as_view(\n            extra_context={\"site_header\": admin.site.site_header}\n        ),\n        name=\"password_reset_done\",\n    ),\n    path(\n        'reset/&lt;uidb64&gt;/&lt;token&gt;/',\n        auth_views.PasswordResetConfirmView.as_view(\n            extra_context={\"site_header\": admin.site.site_header}\n        ),\n        name=\"password_reset_confirm\",\n    ),\n    path(\n        'reset/done/',\n        auth_views.PasswordResetCompleteView.as_view(\n            extra_context={\"site_header\": admin.site.site_header}\n        ),\n        name=\"password_reset_complete\",\n    ),\n]\n</code></pre> <p>In this setup:</p> <ul> <li>If <code>DEBUG</code> mode is enabled, the admin URLs will be under '<code>admin/</code>'.</li> <li>If <code>DEBUG</code> mode is disabled, the admin URLs will be under '<code>utd-admin/</code>'.</li> <li>The <code>password</code> reset URLs are constructed dynamically based on the admin URL chosen.</li> </ul> <p>This setup provides flexibility in defining the admin URL based on the deployment environment while keeping the password reset URLs consistent with the chosen admin URL.</p>"},{"location":"backend/django/django-reset-password/#reference","title":"Reference","text":"<ul> <li>django reset password only in admin: stackoverflow</li> <li>password reset: django 3.2</li> <li>password reset: django 5.0</li> </ul>"},{"location":"backend/django/django-secretkey/","title":"Generate Secretkey","text":"<p>In Django, there isn't a built-in <code>secret_key_generator</code> function. The typical way to generate a secret key in Django is to use the <code>django.core.management.utils.get_random_secret_key()</code> function.</p> <p>Generate secret key for django project</p> Python<pre><code>python3 manage.py shell\n</code></pre> bash<pre><code>&gt;&gt;&gt; from  django.core.management.utils  import  get_random_secret_key\n&gt;&gt;&gt; print(get_random_secret_key())\n</code></pre> <p>This will generate a random secret key for you. You don't need to import secret_key_generator because it's not a part of Django. </p> <p>Tip</p> <p>In Django, the <code>get_random_secret_key()</code> function generates a random secret key of 50 characters in length by default. However, you can customize the length of the generated key by passing an integer argument to the function specifying the desired length. For example:</p> <pre><code>from django.core.management.utils import get_random_secret_key\n\n# Generate a random secret key of length 64\nprint(get_random_secret_key(64))\n</code></pre> <p>This will print a random secret key of 64 characters in length. You can adjust the length as needed for your application.</p>"},{"location":"backend/django/django-template/","title":"django template (view)","text":""},{"location":"backend/django/django-template/#basic","title":"Basic","text":"<p>Django Template System Basic</p> template tagtemplate variabledelimiters <p>A template tag is surrounded by {% and %}. This is because Django\u2019s tags are so flexible. Some examples performed by template tags are as follows:</p> <ol> <li>Display Logic: E.g., <code>{% if %}</code> Add <code>{% endif %}</code></li> <li>Loop Control: E.g., <code>{% for x in y %}</code>...<code>{% endfor %}</code></li> <li>Block Declaration: E.g., <code>{% block content %}</code>...<code>{% endblock %}</code></li> <li>Content Import: E.g., <code>{% include \u201cheader\u200b.ht\u200bml\u201d %}</code></li> <li>Inheritance: E.g., <code>{% extends \u201cbase\u200b.ht\u200bml\u201d %}</code></li> </ol> <p>A template variable is surrounded by {{ and }}. These template variables are passed to the template at runtime in the Context.</p> <ol> <li>Simple Variables: E.g., <code>{{ name }}</code></li> <li>Object Attributes: E.g., <code>{{ page.heading }}</code></li> <li>Dictionary Lookups: E.g., <code>{{ dict\u200b.it\u200bem }}</code></li> <li>List Indexes: E.g., <code>{{ list_items.2 }}</code></li> <li>Method Calls: E.g., <code>{{ var\u200b.low\u200ber }}</code>, <code>{{ mydict\u200b.pu\u200bsh }}</code></li> </ol> <ul> <li> <p>Display Logic - <code>{% ... %}</code> (for Statements )</p> <pre><code>&lt;h1&gt;Favorite Color&lt;/h1&gt;\n&lt;ul&gt;\n    {% for user in colors %}\n        &lt;li&gt;{{ user\u200b.col\u200bor }}&lt;/li&gt;\n    {% endfor %}\n&lt;/ul&gt;\n</code></pre> </li> <li> <p>If: </p> <p>In Jinja, it is easiest to use if as a variable that is defined and then returns some values, not empty and not false.</p> <pre><code>{% if users %}\n    &lt;ul&gt;\n        {% for user in users %}\n            &lt;li&gt;{{ user.username}}&lt;/li&gt;\n        {% endfor %}\n    &lt;/ul&gt;\n{% endif %}\n</code></pre> </li> <li> <p>If Expression:</p> <p>It is also used as an inline expression. For example, you can add this to extend your code logic.</p> <pre><code>{% extends condition if the condition is defined else 'default\u200b.ht\u200bml' %}\n</code></pre> </li> </ul> <p>Mastering Django A Beginner\u2019s Guide Edited by Sufyan bin Uzayr <code>pg-124</code> </p>"},{"location":"backend/django/django-template/#adding-templates","title":"Adding Templates","text":"<p>Adding Templates</p> <p>The first thing to learn is where to put templates in a Django project. By default, Django's template loader looks inside each app for templates that go with it.</p> <p>Now, let us create a templates folder.</p> <p><code>mkdir templates</code></p> <p>Next, we have to add the new template to the settings.py file inside the django project so that Django knows where our new templates directory is. Add the following to the TEMPLATES setting under \"DIRS.\"</p> <pre><code>TEMPLATES = [\n    {\n        ...\n        \"DIRS\": [BASE_DIR / \"templates\"],\n        ...\n    }\n]\n</code></pre> <p><code>Book</code>: Python Flask and Django by emenwa global</p> <p>Example</p> class &amp; viewsproject urlsapp urls <p>We will use the built-in TemplateView to show our template in our view. Edit the <code>views.py</code> file.</p> <pre><code>from django.views.generic import TemplateView\n\nclass HomePageView(TemplateView):\n    template_name = \"home.html\"\n</code></pre> <p>Since <code>HomePageView</code> is now a Python class, we had to capitalize it. Unlike functions, classes should always start with a capital letter. The logic for showing our template is already built into the TemplateView. All we need to do is tell it the name of the template.</p> <pre><code>from django.contrib import admin\nfrom django.urls import path\nfrom django.urls import include\n\nurlpatterns = [\n    path(\"admin/\", admin.site.urls),\n    path(\"\", include(\"page.urls\")),\n]\n</code></pre> <p>one big difference: when using Class-Based Views, you always add as view() to the end of the view name.</p> <pre><code>from django.urls import path\nfrom .views import HomePageView\n\nurlpatterns = [\n    path(\"\", HomePageView.as_view(), name=\"home\"),\n]\n</code></pre>"},{"location":"backend/django/django-template/#extending-templates","title":"Extending Templates","text":"<p>The best thing about templates is how you can extend them. Most websites have <code>headers</code> or <code>footers</code> that you see on every page. How can you do that?</p> <p>First, we make a file called base.html within the templates folder.</p> <p>Info</p> base.htmlhome.html <pre><code>&lt;header&gt;\n    &lt;a href=\"{% url 'home' %}\"&gt;Home&lt;/a&gt;\n    &lt;a href=\"{% url 'about' %}\"&gt;About&lt;/a&gt;\n&lt;/header&gt;\n\n{% block content %}\n{% endblock content %}\n</code></pre> <pre><code>{% extends \"base.html\" %}\n\n{% block content %}\n    &lt;h1&gt;Welcome to my website&lt;/h1&gt;\n{% endblock content %}\n</code></pre>"},{"location":"backend/django/django-template/#static-dir","title":"Static <code>dir</code>","text":"<pre><code>mkdir static\n\n# to create a CSS subfolder:\nmkdir static/css\n</code></pre> <pre><code># settings.py\nSTATIC_URL = \"static/\"\n\nSTATICFILES_DIRS = [BASE_DIR / \"static\"]\n</code></pre>"},{"location":"backend/django/django-template/#advanced","title":"Advanced","text":""},{"location":"backend/django/django-template/#other-topic","title":"Other Topic","text":"<p>Example</p> <p>The difference between the two declarations lies in the method used to construct the path to the <code>static</code> directory:</p> <p>1. Using the / Operator:</p> <pre><code>STATICFILES_DIRS = [\n    BASE_DIR / \"static\"\n]\n</code></pre> <p>This approach uses the <code>/</code> operator for path concatenation. However, this syntax is not standard in Python and may cause an error unless you have overridden the behavior of the <code>/</code> operator to handle path concatenation.</p> <p>2. Using os.path.join():</p> <pre><code>STATICFILES_DIRS = [\n    os.path.join(BASE_DIR, 'static')\n]\n</code></pre> <p>This approach uses the <code>os.path.join()</code> function to construct the path to the static directory. It is the standard and recommended way to join path components in Python, ensuring compatibility across different operating systems.</p> <p>In summary, the second declaration that uses <code>os.path.join(BASE_DIR, 'static')</code> is correct and standard. It ensures that the path is constructed correctly regardless of the operating system being used. The first declaration using the / operator may not work as expected and is not a common practice in Python for constructing paths.</p> static folder <p>Yes, that's correct. STATICFILES_DIRS and STATIC_ROOT serve different purposes, so they typically point to different directories.</p> <p>1. STATICFILES_DIRS:</p> <p>STATICFILES_DIRS is used during development to specify additional directories where Django should look for static files. These directories can contain static files that are not tied to specific apps or are shared across multiple apps. This setting allows you to include third-party static files, custom project-wide static files, or override static files provided by apps or libraries.</p> <p>For example:</p> <pre><code>STATICFILES_DIRS = [\n    os.path.join(BASE_DIR, 'static'),\n    #   '/path/to/external/static/files/',\n]\n</code></pre> <p>2. STATIC_ROOT:</p> <p>STATIC_ROOT is used for deployment purposes. It specifies the directory where Django collects all the static files from your project during the deployment process. These collected static files are meant to be served directly by a web server like Nginx or Apache in a production environment.</p> <p>For example:</p> <pre><code>STATIC_ROOT = os.path.join(BASE_DIR, 'staticfiles')\n</code></pre> <p>After running collectstatic, Django gathers static files from both the app-specific static directories and the additional directories specified in STATICFILES_DIRS, and places them into the directory specified by STATIC_ROOT.</p> <p>In summary, STATICFILES_DIRS and STATIC_ROOT should point to different directories. STATICFILES_DIRS is for specifying additional directories where Django should look for static files during development, while STATIC_ROOT is for specifying the directory where Django should collect all static files for deployment.</p> <p>STATIC_URL is a setting in Django used to specify the base URL from which static files will be served. It defines the URL prefix to access static files in your web application.</p> <p>By default, STATIC_URL is set to '/static/' in Django projects, but you can customize it to fit your application's requirements. For example, if you want to serve static files from a different URL or path, you can modify STATIC_URL accordingly in your project's settings.</p>"},{"location":"backend/django/django-template/#templates","title":"Templates","text":"<p>Choosing Between Direct Slug Usage and Named URL Patterns in Django Templates</p> <p>Both approaches have their advantages and use cases:</p> <p>1. <code>&lt;a href=\"{{ blog.slug }}\"&gt;{{ blog.title }}&lt;/a&gt;</code>:</p> <ul> <li>This approach directly uses the value stored in the slug field of your BlogItem model to generate the URL.</li> <li>It's simpler and more straightforward.</li> <li>You don't need to define URL patterns or use the <code>{% url %}</code> template tag.</li> <li>However, it's less flexible if you ever need to change the URL structure or if you want to handle URLs differently in different parts of your website.</li> </ul> <p>2. <code>&lt;a href=\"{% url 'blog:inner' slug=blog.slug %}\"&gt;{{ blog.title }}&lt;/a&gt;</code>:</p> <ul> <li>This approach uses the <code>{% url %}</code> template tag to generate the URL based on the specified view name (<code>'blog:inner'</code>) and the provided parameters (<code>slug=blog.slug</code>).</li> <li>It's more flexible and maintainable. If you ever need to change the URL structure or if you want to reuse the same URL pattern in different parts of your website, you only need to update the URL pattern in your urls.py file.</li> <li>It ensures consistency and helps prevent errors in URL generation.</li> <li>However, it requires you to define URL patterns in your <code>urls.py</code> file and use the <code>{% url %}</code> template tag, which adds some complexity.</li> </ul> <p>In general, if your URL structure is simple and unlikely to change, and if you don't need the flexibility provided by named URL patterns and the <code>{% url %}</code> template tag, you can use the first approach (<code>&lt;a href=\"{{ blog.slug }}\"&gt;{{ blog.title }}&lt;/a&gt;</code>). Otherwise, if you want more flexibility and maintainability, especially for larger or more complex projects, the second approach (<code>&lt;a href=\"{% url 'blog:inner' slug=blog.slug %}\"&gt;{{ blog.title }}&lt;/a&gt;</code>) is recommended.</p>"},{"location":"backend/django/django-template/#rendering-html-content","title":"Rendering HTML Content","text":"<p>To display content from a TinyMCE field in HTML, you can directly render the HTML content using the <code>safe</code> filter provided by Django templates. This filter ensures that the HTML content is rendered as HTML and not escaped as text. Here's how you can do it:</p> <pre><code>&lt;div class=\"col-md-12\"&gt;\n    &lt;p&gt;{{ about.description | safe }}&lt;/p&gt;\n&lt;/div&gt;\n</code></pre> <p>By using the <code>safe</code> filter, Django will render the HTML content stored in the <code>description</code> field without escaping it. Make sure to sanitize the HTML content before storing it in the database to prevent security vulnerabilities such as cross-site scripting (XSS) attacks. Django's <code>safe</code> filter does not perform any sanitization on the content; it merely marks it as safe for rendering.</p>"},{"location":"backend/django/django-template/#active-in-navigation-website","title":"active in navigation website","text":"<p>Tip</p> BasicAdvanced <p>To change the active state of the navigation links based on the current page, you can use the <code>request.path</code> in your template to compare it with the URL of each navigation link. Here's how you can do it:</p> <pre><code>&lt;ul class=\"navbar-nav mb-2 mb-lg-0\"&gt;\n    &lt;li class=\"nav-item {% if request.path == '/' %}active{% endif %}\"&gt;\n        &lt;a class=\"nav-link\" href=\"{% url 'home' %}\"&gt;Home&lt;/a&gt;\n    &lt;/li&gt;\n    &lt;li class=\"nav-item {% if request.path == '/about/' %}active{% endif %}\"&gt;\n        &lt;a class=\"nav-link\" href=\"{% url 'about' %}\"&gt;About&lt;/a&gt;\n    &lt;/li&gt;\n    &lt;li class=\"nav-item {% if request.path == '/service/' %}active{% endif %}\"&gt;\n        &lt;a class=\"nav-link\" href=\"{% url 'service' %}\"&gt;Service&lt;/a&gt;\n    &lt;/li&gt;\n    &lt;li class=\"nav-item {% if request.path == '/project/' %}active{% endif %}\"&gt;\n        &lt;a class=\"nav-link\" href=\"{% url 'project' %}\"&gt;Project&lt;/a&gt;\n    &lt;/li&gt;\n    &lt;li class=\"nav-item {% if request.path == '/blog/' %}active{% endif %}\"&gt;\n        &lt;a class=\"nav-link\" href=\"{% url 'blog:blog' %}\"&gt;Blog&lt;/a&gt;\n    &lt;/li&gt;\n    &lt;li class=\"nav-item {% if request.path == '/contact/' %}active{% endif %}\"&gt;\n        &lt;a class=\"nav-link\" href=\"{% url 'contact' %}\"&gt;Contact&lt;/a&gt;\n    &lt;/li&gt;\n&lt;/ul&gt;\n</code></pre> <p>In this example:</p> <ul> <li><code>{% if request.path == '/' %}</code> checks if the current page is the home page. If it is, it adds the <code>active</code> class to the corresponding <code>&lt;li&gt;</code> element.</li> <li>Similarly, you can check the <code>request.path</code> against each URL and add the <code>active</code> class accordingly.</li> </ul> <p>Make sure that <code>request</code> is available in your template context. In Django, <code>request</code> is typically available by default in the template context if you've enabled the <code>django.template.context_processors.request</code> context processor in your settings. If not, you need to pass request explicitly to your template context.</p> <p>To highlight the \"Blog\" navigation item when you're on a blog item page, you need to modify the logic to check if the current page URL contains <code>/blog/</code>. Here's how you can do it:</p> <pre><code>&lt;ul class=\"navbar-nav mb-2 mb-lg-0\"&gt;\n    &lt;li class=\"nav-item {% if '/blog/' in request.path %}active{% endif %}\"&gt;\n        &lt;a class=\"nav-link\" href=\"{% url 'blog:blog' %}\"&gt;Blog&lt;/a&gt;\n    &lt;/li&gt;\n    &lt;!-- Add other navigation items --&gt;\n&lt;/ul&gt;\n</code></pre> <p>In this modification:</p> <ul> <li><code>{% if '/blog/' in request.path %}</code> checks if the current page URL contains <code>/blog/</code>. If it does, it adds the <code>active</code> class to the corresponding <code>&lt;li&gt;</code> element.</li> <li>By using <code>in</code>, we're checking if <code>/blog/</code> is part of the current URL. This way, any URL that includes <code>/blog/</code>, like <code>/blog/ktm-bazar</code>, <code>/blog/some-other-blog-post</code>, etc., will highlight the \"Blog\" navigation item.</li> </ul> <p>Make sure that request is available in your template context as explained in the previous response. If not, ensure that you pass request explicitly to your template context in your views.</p> <ul> <li>highlight active links in your django website</li> <li>django-active-link package</li> </ul>"},{"location":"backend/django/django-template/#templates_1","title":"templates","text":"Argument Outputs <code>openblock</code> <code>{%</code> <code>closeblock</code> <code>%}</code> <code>openvariable</code> <code>{{</code> <code>closevariable</code> <code>}}</code> <code>openbrace</code> <code>{</code> <code>closebrace</code> <code>}</code> <code>opencomment</code> <code>{#</code> <code>closecomment</code> <code>#}</code> <p>url template tag</p> <p>Yes, that's correct. When using the <code>{% url %}</code> template tag in Django templates, you specify the name of the URL pattern, not the name of the view function or class-based view.</p> <p>The name parameter you provide in the URL pattern definition (<code>name='...'</code>) is what you use to refer to that URL pattern in the <code>{% url %}</code> template tag.</p> <p>Here's an example to clarify:</p> urls.py<pre><code>from django.urls import path\nfrom .views import my_view_function, MyViewClass\n\nurlpatterns = [\n    path('home/', my_view_function, name='home_view_function'),  # Function-Based View\n    path('about/', MyViewClass.as_view(), name='about_view_class'),  # Class-Based View\n]\n</code></pre> <p>In the above <code>urls.py</code> example:</p> <ul> <li><code>home_view_function</code> is the name of the URL pattern associated with the function-based view <code>my_view_function</code>.</li> <li><code>about_view_class</code> is the name of the URL pattern associated with the class-based view <code>MyViewClass</code>.</li> </ul> <p>Now, when referencing these URL patterns in your templates using the <code>{% url %}</code> template tag, you would use their respective names:</p> html<pre><code>&lt;a href=\"{% url 'home_view_function' %}\"&gt;Link to Home (Function)&lt;/a&gt;\n&lt;a href=\"{% url 'about_view_class' %}\"&gt;Link to About (Class)&lt;/a&gt;\n</code></pre> <p>So, you specify the name of the URL pattern, not the name of the view function or <code>class-based view</code>.</p>"},{"location":"backend/django/django-template/#reference","title":"Reference","text":"<ul> <li>Working with Static and Media Files in Django</li> <li>Managing Media Files in Django </li> <li>Django Media Files</li> <li>Storing Django Static and Media Files on Amazon S3</li> <li>Handling Media Files in Django</li> <li>Static files and Media files: django forum</li> <li>Set up Static and Media files in Django: A Quick and Easy Guide</li> <li>Adding Media Directory In Django </li> </ul>"},{"location":"backend/django/django-urlconf/","title":"django URLconf","text":"<p>django urls</p>"},{"location":"backend/django/django-utility-functions/","title":"Django Utility Function","text":"<p>In Django, utility functions are predefined functions provided by the Django framework to perform common tasks efficiently and effectively. These functions are built-in and can be directly used within Django projects without the need for additional implementation. Some of the utility functions provided by Django include:</p> <p>utility function</p> <ul> <li>slugify: As mentioned earlier, slugify is used to generate URL-friendly versions of strings.</li> <li>gettext and ngettext: These functions are used for internationalization and localization of text strings, allowing developers to make their Django applications multilingual.</li> <li>timezone.now: This function returns the current datetime in the time zone specified by Django's settings.</li> <li>reverse: This function is used to reverse-resolve URLs, meaning it generates a URL from the provided view name and optional parameters.</li> <li>json.dumps and json.loads: These functions are used to serialize Python objects into JSON format and deserialize JSON strings into Python objects, respectively.</li> <li>urlencode: This function is used to encode URL parameters into a query string.</li> <li>format_html: This function is used to safely format HTML strings with placeholders, helping to prevent XSS (Cross-Site Scripting) attacks.</li> <li>get_object_or_404: This function retrieves an object from the database based on given parameters or raises a 404 error if the object does not exist.</li> </ul> <p>These are just a few examples of utility functions provided by Django. There are many more available for various purposes, ranging from string manipulation to database querying and from form handling to file management. These utility functions contribute to Django's power and flexibility, enabling developers to build robust web applications efficiently.</p>"},{"location":"backend/django/django-view/","title":"django view (controller)","text":""},{"location":"backend/django/django-view/#basic","title":"Basic","text":""},{"location":"backend/django/django-view/#django-views","title":"Django Views","text":"<p>Django\u2019s views are the information brokers of a Django application. A view sources data from your database (or an external data source or service) and delivers it to a template. </p> <ul> <li>For a web application, the view delivers web page content and templates; </li> <li>for a RESTful API this content could be formatted JSON data.</li> </ul> <p>Example</p> <p>So, technically, there are three ways to write a view in Django:</p> <ul> <li>function-based views (FBVs), </li> <li>class-based views (CBVs), &amp;</li> <li>generic class-based views (GCBVs).</li> </ul> <p><code>Book</code>: Python Flask and Django by emenwa global,part2-django </p> <p>As per Django Documentation,</p> <p>A view function is a Python function that takes a Web request and returns a Web response. This response can be the HTML contents of a Web page, or a redirect, or a 404 error, or an XML document, or an image, anything that a web browser can display.</p> <p></p> <p>Django views roughly correspond to controllers in MVC, and Django templates to views in MVC.</p> <p></p>"},{"location":"backend/django/django-view/#advanced","title":"Advanced","text":""},{"location":"backend/django/django-view/#example","title":"Example","text":"<p>Example</p> views.pyapp: <code>urls.py</code>about.html views.py<pre><code>from django.shortcuts import render\nfrom django.views.generic import TemplateView\nfrom .models import About, Project, ProjectCategory, ProjectItem, Service, ServiceItem\n\n# Create your views here.\n\nclass IndexView(TemplateView):\n    template_name = 'index.html'\n\n    def get_context_data(self, **kwargs):\n        context = super().get_context_data(**kwargs)\n\n        # Retrieve the first About instance\n        abouts = About.objects.first()\n        context['abouts'] = abouts\n\n        # Retrieve all projects\n        projects = Project.objects.first()\n        context['projects'] = projects\n\n        # Retrieve all project categories\n        project_categories = ProjectCategory.objects.all()\n        context['project_categories'] = project_categories\n\n        # Retrieve all project items\n        project_items = ProjectItem.objects.all()\n        context['project_items'] = project_items\n\n        # Retrieve all services\n        services = Service.objects.first()\n        context['services'] = services\n\n        # Retrieve all service items\n        service_items = ServiceItem.objects.all()\n        context['service_items'] = service_items\n\n        return context\n\nclass AboutView(TemplateView):\n    template_name = 'about.html'\n\n    def get_context_data(self, **kwargs):\n        context = super().get_context_data(**kwargs)\n\n        # Retrieve the About instance\n        about = About.objects.first()\n        context['about'] = about\n\n        return context\n</code></pre> <pre><code>from django.urls import path\nfrom .views import IndexView, AboutView\n\nurlpatterns = [\n    path('', IndexView.as_view(), name='index'),\n    path('about/', AboutView.as_view(), name='about'),\n    # Other URL patterns\n]\n</code></pre> <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n&lt;head&gt;\n    &lt;meta charset=\"UTF-8\"&gt;\n    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;\n    &lt;title&gt;About Us&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;header&gt;\n        &lt;h1&gt;About Us&lt;/h1&gt;\n    &lt;/header&gt;\n    &lt;main&gt;\n        &lt;section&gt;\n            {% if about %}\n                &lt;h2&gt;{{ about.title }}&lt;/h2&gt;\n                &lt;p&gt;{{ about.description }}&lt;/p&gt;\n                &lt;!-- You can display other fields of the About model here --&gt;\n            {% else %}\n                &lt;p&gt;No information available.&lt;/p&gt;\n            {% endif %}\n        &lt;/section&gt;\n    &lt;/main&gt;\n    &lt;footer&gt;\n        &lt;!-- Footer content --&gt;\n    &lt;/footer&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>"},{"location":"backend/django/django-view/#other-topic","title":"Other Topic","text":"get_context_data() IntroductionIn Depth<code>**kwargs</code> <p>Yes, <code>get_context_data()</code> is a built-in method provided by Django for class-based views. It's a method that you can override in your own view classes to customize the context data that is passed to the template when rendering.</p> <p>When you subclass a Django class-based view, such as TemplateView, you have the option to override <code>get_context_data()</code> to provide additional context data or modify existing context data before it is passed to the template for rendering.</p> <p>Here's the general structure of <code>get_context_data()</code> in a Django class-based view:</p> python<pre><code>class YourViewClass(View):\n    # other methods and attributes...\n\n    def get_context_data(self, **kwargs):\n        context = super().get_context_data(**kwargs)\n        # Add or modify context data here\n        return context\n</code></pre> <p>By overriding <code>get_context_data()</code>, you can customize the context data for your views, allowing you to pass any additional information to your templates that may be necessary for rendering.</p> <p>In Django, when you're working with class-based views, get_context_data() is a method used to populate the context dictionary that will be passed to the template rendering engine.</p> <p><code>super().get_context_data(**kwargs)</code> calls the <code>get_context_data()</code> method of the parent class in the method resolution order (MRO). In this case, since your view class (IndexView) inherits from TemplateView, <code>super().get_context_data(**kwargs)</code> calls the <code>get_context_data()</code> method of the TemplateView class.</p> <p>The purpose of <code>super().get_context_data(**kwargs)</code> is to ensure that any context data added by the parent class (TemplateView in this case) is included in the context dictionary. This allows you to extend the context data provided by the parent class while adding your own custom context data in the IndexView.</p> <p>By doing this, you can maintain any default behavior or context data provided by the parent class while adding or modifying context data specific to your IndexView.</p> <p>In Python, <code>**kwargs</code> is a special syntax used in function definitions to collect any keyword arguments that are not explicitly defined. The <code>**kwargs</code> syntax allows you to pass a variable number of keyword arguments to a function. Here's how it works:</p> python<pre><code>def example_function(**kwargs):\n    print(kwargs)\n\nexample_function(a=1, b=2, c=3)\n</code></pre> <p>In this example, <code>**kwargs</code> collects the keyword arguments a, b, and c into a dictionary within the function. When you call <code>example_function(a=1, b=2, c=3)</code>, it prints:</p> <pre><code>{'a': 1, 'b': 2, 'c': 3}\n</code></pre> <p>The <code>**kwargs</code> syntax allows you to pass any number of keyword arguments to the function, and the function will receive them as a dictionary with the keyword names as keys and the corresponding values as values.</p> <p>In the context of Django views, <code>**kwargs</code> is often used in the <code>get_context_data()</code> method to accept any additional keyword arguments that might be passed when calling the method. This allows for flexibility when extending or customizing views, as additional keyword arguments can be passed to <code>get_context_data()</code> without modifying its signature.</p> <p>templates <code>folder structure</code></p> ExampleTheory <p>The structure of the templates folder in a Django project can vary based on developer preferences, project requirements, and the scale of the project. However, there are some common practices that senior developers may follow to organize the templates folder effectively:</p> <p>1.App-Named Subfolders:</p> <ul> <li>One common approach is to create a subfolder within the templates directory for each Django app in your project.</li> <li>For example, if you have apps named <code>app1</code>, <code>app2</code>, and <code>app3</code>, you might have subfolders like <code>templates/app1</code>, <code>templates/app2</code>, and <code>templates/app3</code>.</li> <li>This structure keeps templates organized and helps avoid naming conflicts between templates from different apps.</li> </ul> <p>2. Shared Templates:</p> <ul> <li>Alongside app-specific templates, there might be templates that are shared  across multiple apps or are used globally within the project.</li> <li>These shared templates can be placed directly within the templates directory or within a separate subfolder like <code>templates/shared</code>.</li> </ul> <p>3. Include and Extend Patterns:</p> <ul> <li>Senior developers might use Django's template inheritance features to create a hierarchy of templates.</li> <li>Common elements such as headers, footers, and navigation menus might be placed in base templates, which are then extended by more specific templates for each page or section of the site.</li> <li>These base templates are often stored in a separate subfolder like <code>templates/base</code>.</li> </ul> <p>4. Static Files:</p> <ul> <li>If your project includes static files such as CSS, JavaScript, or images that are specific to templates, they are typically stored within each app's static folder rather than the templates folder.</li> <li>However, sometimes there might be template-specific static files, such as images used only in certain templates, which can be organized similarly within the templates directory.</li> </ul> <p>5. Project-Level Templates:</p> <ul> <li>In some cases, there might be <code>templates</code> that are used across the entire project but don't belong to any specific app.</li> <li>These templates can be stored directly within the templates directory or within a subfolder like <code>templates/project</code>.</li> </ul> <p>Here's an example of what the structure might look like:</p> <pre><code>project_name/\n\u251c\u2500\u2500 project_name/\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 settings.py\n\u2502   \u251c\u2500\u2500 urls.py\n\u2502   \u2514\u2500\u2500 wsgi.py\n\u251c\u2500\u2500 app1/\n\u2502   \u251c\u2500\u2500 templates/\n\u2502   \u2502   \u251c\u2500\u2500 app1/\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 template1.html\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 template2.html\n\u2502   \u2502   \u2514\u2500\u2500 base/\n\u2502   \u2502       \u2514\u2500\u2500 base.html\n\u2502   \u2514\u2500\u2500 ...\n\u251c\u2500\u2500 app2/\n\u2502   \u251c\u2500\u2500 templates/\n\u2502   \u2502   \u251c\u2500\u2500 app2/\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 template3.html\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 template4.html\n\u2502   \u2502   \u2514\u2500\u2500 base/\n\u2502   \u2502       \u2514\u2500\u2500 base.html\n\u2502   \u2514\u2500\u2500 ...\n\u2514\u2500\u2500 templates/\n    \u251c\u2500\u2500 shared/\n    \u2502   \u251c\u2500\u2500 navbar.html\n    \u2502   \u2514\u2500\u2500 footer.html\n    \u2514\u2500\u2500 project/\n        \u2514\u2500\u2500 homepage.html\n</code></pre> <p>This structure keeps the templates organized, making it easier to maintain and understand the project's structure, especially as it grows.</p> <p>The decision of whether to keep template HTML files within the app or solely in the templates folder is influenced by several factors, and different senior programmers may have varying preferences based on project requirements and best practices. Here are some considerations:</p> <p>The decision of whether to keep template HTML files within the app or solely in the templates folder is influenced by several factors, and different senior programmers may have varying preferences based on project requirements and best practices. Here are some considerations:</p> <p>1. Separation of Concerns:</p> <ul> <li>Keeping templates within each app's directory maintains a clear separation of concerns. Each app encapsulates its templates along with its models, views, and other related files. This can make it easier to understand and maintain the codebase, especially for larger projects with many apps.</li> </ul> <p>2. Reusability:</p> <ul> <li>Placing templates within the templates folder allows for better reuse across multiple apps. Templates that are shared between apps can be easily accessed from a central location.</li> <li>However, if templates are tightly coupled with the functionality of a specific app and are unlikely to be reused elsewhere, keeping them within the app's directory may be more appropriate.</li> </ul> <p>3. Project Structure:</p> <ul> <li>Some developers prefer a flatter directory structure to make it easier to locate and manage templates. In such cases, keeping all templates within the templates folder may be preferred.</li> <li>Others prefer a more hierarchical structure, where templates are organized within each app's directory. This can help maintain a clear structure, especially in larger projects with many apps.</li> </ul> <p>4. Project Preferences and Guidelines:</p> <ul> <li>Senior programmers may follow existing project conventions or guidelines established by the team or organization. Consistency within the project codebase is often prioritized over individual preferences.</li> <li>If the project already has a convention in place, it's generally best to adhere to that convention for consistency and maintainability.</li> </ul> <p>5. Integration with Third-party Apps:</p> <p>If your project relies heavily on third-party apps or packages that provide their own templates, keeping app-specific templates separate can help avoid conflicts and make it easier to manage dependencies.</p> <p>In conclusion, there isn't a one-size-fits-all answer, and the decision ultimately depends on factors such as project size, complexity, reuse potential, and team preferences. Both approaches have their advantages, and it's important to weigh these considerations when deciding where to place template files. It's common for senior programmers to consider these factors and make informed decisions based on project requirements and best practices.</p>"},{"location":"backend/django/django-view/#reference","title":"Reference","text":"<ul> <li>Django Tutorial - geeksforgeeks</li> <li>Django w3schools</li> <li>Django javatpoint</li> <li>Django crud: function based views</li> <li>Django crud: class based views</li> <li>Django project MVT structure</li> <li>Django Tutorial: realPython</li> <li>What are Django class based views &amp; should you use them?</li> </ul>"},{"location":"backend/django/intro/","title":"Intro","text":"<p>Django really is the <code>framework for perfectionists with deadlines</code>.</p> <p>Django is an opinionated, full-stack web application framework. It comes with many batteries that you can use to build a fully functional web application, including static and media file management.</p> <p>What Python version can I use with Django?</p> Django version Python versions <code>3.2</code> 3.6, 3.7, 3.8, 3.9, 3.10 (added in 3.2.9) <code>4.0</code> 3.8, 3.9, 3.10 <code>4.1</code> 3.8, 3.9, 3.10, 3.11 (added in 4.1.3) <code>4.2</code> 3.8, 3.9, 3.10, 3.11, 3.12 (added in 4.2.8) <code>5.0</code> 3.10, 3.11, 3.12 <p>For each version of Python, only the latest micro release (A.B.C) is officially supported. You can find the latest micro version for each series on the Python download page.</p> <p>Typically, we will support a Python version up to and including the first Django LTS release whose security support ends after security support for that version of Python ends. For example, Python <code>3.9</code> security support ends in October 2025 and Django <code>4.2</code> LTS security support ends in April 2026. Therefore Django <code>4.2</code> is the last version to support Python 3.9.</p> <p></p> What are Django\u2019s prerequisites? <p>Django requires Python. See the table in the next question for the versions of Python that work with each version of Django. Other Python libraries may be required for some use cases, but you\u2019ll receive an error about them as they\u2019re needed.</p> <p>For a development environment \u2013 if you just want to experiment with Django \u2013 you don\u2019t need to have a separate web server installed or database server.</p> <p>Django comes with its own lightweight development server. For a production environment, Django follows the WSGI spec, PEP 3333, which means it can run on a variety of web servers. See Deploying Django for more information.</p> <p>Django runs SQLite by default, which is included in Python installations. For a production environment, we recommend PostgreSQL; but we also officially support MariaDB, MySQL, SQLite, and Oracle. See Supported Databases for more information.</p>"},{"location":"backend/django/intro/#basic","title":"Basic","text":""},{"location":"backend/django/intro/#django-3-core-parts","title":"Django <code>3</code> core parts","text":"<p>Django\u2019s Parts</p> <p>Django is built on three core parts:</p> <ol> <li>A mapper between URLs and view code</li> <li>An abstraction for interacting with a database</li> <li>A templating system to manage your HTML like code</li> </ol>"},{"location":"backend/django/intro/#big-picture","title":"Big Picture","text":"A Django View is Not a Controller <p>Check out <code>Figure 3-1</code> on the next page, does it look familiar?</p> <p>This is one of my diagrams, but there are plenty of similar versions out there. A common way of explaining Django\u2019s architecture in terms of MVC is to describe it as a Model-Template-View (MTV) or Model-View-Template (MVT). </p> <p>There\u2019s no difference between MTV and MVT\u2014they\u2019re two different ways to describe the same thing, which adds to the confusion.</p> <p></p> <p>The misleading part of this diagram is the view. The view in Django is most often described as being equivalent to the controller in MVC, but it\u2019s not\u2014it\u2019s still the <code>view</code>.</p> <p></p> <p>Note how I have drawn a line between the client- and server-side. Like all client/server architectures, Django uses request and response objects to communicate between the client and the server. As Django is a web framework, we\u2019re talking about HTTP request and response objects.</p> <p></p> <p>The next point to note is that the Django framework encapsulates the model, view logic and business logic. </p> <p>In some tutorials, it\u2019s said that the Django framework is the controller, but that isn\u2019t true either\u2014the <code>Django framework</code> can do much more than respond to user input and interact with data.</p> <p>A perfect example of this extra power is Django\u2019s middleware, which sits between the view and the client-side. Django\u2019s middleware performs critical security and authentication checks before sending the response to the browser.</p> HTTP Request/Response Cycle <p>A network protocol is a set of rules for formatting and processing data. It's like a common language for computers that lets them talk to each other even if they are on opposite sides of the world and have very different hardware and software.</p> <p>HTTP is a protocol that works with a client-server model of computing. When you go to a website, your computer, or \"client,\" sends a \"request,\" and a \"server\" sends back a \"response.\" The client doesn't have to be a computer, though. It could be a cell phone or any other device that can connect to the internet. But the process is the same: a client sends an HTTP request to a URL, and the server sends an HTTP response back.</p> <p>In the end, a web framework like Django takes HTTP requests to a given URL and sends back an HTTP response with the information needed to render a webpage. All done. Usually, this process involves finding the correct URL, connecting to a server, logic, styling with HTML, CSS, JavaScript, or static assets, and then sending the HTTP response.</p> <p>This is what the abstract flow looks like:</p> <p>HTTP Request -&gt; URL -&gt; Django combines database, logic, styling -&gt; HTTP Response</p> <p><code>Book</code>: Python Flask and Django by emenwa global</p> Model-View-Controller (MVC) and Model-View-Template (MVT) <p>Model-View-Controller (MVC) and Model-View-Template (MVT)</p> <p>The Model-View-Controller (MVC) sequence has become a popular way to split up an application's data, logic, and display into separate parts over time. This makes it easier for a programmer to figure out what the code means. The MVC pattern is used by many web frameworks, such as Ruby on Rails, Spring (Java), Laravel (PHP), ASP.NET (C#), and many others.</p> <p>There are three main parts to the traditional MVC pattern:</p> <ul> <li>Model: Takes care of data and the primary project logic</li> <li>View: Gives the model's data in a specific format.</li> <li>Controller: Takes input from the user and does application-specific logic.</li> </ul> <p>Django's method, often called Model-View-Template, only loosely follows the traditional MVC method (MVT). Developers who have worked with web frameworks before might find this confusing at first. In reality, Django's approach is a 4-part pattern that also includes URL Configuration. A better way to describe it would be something like MVTU.</p> <p>Here's how the Django MVT pattern works:</p> <ul> <li>Model: Manages data and core business logic</li> <li>View: Tells the user what data is sent to them, but not how it is shown.</li> <li>Template: Shows the information in HTML, with CSS, JavaScript, and Static Assets as options.</li> <li>URL Configuration: Regular-expression components set up for a View</li> </ul> <p>This interaction is a crucial part of Django, but it can be hard to understand for new users, so let's draw a diagram of how an HTTP request and response cycle works. When a URL like https://djangoproject.com is typed in, the first thing that happens in our Django project is that a URL pattern (contained in urls.py) that matches it is found. The URL pattern is linked to a single view (in views.py) that combines the data from the model (in models.py) and the styling from a template (any file ending in .html). After that, the view gives the user an HTTP response.</p> <p>The flow looks like below:</p> <p>HTTP Request -&gt; URL -&gt; View -&gt; Model and Template -&gt; HTTP Response</p> <p><code>Book</code>: Python Flask and Django by emenwa global</p> <p></p>"},{"location":"backend/django/intro/#concept","title":"Concept","text":""},{"location":"backend/django/intro/#dir-vs-help","title":"<code>dir()</code> vs <code>help()</code>","text":"<p>Koncept HolyGrail</p> <p><code>dir()</code> lists attributes and methods of an object, while <code>help()</code> provides detailed documentation about specific objects, including classes, functions, and modules.</p> <p>Django</p> <pre><code>$ django-admin shell\n\n$ import django\n$ dir(django)\n$ help(django)\n</code></pre> <p><code>djangorestframework</code> rest_framework</p> <pre><code>$ py manage.py shell\n\n$ import rest_framework\n$ dir(rest_framework)\n$ help(rest_framework)\n\n$ import rest_framework.generics\n$ dir(rest_framework.generics)\n$ help(rest_framework.generics) \n</code></pre>"},{"location":"backend/django/intro/#managepy-vs-django-admin","title":"<code>manage.py</code> vs <code>django-admin</code>","text":"<p>manage.py shell vs django shell</p> <p>python manage.py shell loads the Django project's environment, while django-admin shell provides a general Python shell without Django-specific setup.</p> <pre><code># django-admin shell provides a general Python shell without Django-specific setup.\ndjango-admin shell\n\n# python manage.py shell loads the Django project's environment.\npy manage.py shell\n</code></pre>"},{"location":"backend/django/intro/#other-topic","title":"Other Topic","text":"<p>Django Run Server</p> <pre><code>$ python manage.py runserver 127.0.0.1:7000\n\n$ python manage.py runserver 7000\n\n$ python manage.py runserver 0:7000\n</code></pre> <p>mutable &amp; immutable objects</p> <p>Mutability is a fundamental concept of the Python language and is broken down into mutable and immutable objects. </p> <p>An object is said to be mutable if its values can change over time. If an object's value will not change, then that object is said to be immutable. In Python, an object's mutability is also defined by the data type that it is. For example, mutable objects are represented using a <code>list</code>, <code>dictionary</code>, <code>set</code>, or <code>QuerySet</code>. </p> <p>Immutable objects are defined by using the <code>bool</code>, <code>decimal</code>, <code>float</code>, <code>int</code>, <code>range</code>, <code>string</code>, and <code>tuple</code> data types. Queries will perform better if the object being searched is immutable rather than mutable. </p> <p>Most of the time, the difference is miniscule, literally in nano-or milliseconds. When your project goes live and your database starts to collect thousands, if not millions, of records, the time it takes to query something will then be noticed when it takes seconds, if not minutes or tens of minutes, to complete a single query.</p> <p>Becomming Enterprise Developer (pg-122)</p> how to master Django framework <p>To master the Django framework, it's essential to gain proficiency in several key areas. Here are some of the most important topics to learn:</p> <p>1. Understanding Models:</p> <p>Django's ORM (Object-Relational Mapping) allows you to interact with your database using Python objects. Learn how to define models to represent your application's data, work with relationships between models, and use Django's querysets for database operations.</p> <p>2. Views and URLs:</p> <p>Understand how views process HTTP requests and generate responses. Learn how to map URLs to views using URL patterns, and explore Django's function-based views and class-based views.</p> <p>3. Templates and Template Language:</p> <p>Django uses a powerful templating engine to generate dynamic HTML content. Learn how to create templates, use template inheritance and inclusion, and leverage Django's template language for data rendering and logic.</p> <p>4. Forms:</p> <p>Django provides tools for working with HTML forms and handling form submissions. Learn how to create forms using Django's form classes, validate user input, and process form submissions in views.</p> <p>5. Authentication and Authorization:</p> <p>Understand how to implement user authentication and authorization in Django. Learn about Django's built-in authentication system, including user authentication views, user models, and permissions.</p> <p>6. Admin Interface:</p> <p>Django includes a customizable admin interface for managing site content. Learn how to register models with the admin interface, customize admin views, and implement custom admin actions and filters.</p> <p>7. Middleware:</p> <p>Middleware components are a key part of Django's request/response processing pipeline. Learn how to write custom middleware to perform tasks such as request/response modification, authentication, or logging.</p> <p>8. Class-Based Views (CBVs):</p> <p>While Django supports function-based views, class-based views offer a more organized and reusable approach to view development. Mastering CBVs can help you create more modular and maintainable code.</p> <p>9. RESTful APIs with Django REST Framework:</p> <p>If your application needs to expose a RESTful API, learn how to use Django REST Framework (DRF) to build APIs quickly and efficiently. DRF provides tools for serialization, authentication, pagination, and more.</p> <p>10. Testing:</p> <p>Writing tests is crucial for ensuring the reliability and correctness of your Django applications. Learn how to write unit tests, integration tests, and functional tests using Django's testing framework.</p> <p>11. Security Best Practices:</p> <p>Understand common security vulnerabilities and best practices for securing Django applications. Topics include protecting against CSRF attacks, XSS attacks, SQL injection, and ensuring secure user authentication.</p> <p>12. Deployment:</p> <p>Learn how to deploy Django applications to production environments. Understand deployment options such as using WSGI servers like Gunicorn, configuring web servers like Nginx or Apache, and setting up databases and caching solutions.</p> <p>By focusing on these key topics and building projects that utilize these concepts, you'll develop a strong foundation in Django development and be well-equipped to create robust and scalable web applications. Additionally, staying up-to-date with the latest developments in the Django ecosystem and exploring advanced topics as you gain experience will further enhance your mastery of the framework.</p> Basic of CBVs in Django <p>Certainly! Class-Based Views (CBVs) in Django provide a more structured and reusable way to handle HTTP requests compared to function-based views. Here's a comprehensive list of commonly used CBVs that you should learn:</p> <p>1. View:</p> <p>The base class for all views. It doesn't perform any actions itself but serves as the superclass for other views.</p> <p>2. TemplateView:</p> <p>Renders a template in response to a GET request. This is useful for rendering simple static pages or pages that don't require data manipulation.</p> <p>3. RedirectView:</p> <p>Redirects the user to a different URL. It's useful for implementing redirects in response to specific conditions or actions.</p> <p>4. ListView:</p> <p>Renders a list of objects from a queryset. It's often used to display a list of items from a database table or any other iterable data source.</p> <p>5. DetailView:</p> <p>Renders a detail page for a single object retrieved from a queryset. It's used to display detailed information about a specific object, typically identified by a unique identifier such as a primary key.</p> <p>6. CreateView:</p> <p>Handles the creation of new objects. It renders a form for creating a new object and processes the submitted data.</p> <p>7. UpdateView:</p> <p>Handles the updating of existing objects. It renders a form pre-filled with the data of an existing object and processes the submitted data to update the object.</p> <p>8. DeleteView:</p> <p>Handles the deletion of existing objects. It renders a confirmation page before deleting the object and then performs the deletion upon confirmation.</p> <p>9. FormView:</p> <p>Renders a form and handles its submission. It's useful for scenarios where you need custom logic for form processing.</p> <p>10. DetailView:</p> <p>Renders a detail page for a single object retrieved from a queryset. It's used to display detailed information about a specific object, typically identified by a unique identifier such as a primary key.</p> <p>11. ArchiveIndexView:</p> <p>Renders a list of objects grouped by date. It's useful for displaying archives of objects, such as blog posts grouped by publication date.</p> <p>12. YearArchiveView:</p> <p>Renders a list of objects for a specific year. It's typically used in conjunction with ArchiveIndexView to navigate through archives by year.</p> <p>13. MonthArchiveView:</p> <p>Renders a list of objects for a specific month within a year. It's used to display archives filtered by month.</p> <p>14. DayArchiveView:</p> <p>Renders a list of objects for a specific day within a month and year. It's used to display archives filtered by day.</p> <p>15. TodayArchiveView:</p> <p>Renders a list of objects for the current day. It's a shortcut for DayArchiveView with today's date.</p> <p>16. DateDetailView:</p> <p>Renders a detail page for a single object for a specific date. It's useful for displaying detailed information about an object based on its date.</p> <p>These are the core CBVs provided by Django. Mastering these classes will enable you to efficiently handle common web development tasks and build robust applications using Django's class-based views architecture.</p> Mastering CBVs in Django <p>Mastering Class-Based Views (CBVs) in Django requires a combination of understanding the underlying concepts and practical application. Here's a structured approach to mastering CBVs:</p> <p>1. Understand the Basics:</p> <ul> <li>Familiarize yourself with the different types of CBVs provided by Django, such as ListView, DetailView, CreateView, UpdateView, DeleteView, etc.</li> <li>Read the Django documentation thoroughly to understand the purpose and usage of each CBV.</li> <li>Review the source code of Django's built-in CBVs to gain insights into how they are implemented.</li> </ul> <p>2. Hands-on Practice:</p> <ul> <li>Start by creating simple projects or applications where you can apply CBVs.</li> <li>Implement basic functionalities such as displaying lists of objects, viewing details, creating, updating, and deleting objects using CBVs.</li> <li>Experiment with different CBVs and observe how they behave in different scenarios.</li> <li>Refactor existing function-based views to class-based views to understand the differences and benefits.</li> </ul> <p>3. Explore Customization:</p> <ul> <li>Dive deeper into customization options provided by CBVs. Learn how to override methods and attributes to tailor the behavior of CBVs to your specific requirements.</li> <li>Practice extending built-in CBVs to add additional functionality or modify existing behavior without rewriting the entire view.</li> </ul> <p>4. Advanced Topics:</p> <ul> <li>Explore more advanced topics related to CBVs, such as mixin classes, multiple inheritance, and view composition.</li> <li>Learn about best practices for structuring CBVs in large-scale applications to maintain code readability and reusability.</li> <li>Experiment with integrating third-party libraries or frameworks with CBVs, such as Django REST Framework for building RESTful APIs.</li> </ul> <p>5. Review and Refine:</p> <ul> <li>Regularly review your code and seek feedback from peers or mentors to identify areas for improvement.</li> <li>Refactor your codebase to incorporate best practices and design patterns related to CBVs.</li> <li>Stay updated with the latest developments in the Django ecosystem, including new features and improvements related to CBVs.</li> </ul> <p>6. Build Real Projects:</p> <ul> <li>Work on real-world projects that require complex functionality and utilize CBVs extensively.</li> <li>Apply your knowledge of CBVs to solve practical problems and implement features efficiently.</li> <li> <p>Reflect on your project experiences and identify lessons learned to improve your understanding and mastery of CBVs.</p> </li> <li> <p>Contribute to Open Source:</p> </li> <li> <p>Consider contributing to open-source projects that use CBVs. This allows you to collaborate with experienced developers, gain exposure to different coding styles, and contribute to the Django community.</p> </li> </ul> <p>By following this structured approach and combining theoretical understanding with practical application, you can gradually master Class-Based Views in Django and become proficient in building robust web applications. Remember that mastery comes with continuous learning, practice, and experimentation.</p> Example of Class-Based View (CBV) in Django: modelsviewshtmlurlsquestions <p>Let's consider a scenario where you want to display a list of books using a ListView. First, you'll define a model for the books in your models.py:</p> models.py<pre><code># models.py\nfrom django.db import models\n\nclass Book(models.Model):\n    title = models.CharField(max_length=100)\n    author = models.CharField(max_length=100)\n    publication_date = models.DateField()\n\n    def __str__(self):\n        return self.title\n</code></pre> <p>Then, you'll create a ListView to display a list of books in your views.py:</p> views.py<pre><code># views.py\n\nfrom django.views.generic import ListView\nfrom .models import Book\n\nclass BookListView(ListView):\n    model = Book\n    template_name = 'book_list.html'  # specify the template name\n    context_object_name = 'books'     # specify the context variable name for the list of objects\n    ordering = ['-publication_date']  # specify the default ordering of the queryset\n</code></pre> <p>Next, you'll create a template to render the list of books. Create a file named book_list.html in your templates directory:</p> book_list.html<pre><code>&lt;!-- book_list.html --&gt;\n\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;title&gt;Book List&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;h1&gt;Book List&lt;/h1&gt;\n    &lt;ul&gt;\n        {% for book in books %}\n            &lt;li&gt;{{ book.title }} - {{ book.author }} ({{ book.publication_date }})&lt;/li&gt;\n        {% empty %}\n            &lt;li&gt;No books available.&lt;/li&gt;\n        {% endfor %}\n    &lt;/ul&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <p>Finally, you'll set up the URL mapping in your urls.py to associate the ListView with a URL:</p> urls.py<pre><code># urls.py\n\nfrom django.urls import path\nfrom .views import BookListView\n\nurlpatterns = [\n    path('books/', BookListView.as_view(), name='book-list'),\n]\n</code></pre> <p>Now, when a user navigates to <code>/books/</code> in the browser, Django will use the BookListView to fetch the list of books from the database and render them using the book_list.html template.</p> <p>is the context_object_name random variable name or ?</p> <p>No, context_object_name is not a random variable name. It's a specific attribute of Django's ListView class-based view (CBV) that allows you to specify the name of the variable that will be used to pass the list of objects to the template context.</p> <p>When you define a ListView in Django, it automatically retrieves a list of objects from the specified model and passes them to the template context. By default, this list is passed using the variable name object_list. However, you can customize this variable name using the context_object_name attribute.</p> <p>For example, in the following code snippet:</p> <pre><code>class BookListView(ListView):\n    model = Book\n    template_name = 'book_list.html'\n    context_object_name = 'books'\n</code></pre> <p>The context_object_name is set to 'books', which means that in the book_list.html template, the list of books will be available as the variable books.</p> <p>So, in the template:</p> <pre><code>{% for book in books %}\n    {{ book.title }}\n{% endfor %}\n</code></pre> <p>Here, books is the name specified by context_object_name, and it represents the list of books retrieved by the ListView. You can choose any meaningful name for context_object_name based on your application's context.</p> <p>This is just one example of how you can use a CBV in Django. CBVs provide a flexible and reusable way to handle different types of views in your web application, allowing you to write clean and maintainable code.</p> Question about CBVs in django <p>In Django's Class-Based Views (CBVs), the as_view() method is a crucial part of the view setup process. It's used to convert a class-based view into a view function that Django can use to handle HTTP requests.</p> <p>When you define a CBV, you're essentially defining a Python class that encapsulates the logic for processing a particular type of HTTP request. However, Django's URL routing system expects to work with functions rather than classes. So, to make your CBV compatible with Django's URL routing mechanism, you use the as_view() method.</p> <p>Here's how it works:</p> <p>1. Defining the CBV:</p> <p>First, you define your CBV by creating a subclass of one of Django's built-in CBV classes, such as ListView, DetailView, CreateView, etc. For example:</p> <pre><code>from django.views.generic import ListView\nfrom .models import MyModel\n\nclass MyListView(ListView):\n    model = MyModel\n    template_name = 'myapp/my_model_list.html'\n</code></pre> <p>2. Using as_view() in URL Configuration:</p> <p>When you include your CBV in your URL configuration (usually in urls.py), you use the as_view() method to convert the CBV into a view function that Django's URL dispatcher can work with. For example:</p> <pre><code>from django.urls import path\nfrom .views import MyListView\n\nurlpatterns = [\n    path('my-list/', MyListView.as_view(), name='my-list'),\n]\n</code></pre> <p>3. Instantiating the CBV:</p> <p>When Django's URL dispatcher matches a URL pattern to a view function, it will instantiate the CBV using the as_view() method and call the appropriate method (such as get() or post()) to handle the HTTP request.</p> <p>Behind the scenes, the as_view() method creates a function that:</p> <ul> <li>Instantiates the CBV class.</li> <li>Calls the appropriate method (dispatch()) on the instance to handle the HTTP request.</li> <li>Returns the HTTP response generated by the CBV.</li> </ul> <p>This process allows Django's URL routing system to seamlessly work with CBVs, providing a more object-oriented and modular approach to handling HTTP requests compared to traditional function-based views.</p> Detail on routers <p>In traditional Django applications that serve HTML content using Django's built-in views and templates, routers are not typically used. Routers are primarily associated with Django REST Framework (DRF), which is an additional library used for building RESTful APIs in Django.</p> <p>In traditional Django applications:</p> <p>1. URL Configuration:</p> <p>URL patterns are typically defined in the urls.py module of your Django application. You manually specify the URL patterns and map them to corresponding views or view functions.</p> <p>2. Views:</p> <p>Views in traditional Django applications are typically implemented as functions or class-based views (CBVs) within your Django application. These views are responsible for processing HTTP requests and returning HTTP responses, usually in the form of HTML content generated with Django's template engine.</p> <p>3. Templates:</p> <p>HTML templates are used to generate the content that is returned to the user's browser. Django's template engine allows you to define dynamic HTML content by embedding Python-like code within HTML templates.</p> <p>In summary, if you are building a traditional Django application that serves HTML content, you won't typically use routers. Routers are specifically designed for building RESTful APIs with Django REST Framework, where URL routing and resource management are different from traditional Django applications.</p> <p>However, if you are building a RESTful API using Django REST Framework, routers provide a convenient and efficient way to define URL patterns for your API endpoints, organize your API resources, and manage URL configurations.</p>"},{"location":"backend/django/intro/#others","title":"Others","text":"<p>pip freeze</p> <p>If you want to freeze a newly installed package only to your <code>prod-requirements.txt</code> file and not the <code>dev-requirements.txt</code>, you can manually add it to <code>prod-requirements.txt</code> after installation. Here's how you can do it:</p> <ol> <li> <p>First, install the package using pip install <code>&lt;package_name&gt;</code>.</p> </li> <li> <p>After installation, run pip freeze to see the list of installed packages.</p> </li> <li> <p>Identify the newly installed package in the output of pip freeze.</p> </li> <li> <p>Copy the line corresponding to the newly installed package, including its version, from the output of pip freeze.</p> </li> <li> <p>Open your <code>prod-requirements.txt</code> file in a text editor.</p> </li> <li> <p>Paste the copied line into your <code>prod-requirements.txt</code> file.</p> </li> <li> <p>Save the <code>prod-requirements.txt</code> file.</p> </li> </ol> <p>By following these steps, you're ensuring that the newly installed package is frozen only in your <code>prod-requirements.txt</code> file and not in your <code>dev-requirements.txt</code> file. This keeps the development and production environments separate and ensures that only production dependencies are specified in the <code>prod-requirements.txt</code>.</p> <p>Best WYSIWYG editor for website</p> <p>1. TinyMCE</p> <p>2. CKEditor</p> <ul> <li>Best WYSIWYG Editors</li> <li>20 Best WYSIWYG HTML Editors for 2024</li> <li>What is your goto WYSIWYG Editor? </li> </ul>"},{"location":"backend/django/intro/#paginator","title":"Paginator","text":"<p>pagination</p> <ul> <li> <p>What is the difference between TemplateView <code>vs</code> ListView</p> </li> <li> <p>list view vs tempate view</p> </li> </ul> <p>Warning</p> Defensive String Representation for About Model <p>A senior programmer might write the <code>__str__</code> method in a slightly more defensive and robust way.</p> <p>Here's an example of how they might do it(<code>shown in fig-1</code>):</p> <p>In this version, a few improvements have been made:</p> <ul> <li> <p>Conditional Concatenation: It checks if about_descrip is not empty before concatenating it with about_title. If <code>about_descrip</code> is empty, it simply returns <code>about_title</code>. This avoids potential errors if <code>about_descrip</code> is None or an empty string.</p> </li> <li> <p>Limiting Description Length: It limits the length of about_descrip to the first 50 characters. This helps to prevent excessively long strings from cluttering up output (you can adjust this number to fit your needs).</p> </li> <li> <p>Formatted String: It uses an f-string for string interpolation, which is more concise and readable.</p> </li> </ul> <p>By incorporating these practices, the code becomes more robust and easier to understand and maintain.</p> <p></p> How to view all app code in index.html admin.py<pre><code>@admin.register(About)\nclass AboutAdmin(admin.ModelAdmin):\n    list_display = ['title', 'description', 'image_preview']\n\n    def image_preview(self, obj):\n        if obj.image:\n            return mark_safe('&lt;img src=\"{url}\" width=\"100\" height=\"100\" /&gt;'.format(url=obj.image.url))\n        else:\n            return 'No Image'\n\n    image_preview.short_description = 'Image Preview'\n</code></pre> views.py<pre><code>from django.views.generic import TemplateView\nfrom .models import About, Contact\n\nclass IndexView(TemplateView):\n    template_name = 'index.html'\n\n    def get_context_data(self, **kwargs):\n        context = super().get_context_data(**kwargs)\n        context['about'] = About.objects.first()  # Assuming you have only one About instance\n        context['contact'] = Contact.objects.first()  # Assuming you have only one Contact instance\n        return context\n</code></pre> index.html<pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n&lt;head&gt;\n    &lt;meta charset=\"UTF-8\"&gt;\n    &lt;title&gt;Index&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;h1&gt;Welcome to Our Website&lt;/h1&gt;\n    &lt;h2&gt;About Us&lt;/h2&gt;\n    &lt;p&gt;{{ about.description }}&lt;/p&gt;\n\n    &lt;h2&gt;Contact Us&lt;/h2&gt;\n    &lt;p&gt;{{ contact.description }}&lt;/p&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <p>Example</p> <p>To add a nullable image field in Django, you can use the ImageField from django.db.models. By default, ImageField allows null values, so you just need to set null=True and blank=True attributes. Here's how you can do it:</p> <p>1. First, ensure you have Pillow installed. Pillow is a required dependency for handling images in Django.</p> <pre><code>pip install Pillow\n</code></pre> <p>2. In your Django model, define an ImageField and set null=True and blank=True attributes.</p> <pre><code>from django.db import models\n\nclass YourModel(models.Model):\n    image = models.ImageField(null=True, blank=True, upload_to='your_upload_path/')\n</code></pre> django nullable field <p>In Django models, null=True and blank=True are <code>two parameters</code> that can be set for a field to allow it to be optional.</p> <p>1. null=True: This parameter specifies that the database column associated with the field can store NULL values. It's a database-level option. If null=True is set, Django will store empty values as NULL in the database.</p> <p>2. blank=True: This parameter is used for form validation. When blank=True is set, the field is allowed to be left blank in forms. It's a validation-related option. Without blank=True, the field would be required in forms.</p> <p>Here's a breakdown of their roles:</p> <ul> <li>null=True: Affects database schema, allowing NULL values in the database column.</li> <li>blank=True: Affects form validation, allowing the field to be left blank in forms.</li> </ul> <p>Using null=True, blank=True together is common when you want a field to be optional both at the database level and in forms. For example, in the context of an image field, null=True allows the database to store records without images, and blank=True allows users to submit forms without uploading an image.</p> <ul> <li>Sort Apps in the Django Admin</li> </ul> <p>Reuse HasAddPermissionMixin in Django Admin for Blogs App</p> <p>Yes, you can reuse the <code>HasAddPermissionMixin</code> class in your <code>blogs</code> app's <code>admin.py</code> file, provided that you have access to it. You can either import it directly or place it in a module that both apps can access.</p> <p>Here's how you can reuse the <code>HasAddPermissionMixin</code> class in your <code>blogs</code> app's <code>admin.py</code> file:</p> <pre><code>from django.contrib import admin\nfrom .models import YourModel\nfrom websites.apps.admin import HasAddPermissionMixin\n\nclass YourModelAdmin(HasAddPermissionMixin, admin.ModelAdmin):\n    pass  # Add other admin customization as needed\n\nadmin.site.register(YourModel, YourModelAdmin)\n</code></pre> <p>In the above code, replace <code>YourModel</code> with the model you want to apply this mixin to. This will apply the <code>HasAddPermissionMixin</code> to your model admin, allowing you to control the add permission based on the existence of objects.</p> <p>Make sure that the <code>websites.apps.admin</code> module is importable from your <code>blogs</code> app. If it's not directly accessible, you may need to reorganize your code or import the mixin from a different location that both apps can access.</p> chatgpt <pre><code>django.db.models.fields\n</code></pre>"},{"location":"backend/django/intro/#ask-chatgpt","title":"ask chatgpt:","text":"<p>how does the seniort programmer writes this code:</p>"},{"location":"backend/django/intro/#static-category","title":"Static Category","text":"<p>To create a category dropdown field in a Django model, you typically use the models.CharField with choices. Here's how you can do it:</p> <pre><code>from django.db import models\n\nclass YourModel(models.Model):\n    CATEGORY_CHOICES = (\n        ('option1', 'Option 1'),\n        ('option2', 'Option 2'),\n        ('option3', 'Option 3'),\n        # Add more choices as needed\n    )\n\n    category = models.CharField(max_length=50, choices=CATEGORY_CHOICES)\n\n    # Your other fields here\n</code></pre>"},{"location":"backend/django/intro/#dynamic-category","title":"Dynamic Category","text":"<p>To create a dynamic dropdown menu where the admin can add new categories through the Django admin interface, you can utilize Django's built-in <code>ForeignKey field</code> or <code>ManyToManyField</code> if you want multiple categories per item. Here's how you can do it using <code>ForeignKey</code>:</p> <ol> <li> <p>Create a Category Model: First, create a model to represent your categories.</p> <pre><code>from django.db import models\n\nclass Category(models.Model):\n    name = models.CharField(max_length=100)\n\n    def __str__(self):\n        return self.name\n</code></pre> </li> <li> <p>Register Models in admin.py: Register both models in your admin.py file to make them accessible in the Django admin interface.</p> <pre><code>from django.contrib import admin\nfrom .models import YourModel, Category\n\nadmin.site.register(YourModel)\nadmin.site.register(Category)\n</code></pre> </li> </ol>"},{"location":"backend/django/intro/#mark_safe","title":"mark_safe","text":"<pre><code>from django.utils.safestring import mark_safe\n</code></pre>"},{"location":"backend/django/intro/#pillow","title":"Pillow","text":"<p>Pillow is a Python Imaging Library (PIL) fork that provides extensive capabilities for opening, manipulating, and saving many different image file formats. It is a powerful library for image processing tasks in Python and is widely used in various applications, including web development, scientific computing, computer vision, and more.</p> <pre><code>pip install Pillow\n</code></pre> <p>In Django, Pillow is commonly used for handling image-related tasks such as uploading, processing, and serving images in web applications. Here's how Pillow is typically used in Django:</p> <ul> <li> <p><code>ImageField</code> in Models:</p> <p>Django's ImageField is used to store image files in the database. Pillow integrates seamlessly with ImageField, allowing you to handle image uploads and save them to the filesystem.</p> <pre><code>from django.db import models\n\nclass MyModel(models.Model):\n    image = models.ImageField(upload_to='images/')\n</code></pre> </li> </ul>"},{"location":"backend/django/intro/#django-built-in","title":"Django Built-in","text":"Django <code>accounts</code> IntroductionPractical <p>Django accounts typically refers to the user authentication system built using Django, a high-level Python web framework. In web development, user authentication is a common requirement where users need to register, log in, log out, and manage their accounts.</p> <p>Django provides a <code>built-in</code> authentication system that includes features such as user registration, login, logout, password management, and more. This system is highly customizable and can be extended to meet the specific requirements of different projects.</p> <p>When developers refer to \"Django accounts,\" they are often discussing the implementation and customization of these authentication features within a Django web application. This can include designing user registration forms, login views, password reset functionality, user profile pages, and other related features.</p> <p>Django accounts are an essential component of many web applications, as they allow users to securely access and interact with the application's features and data. By using Django's built-in authentication system, developers can streamline the development process and ensure that user accounts are managed securely and efficiently.</p> <p>Certainly! Below, I'll guide you through the process of setting up a basic Django project with user authentication. This will include creating a new Django project, setting up user authentication, and creating basic views and templates for user registration, login, and logout.</p> <p>Install Django: If you haven't already installed Django, you can do so using pip, Python's package manager:</p> <pre><code>pip install django\n\n# Create a new Django project:\ndjango-admin startproject myproject\n\n# Navigate to the project directory:\ncd myproject\n\n# Django's built-in authentication system is part of the django.contrib.auth module\n\n# Create a new Django app for user authentication:\npython manage.py startapp accounts\n</code></pre> <p>Create URL patterns: Define URL patterns for user authentication views in your project's urls.py file:</p> <pre><code>from django.contrib import admin\nfrom django.urls import path, include\n\nurlpatterns = [\n    path('admin/', admin.site.urls),\n    path('accounts/', include('accounts.urls')),\n]\n</code></pre> <p>Create URL patterns in accounts app: Create a new file called urls.py in the accounts app directory, and define URL patterns for authentication views:</p> <pre><code>from django.urls import path\nfrom . import views\n\nurlpatterns = [\n    path('signup/', views.signup, name='signup'),\n    path('login/', views.login, name='login'),\n    path('logout/', views.logout, name='logout'),\n]\n</code></pre> <p>Create views: Create view functions for user registration, login, and logout in the views.py file inside the accounts app:</p> <pre><code>from django.shortcuts import render\n\ndef signup(request):\n    # Implement user registration logic here\n    return render(request, 'accounts/signup.html')\n\ndef login(request):\n    # Implement login logic here\n    return render(request, 'accounts/login.html')\n\ndef logout(request):\n    # Implement logout logic here\n    return render(request, 'accounts/logout.html')\n</code></pre> <p>Create templates: Create HTML templates for user registration, login, and logout inside a templates/accounts directory in your app. Name these templates signup.html, login.html, and logout.html, respectively. You can design these templates as per your project's requirements.</p> <pre><code># Migrate the database:\npython manage.py migrate\n\n# Run the development server:\npython manage.py runserver\n</code></pre> <p>Now, you should be able to access the user authentication views at URLs like <code>/accounts/signup/</code>, <code>/accounts/login/</code>, and <code>/accounts/logout/</code>. You can customize the views, templates, and functionality further based on your project's requirements. Additionally, you may want to implement features like password reset, user profile management, etc., as needed.</p> folder structure of accounts<pre><code>myproject/\n\u251c\u2500\u2500 accounts/\n\u2502   \u251c\u2500\u2500 templates/\n\u2502   \u2502   \u251c\u2500\u2500 accounts/\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 signup.html\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 login.html\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 logout.html\n\u2502   \u251c\u2500\u2500 views.py\n\u2502   \u251c\u2500\u2500 urls.py\n\u251c\u2500\u2500 myproject/\n\u2502   \u251c\u2500\u2500 settings.py\n\u2502   \u251c\u2500\u2500 urls.py\n\u2502   \u2514\u2500\u2500 ...\n\u2514\u2500\u2500 ...\n</code></pre> <p>Efficient Data Presentation in Django Templates: Integrating Multiple Models into Your Index Page</p> <p>To display the data from the models <code>About</code>, <code>Project</code>, <code>ProjectCategory</code>, <code>ProjectItem</code>, <code>Service</code>, and <code>ServiceItem</code> in your index.html template, you'll need to pass the data from these models to the template through your view function or class-based view.</p> <p>Here's how you can modify your view to include data from all these models:</p> views.pyindex.html <pre><code>from django.shortcuts import render\nfrom django.views.generic import TemplateView\nfrom .models import About, Project, ProjectCategory, ProjectItem, Service, ServiceItem\n\nclass IndexView(TemplateView):\n    template_name = 'index.html'\n\n    def get_context_data(self, **kwargs):\n        context = super().get_context_data(**kwargs)\n\n        # Retrieve the About instance\n        about_info = About.objects.first()\n        context['about_info'] = about_info\n\n        # Retrieve all projects\n        projects = Project.objects.all()\n        context['projects'] = projects\n\n        # Retrieve all project categories\n        project_categories = ProjectCategory.objects.all()\n        context['project_categories'] = project_categories\n\n        # Retrieve all service items\n        service_items = ServiceItem.objects.all()\n        context['service_items'] = service_items\n\n        return context\n</code></pre> <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n&lt;head&gt;\n    &lt;meta charset=\"UTF-8\"&gt;\n    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;\n    &lt;title&gt;Index&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;h1&gt;About&lt;/h1&gt;\n    &lt;p&gt;{{ about_info.title }}&lt;/p&gt;\n    &lt;p&gt;{{ about_info.description }}&lt;/p&gt;\n\n    &lt;h1&gt;Projects&lt;/h1&gt;\n    &lt;ul&gt;\n        {% for project in projects %}\n            &lt;li&gt;\n                &lt;h2&gt;{{ project.title }}&lt;/h2&gt;\n                &lt;p&gt;{{ project.description }}&lt;/p&gt;\n            &lt;/li&gt;\n        {% endfor %}\n    &lt;/ul&gt;\n\n    &lt;h1&gt;Project Categories&lt;/h1&gt;\n    &lt;ul&gt;\n        {% for category in project_categories %}\n            &lt;li&gt;{{ category.name }}&lt;/li&gt;\n            &lt;ul&gt;\n                {% for item in category.items.all %}\n                    &lt;li&gt;{{ item.title }}&lt;/li&gt;\n                    &lt;p&gt;{{ item.description }}&lt;/p&gt;\n                {% endfor %}\n            &lt;/ul&gt;\n        {% endfor %}\n    &lt;/ul&gt;\n\n    &lt;h1&gt;Service Items&lt;/h1&gt;\n    &lt;ul&gt;\n        {% for item in service_items %}\n            &lt;li&gt;\n                &lt;h2&gt;{{ item.title }}&lt;/h2&gt;\n                &lt;p&gt;{{ item.description }}&lt;/p&gt;\n            &lt;/li&gt;\n        {% endfor %}\n    &lt;/ul&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <p>In Django, the context variable is a dictionary that is passed from the view to the template. It contains data that you want to make available to your template for rendering.</p> <p>In the provided code snippet:</p> <pre><code>projects = Project.objects.all()\ncontext['projects'] = projects\n</code></pre> <ul> <li>Project.objects.all() retrieves all instances of the Project model from the database.</li> <li>projects is a queryset containing all instances of the Project model.</li> <li>context['projects'] = projects assigns the queryset projects to the key 'projects' in the context dictionary.</li> </ul> <p>The context dictionary is then passed to the template when rendering the view. This allows you to access the data in the template using the keys of the context dictionary. For example, in your template, you would use {{ projects }} to access the list of projects retrieved from the database.</p> <p>Understanding Queryset Retrieval in Django's Model Views: all() vs first() and Looping in Templates</p> <p>The difference between <code>Project.objects.all()</code> and <code>Project.objects.first()</code> lies in the data they retrieve from the database:</p> <p>1. Project.objects.all(): This retrieves all instances of the Project model from the database. It returns a queryset, which is a list-like object containing all the instances.</p> <p>2. Project.objects.first(): This retrieves the first instance of the Project model from the database. It returns a single instance of the model, not a queryset.</p> <p>So, when you use <code>Project.objects.all()</code>, you get all instances of the Project model, and when you use <code>Project.objects.first()</code>, you get only the first instance.</p> all()first() <p>In the context of your IndexView class-based view, if you want to display all projects, you would typically use <code>Project.objects.all()</code> and iterate over them in your template using a loop. For example:</p> python<pre><code># Retrieve all projects\nprojects = Project.objects.all()\ncontext['projects'] = projects\n</code></pre> <p>Then in your template, you would loop through projects to display each project:</p> html<pre><code>{% for project in projects %}\n    &lt;h2&gt;{{ project.title }}&lt;/h2&gt;\n    &lt;p&gt;{{ project.description }}&lt;/p&gt;\n{% endfor %}\n</code></pre> <p>On the other hand, if you only need to display information about a single project (for instance, the first project), you could use <code>Project.objects.first()</code>:</p> python<pre><code># Retrieve the first project\nfirst_project = Project.objects.first()\ncontext['first_project'] = first_project\n</code></pre> <p>And then in your template, you would display information about this single project:</p> html<pre><code>&lt;h2&gt;{{ first_project.title }}&lt;/h2&gt;\n&lt;p&gt;{{ first_project.description }}&lt;/p&gt;\n</code></pre> <p>So, to summarize:</p> <ul> <li>Use <code>Project.objects.all()</code> when you want to retrieve and display all instances of the Project model.</li> <li>Use <code>Project.objects.first()</code> when you only need to retrieve and display information about the first instance of the Project model.</li> <li>If you use <code>Project.objects.all()</code>, you typically need to loop through the queryset in your template to display each project.</li> </ul>"},{"location":"backend/django/intro/#reference","title":"Reference","text":"Note <ul> <li> <p>Django in Action MEAP V01 by Christopher Trudeau - Manning publication</p> </li> <li> <p>Django Popular Apps</p> </li> <li> <p>18 Django Apps To Build And Ship a Product Quickly</p> </li> <li>Django Packages</li> <li>10 Django Packages Every Developer Must Know</li> <li>The 15 Best Django Packages for Your Application </li> <li>Top 12 Django Packages and Libraries</li> </ul> <ul> <li>django apps : github</li> <li> <p>django change default runserver port</p> </li> <li> <p>Django Best Practices: Code Structure, Naming Conventions, and Design Patterns</p> </li> </ul> <ul> <li>Books</li> <li>Mastering Django by Nigel George - 2022</li> <li>Web Development with Django - 2023</li> </ul>"},{"location":"backend/django/migration/","title":"django migrations","text":""},{"location":"backend/django/migration/#reference","title":"Reference","text":"<ul> <li>django.db.utils.IntegrityError: (1062, \"Duplicate entry '' for key 'slug'\")</li> </ul>"},{"location":"backend/django/advanced/django-celery/","title":"django celery","text":"<p>Install Celery and Redis</p> <p>Celery requires a message broker to send and receive messages. Redis is a common choice. Install Celery and Redis using pip:</p> <pre><code>pip install celery redis\n</code></pre>"},{"location":"backend/django/advanced/django-celery/#example-scenarios-for-using-celery","title":"Example Scenarios for Using <code>Celery</code>","text":"Example Example 1Example 2Monitoring Celery Tasks <p>Example 1: Sending an Email Notification</p> <p>When a user signs up on your platform, you might want to send them a welcome email. Sending the email can take some time, especially if the email server is slow or the network is congested. Using Celery, you can offload the email sending process to a background task:</p> tasks.py<pre><code>from celery import shared_task\nfrom django.core.mail import send_mail\n\n@shared_task\ndef send_welcome_email(user_id):\n    from django.contrib.auth.models import User\n    user = User.objects.get(id=user_id)\n    send_mail(\n        'Welcome!',\n        'Thank you for signing up, {}'.format(user.username),\n        'from@example.com',\n        [user.email],\n        fail_silently=False,\n    )\n</code></pre> views.py<pre><code>from django.shortcuts import render, redirect\nfrom django.contrib.auth.models import User\nfrom .tasks import send_welcome_email\n\ndef signup(request):\n    if request.method == 'POST':\n        username = request.POST['username']\n        email = request.POST['email']\n        password = request.POST['password']\n        user = User.objects.create_user(username, email, password)\n        send_welcome_email.delay(user.id)\n        return redirect('home')\n    return render(request, 'signup.html')\n</code></pre> <p>Example 2: Generating a Report</p> <p>Generating a detailed report based on user data can be time-consuming. Using Celery, you can generate the report in the background and notify the user when it's ready:</p> <p>```python \"tasks.py\" from celery import shared_task import time</p> <p>@shared_task def generate_report(user_id):     # Simulate a long-running task     time.sleep(10)     return 'Report for user {}'.format(user_id) </p><pre><code>```python title=\"views.py\"\nfrom django.shortcuts import render\nfrom django.http import JsonResponse\nfrom .tasks import generate_report\n\ndef request_report(request):\n    if request.method == 'POST':\n        user_id = request.user.id\n        result = generate_report.delay(user_id)\n        return JsonResponse({'task_id': result.id})\n    return render(request, 'request_report.html')\n</code></pre> <p>Celery provides several tools for monitoring and managing tasks:</p> <ol> <li> <p>Flower: A real-time web-based monitoring tool for Celery.</p> <ul> <li>Install Flower: <code>pip install flower</code></li> <li>Run Flower: <code>celery -A myproject flower</code></li> <li>Access Flower: Navigate to <code>http://localhost:5555/</code> in your web browser.</li> </ul> </li> <li> <p>Celery Events: Built-in command-line tool for monitoring.</p> <ul> <li>Run Celery Events: celery -A myproject events</li> </ul> </li> </ol> <p>Summary</p> <p>Celery is an essential tool for handling asynchronous tasks in Django applications. It is particularly useful for long-running tasks, I/O bound tasks, scheduled tasks, real-time updates, resource-intensive tasks, integration with external APIs, and tasks that require retry mechanisms. By offloading such tasks to Celery, you can improve the responsiveness, scalability, and maintainability of your Django applications.</p>"},{"location":"backend/django/advanced/django-channels/","title":"django channels","text":"Tip InstallationTheoryAdditionalLogo <pre><code>pip install django\npip install channels\npip install daphne\npip install channels_redis\n\n# or\npip install django channels daphne\n\n# Start the Daphne server:\ndaphne -p 8005 myproject.asgi:application\n</code></pre> settings.py<pre><code>INSTALLED_APPS = [\n    # ...\n    'channels',\n    # ...\n]\n\n# WSGI application\nWSGI_APPLICATION = 'your_project_name.wsgi.application'\n\n# ASGI application\nASGI_APPLICATION = 'your_project_name.asgi.application'\n\n# Channels layer backend\nCHANNEL_LAYERS = {\n    'default': {\n        'BACKEND': 'channels_redis.core.RedisChannelLayer',\n        'CONFIG': {\n            \"hosts\": [('127.0.0.1', 6379)],\n        },\n    },\n}\n</code></pre> <pre><code>asgi.py\nrouting.py\nconsumers.py\n</code></pre> <p>Channels is a Django extension that allows us to use protocols other than HTTP. The Django team, knowing the existing limitations of including other protocols, had to create a new server called Daphne that is natively compatible with the Asynchronous Server Gateway Interface (ASGI), an update of the Web Server Gateway Interface (WSGI). Without Channels, it would be impossible to have the WebSockets protocol.</p> <p>Why Do We Need WebSockets?</p> <p>WebSockets are essential for enabling real-time, two-way communication between a client and a server. Traditional HTTP protocols are request-response based, which means a client must send a request and wait for a response from the server. This model is not ideal for applications requiring real-time updates, such as chat applications, live sports scores, online gaming, or collaborative tools.</p> <p>Problems Solved by WebSockets</p> <ol> <li>Real-Time Communication: WebSockets allow for instantaneous data transfer between client and server without the need for repeated HTTP requests.</li> <li>Efficiency: Once a WebSocket connection is established, it remains open, reducing the overhead of establishing new connections and improving the efficiency of data transfer.</li> <li>Low Latency: WebSockets reduce the latency of data transfer compared to HTTP, which is crucial for applications where timing is critical.</li> <li>Bi-Directional Communication: Unlike HTTP, where the client always initiates communication, WebSockets support two-way communication, allowing the server to push updates to the client.</li> </ol> <p>When to Use WebSockets</p> <ol> <li>Chat Applications: For real-time messaging between users.</li> <li>Live Notifications: For pushing updates such as news alerts, notifications, or messages.</li> <li>Real-Time Gaming: For synchronizing game states and user actions in multiplayer games.</li> <li>Collaborative Tools: For live updates in collaborative documents or whiteboards.</li> <li>Financial Tickers: For real-time stock or cryptocurrency price updates.</li> </ol> <p></p> <p>Sure, let's create a real-time example of push notifications in Django using Django Channels and Daphne. We'll set up a simple project where messages sent from one client are broadcast to all connected clients in real time.</p> Example"},{"location":"backend/django/advanced/django-channels/#step-by-step-guide","title":"Step-by-Step Guide","text":"<ol> <li> <p>Install Required Packages</p> <p>First, install <code>Django</code> and <code>Django Channels</code>:</p> <p>bash</p> <pre><code>pip install django channels daphne\n</code></pre> </li> <li> <p>Create Django Project and Application</p> <p>Create a new Django project and an application within it:</p> <p>bash</p> <pre><code>django-admin startproject myproject\ncd myproject\ndjango-admin startapp myapp\n</code></pre> </li> <li> <p>Configure Django Channels</p> <p>Edit <code>myproject/settings.py</code> to include channels in your <code>INSTALLED_APPS</code> and configure the ASGI application and channel layers:</p> <p>settings.py</p> <pre><code>INSTALLED_APPS = [\n    ...\n    'channels',\n    ...\n    # Other installed apps\n    'myapp',\n]\n\nASGI_APPLICATION = 'myproject.asgi.application'\n\nCHANNEL_LAYERS = {\n    'default': {\n        'BACKEND': 'channels.layers.InMemoryChannelLayer',\n    },\n}\n</code></pre> </li> <li> <p>Create ASGI Configuration</p> <p>Create an <code>asgi.py</code> file in your project directory:</p> myproject/asgi.py<pre><code>import os\nfrom django.core.asgi import get_asgi_application\nfrom channels.routing import ProtocolTypeRouter, URLRouter\nfrom channels.auth import AuthMiddlewareStack\nimport myapp.routing\n\nos.environ.setdefault('DJANGO_SETTINGS_MODULE', 'myproject.settings')\n\napplication = ProtocolTypeRouter({\n    \"http\": get_asgi_application(),\n    \"websocket\": AuthMiddlewareStack(\n        URLRouter(\n            myapp.routing.websocket_urlpatterns\n        )\n    ),\n})\n</code></pre> </li> <li> <p>Define WebSocket Routing</p> <p>Create a <code>routing.py</code> file in your myapp directory:</p> myapp/routing.py<pre><code>from django.urls import re_path\nfrom . import consumers\n\nwebsocket_urlpatterns = [\n    re_path(r'ws/notifications/$', consumers.NotificationConsumer.as_asgi()),\n]\n</code></pre> </li> <li> <p>Create a Consumer</p> <p>Create a <code>consumers.py</code> file in your myapp directory:</p> myapp/consumers.py<pre><code>import json\nfrom channels.generic.websocket import AsyncWebsocketConsumer\n\nclass NotificationConsumer(AsyncWebsocketConsumer):\n    async def connect(self):\n        await self.channel_layer.group_add(\"notifications\", self.channel_name)\n        await self.accept()\n\n    async def disconnect(self, close_code):\n        await self.channel_layer.group_discard(\"notifications\", self.channel_name)\n\n    async def receive(self, text_data):\n        data = json.loads(text_data)\n        message = data['message']\n\n        await self.channel_layer.group_send(\n            \"notifications\",\n            {\n                'type': 'send_notification',\n                'message': message\n            }\n        )\n\n    async def send_notification(self, event):\n        message = event['message']\n        await self.send(text_data=json.dumps({\n            'message': message\n        }))\n</code></pre> </li> <li> <p>Set Up URLs</p> <p>Create the app's <code>urls.py</code> file:</p> myapp/urls.py<pre><code>from django.urls import path\nfrom . import views\n\nurlpatterns = [\n    path('', views.index, name='index'),  # This will render the HTML page\n]\n</code></pre> <p>Update the project-level urls.py:</p> myproject/urls.py<pre><code>from django.contrib import admin\nfrom django.urls import path, include\n\nurlpatterns = [\n    path('admin/', admin.site.urls),\n    path('', include('myapp.urls')),  # Include app URLs\n]\n</code></pre> </li> <li> <p>Create a View</p> <p>Create a simple view to render the <code>index.html</code>:</p> myapp/views.py<pre><code>from django.shortcuts import render\n\ndef index(request):\n    return render(request, 'index.html')\n</code></pre> </li> <li> <p>Create a Simple Frontend</p> <p>Create an <code>index.html</code> file in a templates directory inside your myapp directory:</p> myapp/templates/index.html<pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;title&gt;Push Notifications&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;h1&gt;Push Notifications Example&lt;/h1&gt;\n    &lt;div id=\"notifications\"&gt;&lt;/div&gt;\n    &lt;input type=\"text\" id=\"messageInput\" placeholder=\"Enter a message\"&gt;\n    &lt;button onclick=\"sendMessage()\"&gt;Send&lt;/button&gt;\n\n    &lt;script&gt;\n        const ws = new WebSocket('ws://' + window.location.host + '/ws/notifications/');\n\n        ws.onmessage = function(event) {\n            const data = JSON.parse(event.data);\n            const notificationsDiv = document.getElementById('notifications');\n            notificationsDiv.innerHTML += '&lt;p&gt;' + data.message + '&lt;/p&gt;';\n        };\n\n        function sendMessage() {\n            const messageInput = document.getElementById('messageInput');\n            const message = messageInput.value;\n            ws.send(JSON.stringify({ 'message': message }));\n            messageInput.value = '';\n        }\n    &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre> </li> </ol> <p>Running the Server</p> <ol> <li> <p>Run the Daphne server: Start the Daphne server to handle HTTP and WebSocket connections:</p> bash<pre><code>daphne -p 8000 myproject.asgi:application\n</code></pre> </li> <li> <p>Navigate to the site: Open your browser and go to http://localhost:8000/. You should see the HTML page with an input box and a button.</p> </li> <li> <p>Test the real-time notifications:</p> <ul> <li>Open multiple browser tabs or windows to <code>http://localhost:8000/</code>.</li> <li>Enter a message in the input box and click the \"Send\" button.</li> <li>The message should appear in real-time on all open tabs or windows.</li> </ul> </li> </ol> <p>Summary</p> <p>This example demonstrates how to set up real-time push notifications in a Django project using Django Channels and Daphne. The steps include configuring Django Channels, setting up ASGI, defining WebSocket routing, creating a WebSocket consumer, and building a simple frontend to send and receive messages in real-time. By following these steps, you can implement real-time communication in your Django applications.</p>"},{"location":"backend/django/advanced/django-channels/#reference","title":"Reference","text":"<ul> <li>Django Channels \u2013 Introduction and Basic Setup: geeksforgeeks</li> <li>channels: readthedocs</li> <li>Introduction to Django Channels and WebSockets: medium</li> <li>Guide to Django Channels: What it is, pros and cons and use cases</li> </ul>"},{"location":"backend/django/advanced/django-hardening/","title":"Django Hardening","text":""},{"location":"backend/django/advanced/django-hardening/#django-hardening","title":"Django Hardening","text":"<p>Django is one of the most secure web frameworks out there.</p> <p>Django hardening refers to the process of securing a Django web application by implementing various measures to mitigate potential security risks and vulnerabilities. These measures aim to protect the application and its data from unauthorized access, data breaches, and other security threats.</p> <p>However, it\u2019s easy to let things slip out, especially when we are in a hurry to see our project up and running in production. Before exposing our website or our API to the world, we need to take care of some extra details to avoid surprises.</p>"},{"location":"backend/django/advanced/django-hardening/#django-settings-for-production","title":"Django Settings for Production","text":"<p>In Chapter 5, in the Splitting the Settings File section, we configured our Django project to use different settings for each environment. As of now, we have the following settings:</p> <pre><code>decoupled_dj/settings/base.py\ndecoupled_dj/settings/development.py\n</code></pre> <p>To prepare the project for production, we create another settings file in <code>decoupled_dj/settings/production.py</code>, which will hold all the production-related settings. What should go in this file? Some of the most important settings for production in Django are:</p>"},{"location":"backend/django/advanced/django-hardening/#authentication-and-cookies-in-django","title":"Authentication and Cookies in Django","text":"<p><code>decoupled_dj/settings/production.py</code> - Securing Authentication Cookies</p> <pre><code>...\nCSRF_COOKIE_SECURE = True\nSESSION_COOKIE_SECURE = True\n...\n</code></pre> <p>With <code>CSRF_COOKIE_SECURE</code> and <code>SESSION_COOKIE_SECURE</code> set to True, we ensure that session authentication related cookies are transmitted only over HTTPS.</p>"},{"location":"backend/django/advanced/django-hardening/#randomize-the-admin-url","title":"Randomize the Admin URL","text":"<p>The <code>built-in</code> admin panel is probably one of the most beloved Django features.</p> <p>However, the URL for this panel, which by default is <code>admin/</code>, can be targeted by automated brute force attacks when the website is exposed online. To mitigate the issue, we can introduce a bit of randomness in the URL, by changing it to something not easily guessable.</p> Python<pre><code>from django.urls import path, include\nfrom django.contrib import admin\nfrom django.conf import settings\n\nurlpatterns = [\n    path(\"billing/\", include(\"billing.urls\", namespace=\"billing\")),\n]\n\nif settings.DEBUG:\n    urlpatterns = [\n        path(\"admin/\", admin.site.urls),\n    ] + urlpatterns\n\nif not settings.DEBUG:\n    urlpatterns = [\n        path(\"77randomAdmin@33/\", admin.site.urls),\n    ] + urlpatterns\n</code></pre> <p>This code tells Django to change the admin URL from <code>admin/</code> to <code>77randomAdmin@33/</code> when DEBUG is False. With this little change, we add a bit more protection to the admin panel. Let\u2019s now see what we can do to improve the security of our REST API.</p>"},{"location":"backend/django/advanced/django-hardening/#reference","title":"Reference","text":"<ul> <li>Decoupled Django by Valentino Gagliardi</li> </ul>"},{"location":"backend/django/advanced/django-signals/","title":"django signals","text":"<p>Signals are a <code>built-in</code> feature of the Django framework. </p> <p></p> <p>Note</p> BasicWhen to use it?When not to use it?Best PracticesExample <p>There are three types of signals as follows:</p> <ul> <li>preserve and postsave: These signals execute before and after the <code>save()</code> method.</li> <li>predelete and postdelete: These signals execute before and after the <code>delete()</code> method.</li> <li>preinit and postinit: These signals execute before and after instantiating the model.</li> </ul> <p>Django\u2019s built-in signals let user code get notified of certain actions.</p> <p>Django Signals are useful in scenarios where you want to decouple certain behaviors from your main application logic. Here are some common scenarios where signals can be beneficial:</p> <ol> <li> <p>User Registration and Authentication:</p> <ul> <li>Welcome Emails: Automatically send a welcome email when a new user registers.</li> <li>Profile Creation: Create a user profile automatically when a new user account is created.</li> </ul> </li> <li> <p>Logging and Auditing:</p> <ul> <li>Activity Logs: Log user activities, such as login/logout events or changes to important models.</li> <li>Audit Trails: Track changes to critical data for compliance or debugging purposes.</li> </ul> </li> <li> <p>Notifications:</p> <ul> <li>Real-Time Updates: Send notifications when certain events occur, such as new messages, comments, or task assignments.</li> <li>Email/SMS Alerts: Notify administrators or users of significant events like system errors or account issues.</li> </ul> </li> <li> <p>Data Integrity and Consistency:</p> <ul> <li>Related Models: Ensure consistency between related models. For example, updating related records when a primary record changes.</li> <li>Automatic Calculations: Automatically update aggregate values, such as recalculating a user\u2019s total points when they complete a task.</li> </ul> </li> <li> <p>Background Tasks:</p> <ul> <li>Delayed Processing: Trigger background tasks using Celery or another task queue to handle resource-intensive operations without blocking the main application.</li> </ul> </li> </ol> <p>While signals are powerful, they can introduce complexity and hidden dependencies if not used carefully. Here are scenarios where it might be better to avoid signals:</p> <ol> <li> <p>Complex Business Logic:</p> <ul> <li>Readability: If the logic within your signal handlers becomes complex, it can make your code harder to understand and maintain. Consider keeping complex business logic within views or services.</li> </ul> </li> <li> <p>Performance-Critical Tasks:</p> <ul> <li>Overhead: Signals add an extra layer of function calls, which might introduce performance overhead. For high-performance applications, inline processing might be more efficient.</li> <li>Synchronous Execution: By default, signal handlers execute synchronously. For tasks that can slow down your request-response cycle, consider using Celery for asynchronous processing.</li> </ul> </li> <li> <p>Tight Coupling:</p> <ul> <li>Dependencies: Signals can lead to tight coupling between different parts of your application if overused. This can make it harder to track dependencies and debug issues.</li> <li>Testing Complexity: Signals can make unit testing more difficult because they introduce side effects. Ensure you have thorough tests for any signal-related functionality.</li> </ul> </li> <li> <p>Event-Driven Architecture:</p> <ul> <li>Event Systems: For large applications requiring extensive event-driven architecture, a dedicated event system like Apache Kafka or RabbitMQ might be more appropriate than Django\u2019s signals.</li> </ul> </li> </ol> <p>Summary: Best Practices</p> <ul> <li>Keep It Simple: Use signals for straightforward tasks like sending notifications or logging events.</li> <li>Maintain Readability: Avoid putting complex business logic in signal handlers. Keep handlers small and focused.</li> <li>Use Asynchronous Processing: Offload heavy or long-running tasks to a task queue like Celery.</li> <li>Ensure Decoupling: Be mindful of creating hidden dependencies. Ensure that the application remains easy to understand and maintain.</li> <li>Thorough Testing: Write comprehensive tests for signal handlers to ensure they work as expected and handle edge cases.</li> </ul> <p>Example Scenario: When to Use and Not Use Signals</p> <p>Use Signals:</p> <ul> <li>Automatically sending a welcome email when a new user registers.</li> <li>Logging when a user logs in or logs out.</li> </ul> <pre><code># myapp/signals.py\nfrom django.db.models.signals import post_save\nfrom django.contrib.auth.models import User\nfrom django.dispatch import receiver\nfrom django.core.mail import send_mail\n\n@receiver(post_save, sender=User)\ndef send_welcome_email(sender, instance, created, **kwargs):\n    if created:\n        send_mail(\n            'Welcome to Our Site',\n            'Thank you for registering!',\n            'from@example.com',\n            [instance.email],\n            fail_silently=False,\n        )\n</code></pre> <p>Avoid Signals:</p> <ul> <li>Complex business rules for calculating user scores based on multiple criteria.</li> <li>Performance-intensive tasks like generating large reports on data updates.</li> </ul> <p>For complex logic or performance-intensive tasks, encapsulate the logic in a service layer or use a background task queue like Celery:</p> <pre><code># Use Celery for background tasks\n# tasks.py\nfrom celery import shared_task\nfrom django.core.mail import send_mail\n\n@shared_task\ndef send_welcome_email(user_email):\n    send_mail(\n        'Welcome to Our Site',\n        'Thank you for registering!',\n        'from@example.com',\n        [user_email],\n        fail_silently=False,\n    )\n\n# Call the task from a view or another part of your application\nsend_welcome_email.delay(user.email)\n</code></pre> <p>By following these guidelines, you can effectively use Django Signals to enhance your application while avoiding common pitfalls.</p> <p></p>"},{"location":"backend/django/advanced/django-signals/#reference","title":"Reference","text":"<ul> <li>Signals Topics: Official</li> <li> <p>Signals Ref: Official</p> </li> <li> <p>Django Signals mastery </p> </li> <li>When to Use Django Signals</li> <li>Understanding Signals in Django</li> <li>Django Signals</li> <li> <p>Introduction to Django Signals: educba.com</p> </li> <li> <p>chatgpt</p> </li> </ul>"},{"location":"backend/django/advanced/django-tools/","title":"Django Tool","text":""},{"location":"backend/django/advanced/django-tools/#testing-urls","title":"Testing URLs:","text":"<p>You can test URLs using <code>Django's test client</code> to see how your views respond to different requests. For example:</p> <p>Example</p> <pre><code>&gt;&gt;&gt; from django.test import Client\n&gt;&gt;&gt; client = Client()\n&gt;&gt;&gt; response = client.get('/myapp/myurl/')\n&gt;&gt;&gt; print(response.status_code)\n</code></pre> Note <p>In your settings.py, locate the ALLOWED_HOSTS setting and add 'testserver' to the list. If you're using the wildcard '*', make sure 'testserver' is included there.</p> <pre><code># settings.py\n\nALLOWED_HOSTS = ['yourdomain.com', 'testserver']\n</code></pre> <p>By adding 'testserver' to the ALLOWED_HOSTS setting, Django will allow requests with the HTTP_HOST header set to 'testserver' during testing.</p>"},{"location":"backend/django/advanced/django-tools/#using-django-extensions","title":"Using Django Extensions:","text":"<p>Install and utilize Django Extensions, a package that adds various useful functionalities to Django, including shell_plus, which loads all models into the shell namespace to make interacting with them easier.</p> bash<pre><code>$ pip install django-extensions\n$ python manage.py shell_plus\n</code></pre> <p>To enable django_extensions in your project you need to add it to <code>INSTALLED_APPS</code> in your projects <code>settings.py</code> file:</p> <pre><code>INSTALLED_APPS = (\n    ...\n    'django_extensions',\n    ...\n)\n</code></pre>"},{"location":"backend/django/advanced/django-tools/#django-debug-toolbar","title":"Django Debug Toolbar:","text":"<p>Install and use Django Debug Toolbar to analyze and optimize your application during development.</p> bash<pre><code>$ pip install django-debug-toolbar\n</code></pre> <p>Then, add it to your <code>INSTALLED_APPS</code> and configure it properly in your settings file.</p> <pre><code>INSTALLED_APPS = [\n    # ...\n    \"debug_toolbar\",\n    # ...\n]\n</code></pre>"},{"location":"backend/django/advanced/django-tools/#reference","title":"Reference","text":"<ul> <li> <p>Documentation: Testing tools</p> </li> <li> <p>Django Extensions</p> </li> <li>django-extensions: github</li> <li>django-debug-toolbar: readthedocs.io</li> </ul>"},{"location":"backend/django/advanced/intro/","title":"Intro","text":"Django Advanced Topic <p>Django is a robust and feature-rich framework that provides many advanced features for building complex web applications. Below are some of the advanced topics in Django, including <code>signals</code> and <code>channels</code>, as well as others like <code>middleware</code>, <code>forms</code>, <code>custom model managers</code>, and more.</p>"},{"location":"backend/django/advanced/intro/#advanced-topics-in-django","title":"Advanced Topics in Django","text":"<ol> <li> <p>Django Signals</p> <ul> <li>Overview: Signals are a way to allow decoupled applications to get notified when certain events occur elsewhere in the application.</li> <li>Common Use Cases: User creation, email notifications, logging.</li> <li>Example:</li> </ul> <pre><code># signals.py\n  from django.db.models.signals import post_save\n  from django.dispatch import receiver\n  from django.contrib.auth.models import User\n  from .models import Profile\n\n  @receiver(post_save, sender=User)\n  def create_profile(sender, instance, created, **kwargs):\n      if created:\n          Profile.objects.create(user=instance)\n\n  @receiver(post_save, sender=User)\n  def save_profile(sender, instance, **kwargs):\n      instance.profile.save()\n</code></pre> </li> <li> <p>Django Channels</p> <ul> <li>Overview: Extends Django to handle WebSockets, HTTP2, and other protocols that require long-lived connections.</li> <li>Common Use Cases: Real-time chat applications, notifications, live updates.</li> <li>Example: Refer to the previous example on WebSockets for setting up real-time notifications with Django Channels.</li> </ul> </li> <li> <p>Middleware</p> <ul> <li>Overview: Middleware is a way to process requests globally before they reach the view or after the view has processed them.</li> <li>Common Use Cases: Authentication, logging, request modification.</li> <li>Example:</li> </ul> <pre><code># middleware.py\nclass SimpleMiddleware:\n    def __init__(self, get_response):\n        self.get_response = get_response\n\n    def __call__(self, request):\n        # Code to be executed for each request before the view (and later middleware) are called.\n        response = self.get_response(request)\n        # Code to be executed for each request/response after the view is called.\n        return response\n</code></pre> </li> <li> <p>Custom Model Managers</p> <ul> <li>Overview: Managers are the interface through which database query operations are provided to Django models.</li> <li>Common Use Cases: Adding extra manager methods, customizing queryset behavior.</li> <li>Example:</li> </ul> <pre><code>from django.db import models\n\nclass PublishedManager(models.Manager):\n    def get_queryset(self):\n        return super().get_queryset().filter(status='published')\n\nclass Post(models.Model):\n    STATUS_CHOICES = (\n        ('draft', 'Draft'),\n        ('published', 'Published'),\n    )\n    title = models.CharField(max_length=200)\n    status = models.CharField(max_length=10, choices=STATUS_CHOICES)\n\n    objects = models.Manager()  # The default manager.\n    published = PublishedManager()  # Our custom manager.\n</code></pre> </li> <li> <p>Custom Forms and Formsets</p> <ul> <li>Overview: Django forms handle user input and validation. Formsets allow handling multiple forms on a single page.</li> <li>Common Use Cases: Complex form processing, multiple related forms.</li> <li>Example:</li> </ul> <pre><code>from django import forms\nfrom .models import Post\n\nclass PostForm(forms.ModelForm):\n    class Meta:\n        model = Post\n        fields = ['title', 'content']\n\nfrom django.forms import formset_factory\nPostFormSet = formset_factory(PostForm, extra=2)\n</code></pre> </li> <li> <p>Custom Template Tags and Filters</p> <ul> <li>Overview: Template tags and filters allow custom functionalities in Django templates.</li> <li>Common Use Cases: Custom formatting, reusable template logic.</li> <li>Example:</li> </ul> <pre><code># templatetags/custom_tags.py\nfrom django import template\n\nregister = template.Library()\n\n@register.filter(name='cut')\ndef cut(value, arg):\n    return value.replace(arg, '')\n\n@register.simple_tag\ndef current_time(format_string):\n    return datetime.datetime.now().strftime(format_string)\n</code></pre> </li> </ol>"},{"location":"backend/django/advanced/intro/#reference","title":"Reference","text":"<ul> <li>The A to Z of Advanced Django</li> </ul>"},{"location":"backend/django/advanced/shortcuts/","title":"Shortcuts","text":""},{"location":"backend/django/advanced/shortcuts/#django-shortcuts","title":"Django Shortcuts","text":"<p>Django shortcuts module is a collection of helper functions that are generally used in view function/classes. There are many shortcuts available in module  <code>django.shortcuts</code>. In other words, these function/classes introduce controlled coupling for convenience's sake.</p> <p>Example</p> render()redirect()get_object_or_404()get_list_or_404() <p>It combines a given template with a dictionary and returns the HttpResponse object with that rendered text. Following is the syntax of the render() function.</p> <pre><code>from django.shortcuts import render  \ndef new_view(request):  \n    # View code here...  \n    return render(\n        request, 'newapp/index.html',\n        {  \n        'foo': 'bar',  \n        }, \n        content_type='application/xhtml+xml'\n        )\n</code></pre> <p>It is equivalent to the below code.</p> <pre><code>def new_view(request):  \n    # View code here...  \n    t = loader.get_template('newapp/index.html')  \n    c = {'foo': 'bar'}  \n    return HttpResponse(t.render(c, request), content_type='application/xhtml+xml') \n</code></pre> <p>The redirect() function is used to redirect to the specific URL. It returns an HttpResponseRedirect to the appropriate URL for the argument passed. Let's see the following syntax.</p> <p>Syntax</p> <pre><code>redirect(to, *args, permanent=False, **kwargs)  \n</code></pre> <pre><code>def blog_view(request, post_id):  \n    blog = Post.objects.get(pk=post_id)  \n    return redirect(blog)  \n    # equivalent to: return HttpResponseRedirect(blog.get_absolute_url())  \n\ndef blog_view(request, post_id):  \n    return redirect('blog_details', id=post_id)  \n    # equivalent to: return HttpResponseRedirect(reverse('blog_details', args=(post_id, )))  \n\ndef relative_url_view(request):  \n    return redirect('/blogs/archive/')  \n    # equivalent to: return HttpResponseRedirect('/blogs/archive/')  \n</code></pre> <pre><code>\n</code></pre> <p>It returns the DoesNotExist exception if the searched object is not found. On the other hand, <code>get()</code> method raise Http404.</p> <pre><code>from django.shortcuts import get_object_or_404  \ndef my_view(request):  \n    obj = get_object_or_404(MyModel, pk=1)  \n</code></pre> <p>It is equivalent to:</p> <pre><code>from django.http import Http404   \ndef my_view(request):  \n    try:  \n            obj = MyModel.objects.get(pk=1)  \n    except MyModel.DoesNotExist:  \n            raise Http404(\"No MyModel matches the given query.\")  \n</code></pre> <p>It returns the results of <code>filter()</code> on a given model manager cast to a list, raising Http404 if the resulting list is empty. The syntax is same as get_object_or_404.</p> <pre><code>from django.shortcuts import get_list_or_404  \ndef my_view(request):  \n    my_objects = get_list_or_404(MyModel, published=True)  \n</code></pre> <pre><code>from django.http import Http404  \ndef my_view(request):  \n    my_objects = list(MyModel.objects.filter(published=True))  \n    if not my_objects:  \n    raise Http404(\"No MyModel matches the given query.\")  \n</code></pre>"},{"location":"backend/django/advanced/shortcuts/#reference","title":"Reference","text":"<ul> <li>django shortcuts</li> </ul>"},{"location":"backend/django/builtin/class-based-views/","title":"generic views","text":""},{"location":"backend/django/builtin/class-based-views/#class-based-views","title":"class-based views","text":"<p>In Django, <code>View</code>, <code>TemplateView</code>, <code>ListView</code>, and <code>DetailView</code> are class-based views provided by Django's generic views framework. Each serves a specific purpose and can be used to handle different scenarios in web applications.</p> <p>Here's a brief overview of each:</p> <ol> <li> <p>View:</p> <p>The base class for all views in Django. It's a class-based approach for defining views in Django. You can subclass View and override its methods (get(), post(), etc.) to handle different HTTP methods.</p> </li> <li> <p>TemplateView:</p> <p>A generic class-based view that renders a template. It's useful for simple views that only need to render a template without any data processing. You specify the template name using the template_name attribute.</p> </li> <li> <p>ListView:</p> <p>A generic class-based view for displaying a list of objects from a queryset. It's commonly used for displaying paginated lists of objects, such as a list of blog posts or news articles. You specify the model and queryset using the model and queryset attributes.</p> </li> <li> <p>DetailView:</p> <p>A generic class-based view for displaying details of a single object. It's used for displaying detailed information about a specific object, such as a blog post or product details. You specify the model using the model attribute, and the view automatically retrieves the object based on the URL parameters.</p> </li> </ol> <p>Example</p> <pre><code>from django.views.generic import View, TemplateView, ListView, DetailView\nfrom .models import YourModel\n\nclass YourView(View):\n    def get(self, request, *args, **kwargs):\n        # Your view logic goes here\n        pass\n\nclass YourTemplateView(TemplateView):\n    template_name = 'your_template.html'\n\n    def get_context_data(self, **kwargs):\n        context = super().get_context_data(**kwargs)\n        # Add additional context data if needed\n        return context\n\nclass YourListView(ListView):\n    model = YourModel\n    queryset = YourModel.objects.all()  # Optionally, specify a queryset\n    template_name = 'your_list_template.html'\n    context_object_name = 'your_objects'  # Optionally, specify the context object name\n\nclass YourDetailView(DetailView):\n    model = YourModel\n    template_name = 'your_detail_template.html'\n    context_object_name = 'your_object'  # Optionally, specify the context object name\n    # Optionally, define additional context data or override other methods\n</code></pre> <p>Replace YourModel with the model you want to use, and <code>your_template.html</code>, <code>your_list_template.html</code>, and <code>your_detail_template.html</code> with the actual template names you're using.</p> <p>These are just basic examples, and you can customize each view by overriding methods or attributes as needed to fit your application's requirements.</p>"},{"location":"backend/django/builtin/class-based-views/#difference-between-view-and-templateview","title":"Difference between <code>View</code> and <code>TemplateView</code>","text":"<p>Sure, let's simplify the distinction between View and TemplateView with examples and scenarios for each:</p> <p>Example</p> ViewTemplateView <ol> <li> <p>View:</p> <p>Use Case:</p> <p>When you need to perform custom logic that doesn't directly involve rendering a template. This could include processing form submissions, interacting with external APIs, or performing complex business logic.</p> <p>Example: </p> <p>Suppose you have a contact form on your website. You might use a View to handle form submissions, validate input data, and send emails to the site administrator.</p> <pre><code>from django.views import View\nfrom django.http import HttpResponse\n\nclass ContactView(View):\n    def post(self, request):\n        # Process form submission and send email\n        return HttpResponse(\"Thank you for contacting us!\")\n</code></pre> </li> </ol> <ol> <li> <p>TemplateView:</p> <p>Use Case: </p> <p>When you simply need to render a template without any additional logic. This is useful for static pages, such as an about page, a homepage, or a contact page where you only need to display content from a template.</p> <p>Example:</p> <p>Let's say you have a simple about page on your website. You might use a TemplateView to render the about page template without any additional processing.</p> <pre><code>from django.views.generic import TemplateView\n\nclass AboutView(TemplateView):\n    template_name = 'about.html'\n</code></pre> </li> </ol> <p>In summary:</p> <ul> <li>Use <code>View</code> when you need to perform custom logic, such as handling form submissions, interacting with databases, or executing complex business logic.</li> <li>Use <code>TemplateView</code> when you only need to render a template without any additional processing or logic. This is useful for static pages or simple views that primarily serve to display content.</li> </ul> <p>In many cases, you'll use a combination of both View and TemplateView depending on the requirements of your web application. If a view involves both custom logic and rendering a template, you might start with a View and later refactor it to a TemplateView if the logic becomes simpler and you only need to render a template.</p>"},{"location":"backend/django/builtin/django-contrib-admin/","title":"django contrib admin","text":"<p>Django comes with a built-in admin interface.</p>"},{"location":"backend/django/builtin/django-contrib-admin/#touring-the-django-admin","title":"Touring the Django Admin","text":"<p>As the name implies, the Django Admin\u2019s purpose is administering your website. Its interface isn\u2019t the prettiest, and its design is focused on users who control your site. Before using the Admin, you need to understand the basics of user permissions. Django is a multi-user framework, meaning you can create websites that have user accounts, and each account can be restricted to a subset of activities. Django has fine-grained permission control, and you can get quite specific about who can do what, but it also has a high-level mechanism that is good enough for most situations.</p> <p>Note</p> <p>Django divides users into three classes:</p> <ol> <li>General User </li> <li>Staff</li> <li>Admin</li> </ol> <p>Django in Action MEAP V01</p>"},{"location":"backend/django/builtin/django-contrib-admin/#django-manager","title":"Django Manager","text":"<p>Django Manager</p> <p>In Django, a Manager is a class that provides methods for querying the database and performing <code>CRUD</code> (<code>Create</code>, <code>Read</code>, <code>Update</code>, <code>Delete</code>) operations on model instances. Every Django model has at least one Manager, and the default Manager is named objects.</p> <p>The objects Manager provides several methods to interact with the database. Here are some commonly used methods:</p> <ul> <li>YourModel.objects.all()</li> <li>YourModel.objects.get(id=1)</li> <li>YourModel.objects.filter(field=value)</li> <li>YourModel.objects.exclude(field=value)</li> <li>YourModel.objects.order_by('-field')</li> <li>YourModel.objects.first()</li> <li>YourModel.objects.last()</li> <li>YourModel.objects.values('field1', 'field2')</li> </ul> <p>In the context of <code>databases</code> or <code>models</code>, entities typically refer to the objects or items that are represented and stored within the database. In a database management system, entities are often mapped to tables, and each row in the table represents a specific instance of that entity.</p> <p>In the context of <code>Django's models</code>, entities usually refer to the objects that you define using Django's Object-Relational Mapping (ORM). In Django, you define entities using model classes, which represent tables in the database. Each instance of a model class corresponds to a row in the respective table, and each attribute of the model class typically corresponds to a column in the table.</p> <p>For example, consider a simple Django model representing a user:</p> python<pre><code>from django.db import models\n\nclass User(models.Model):\n    username = models.CharField(max_length=100)\n    email = models.EmailField()\n</code></pre> <p>In this example, User is the entity, and it's represented by the model class User. The attributes username and email define the properties of this entity, which will be stored as columns in the database table representing the User entity.</p> <p>Entities play a crucial role in database design and modeling as they represent real-world objects or concepts within the system being developed. They help in organizing and structuring data in a way that reflects the relationships and behaviors of the system's components.</p>"},{"location":"backend/django/builtin/django-contrib-admin/#rename-model-name-in-django-admin","title":"Rename model name in django admin","text":"<p>Example</p> <p>To rename the model name in the Django admin interface, you can use the verbose_name and verbose_name_plural attributes in the model's Meta class. Here's how you can do it:</p> Python<pre><code>from django.db import models\n\nclass ServiceItem(models.Model):\n    title = models.CharField(max_length=120)\n    description = models.TextField(null=True, blank=True)\n    image = models.ImageField(null=True, blank=True, upload_to=\"service/\")\n\n    class Meta:\n        db_table = \"bishow_service_item\"\n        verbose_name = \"Custom Service Item\"\n        verbose_name_plural = \"Custom Service Items\"\n</code></pre> <p>With this setup, in the Django admin interface, instead of \"Service Items\", you'll see \"Custom Service Items\" as the plural name, and instead of \"Service Item\", you'll see \"Custom Service Item\" as the singular name.</p> <code>list_display</code> attribute in a Django ModelAdmin class IntroDetail <p>The list_display attribute in a Django ModelAdmin class is used to specify which fields of the model should be displayed in the list view of the Django admin interface.</p> <p>When you register a model with the Django admin site, it provides a default list view where it shows a list of objects of that model. By default, Django admin will display a representation of each object that just says \"object\" followed by its primary key (e.g., \"<code>About object (1)</code>\").</p> <p>By specifying <code>list_display</code>, you're telling Django admin to customize this default list view by displaying specific fields from your model instead of just the default representation.</p> <p>For example, in your AboutAdmin class:</p> <pre><code>from django.contrib import admin\nfrom .models import About\n\nclass AboutAdmin(admin.ModelAdmin):\n    list_display = ('title', 'description')\n</code></pre> <p>You've specified that in the list view for the About model, Django admin should display the title and description fields of each object.</p> <p>This provides a more informative and user-friendly view of the data in the admin interface, making it easier for administrators to browse and manage the data.</p> <p>Confirm that the AboutAdmin class is correctly registered with the About model. It should look like this:</p> <pre><code>admin.site.register(About, AboutAdmin)\n</code></pre> <p>\"what is <code>list_display</code> attribute?\"</p> <p>In Django, the list_display attribute in a ModelAdmin class is a sequence (typically a tuple) of field names, specifying which fields of the model should be displayed in the list view of the Django admin interface.</p> <p>While you can use either a list or a tuple, it's a convention in Django to use a tuple for list_display. This is because list_display is not expected to be mutable; it's defining the structure of the admin interface, which should remain consistent.</p> <p>However, since Python allows both lists and tuples to be used in most contexts interchangeably, you can technically use either. Here's an example showing list_display being defined with both a list and a tuple:</p> Python<pre><code># Using a tuple\nclass MyModelAdmin(admin.ModelAdmin):\n    list_display = ('field1', 'field2', 'field3')\n\n# Using a list (not recommended, but works)\nclass MyModelAdmin(admin.ModelAdmin):\n    list_display = ['field1', 'field2', 'field3']\n</code></pre> <p>Both of the above are valid and will achieve the same result. However, using a tuple is more consistent with Django's style and intent for list_display.</p>"},{"location":"backend/django/builtin/django-contrib-admin/#preview-image-in-admin-column","title":"Preview image in admin column","text":"how to display a <code>preview</code> of the image directly in the Django admin interface <p>If you want to display a preview of the image directly in the Django admin interface without using an HTML <code>&lt;img&gt;</code> tag, you can utilize Django's built-in functionality to generate thumbnail previews of images. Django's ImageField provides a Thumbnail widget that automatically generates a thumbnail preview for images.</p> <p>Here's how you can implement it:</p> Python<pre><code>from django.contrib import admin\nfrom django.utils.safestring import mark_safe\nfrom .models import About\n\nclass AboutAdmin(admin.ModelAdmin):\n    list_display = ('title', 'description', 'display_image')\n\n    def display_image(self, obj):\n        if obj.image:\n            return mark_safe('&lt;img src=\"{}\" width=\"100\" height=\"100\" /&gt;'.format(obj.image.url))\n        else:\n            return 'No Image'\n    display_image.short_description = 'Image Preview'\n\nadmin.site.register(About, AboutAdmin)\n</code></pre> <p>In this code:</p> <ul> <li>We still define the display_image method to return an image tag.</li> <li>We use Django's mark_safe function to mark the string as safe HTML. This is necessary to prevent Django from escaping the HTML when rendering.</li> <li>If there is no image associated with the About object, we return a text saying \"No Image\".</li> <li>The <code>display_image</code> method is assigned to the list_display attribute to display the image preview along with other fields.</li> </ul> <p>With this setup, the Django admin list view for the About model will display a preview of the image (if available) directly in the interface. If there's no image, it will display \"No Image\". Adjust the width and height attributes as needed to control the size of the displayed images.</p> <p>Abstract</p> <p>To reuse the display_image method without duplicating code, you can define it as a static method and use it across multiple ModelAdmin classes. Here's how you can refactor your code:</p> Python<pre><code>from django.contrib import admin\nfrom django.utils.safestring import mark_safe\nfrom .models import About, Project, ProjectItem\n\nclass ImageDisplayMixin:\n    @staticmethod\n    def display_image(obj):\n        if obj.image:\n            return mark_safe('&lt;img src=\"{}\" width=\"100\" height=\"100\" /&gt;'.format(obj.image.url))\n        else:\n            return 'No Image'\n    display_image.short_description = 'Image Preview'\n\nclass AboutAdmin(admin.ModelAdmin, ImageDisplayMixin):\n    list_display = ('title', 'description', 'display_image')\n\nclass ProjectAdmin(admin.ModelAdmin):\n    list_display = ('title', 'description')\n\nclass ProjectItemAdmin(admin.ModelAdmin, ImageDisplayMixin):\n    list_display = ('title', 'description', 'display_image')\n\nadmin.site.register(About, AboutAdmin)\nadmin.site.register(Project, ProjectAdmin)\nadmin.site.register(ProjectItem, ProjectItemAdmin)\n</code></pre> <p>In this code:</p> <ul> <li>We've created a mixin class called ImageDisplayMixin, which contains the display_image method.</li> <li>The display_image method is decorated with @staticmethod to indicate that it doesn't require access to instance data.</li> <li>Both <code>AboutAdmin</code> and <code>ProjectItemAdmin</code> classes inherit from <code>ImageDisplayMixin</code>, allowing them to reuse the display_image method without duplicating code.</li> <li>By using this approach, you avoid redundancy and keep your code DRY (Don't Repeat Yourself).</li> </ul>"},{"location":"backend/django/builtin/django-contrib-admin/#remove-add-button-in-admin","title":"Remove add button in admin","text":"how to remove add button in admin interface BasicAdvanced <p>Yes, you can remove the \"<code>Add About</code>\" button from the Django admin interface if there is already one item present. This can be achieved by customizing the admin interface using the has_add_permission method in your ModelAdmin class.</p> <p>Here's how you can do it:</p> Python<pre><code>from django.contrib import admin\nfrom .models import About\n\nclass AboutAdmin(admin.ModelAdmin):\n    # other configurations for list_display, fields, etc.\n\n    def has_add_permission(self, request):\n        # Check if there are any existing About objects\n        if About.objects.exists():\n            # Return False to disable the \"Add About\" button\n            return False\n        # Return True to enable the \"Add About\" button\n        return True\n\nadmin.site.register(About, AboutAdmin)\n</code></pre> <p>In this code:</p> <ul> <li>We define the has_add_permission method in the AboutAdmin class.</li> <li>Inside this method, we check if there are any existing About objects in the database using About.objects.exists().</li> <li>If there are existing About objects, we return False to disable the \"<code>Add About</code>\" button.</li> <li>If there are no existing About objects, we return True to enable the \"<code>Add About</code>\" button.</li> </ul> <p>By implementing has_add_permission in this way, you can control whether the \"<code>Add About</code>\" button is displayed based on the presence of existing About objects in the database. If there is already an About object, the button will be hidden, preventing users from adding more About objects.</p> <p>The reason why HasAddPermissionMixin is not working as expected might be due to the order of inheritance in your ServiceAdmin class. In Python, the order of inheritance matters.</p> <p>When you inherit from multiple classes, Python resolves method lookups in the order specified by the inheritance list. This means that if a method is defined in both the child class and one of its parent classes, the version of the method defined in the child class will take precedence.</p> <p>In your case, HasAddPermissionMixin should come before admin.ModelAdmin in the inheritance list so that its has_add_permission method overrides the one from admin.ModelAdmin. Here's the corrected version:</p> Python<pre><code>from django.contrib import admin\nfrom django.utils.safestring import mark_safe\nfrom .models import About, Project, ProjectItem, Service, ServiceItem\n\n\nclass HasAddPermissionMixin:\n    \"\"\"\n    Mixin class to control the add permission based on the existence of objects.\n    \"\"\"\n    def has_add_permission(self, request):\n        model = self.model\n        return not model.objects.exists()\n\nclass ServiceAdmin(HasAddPermissionMixin, admin.ModelAdmin):\n    \"\"\"\n    Admin class for managing Service objects.\n    \"\"\"\n    list_display = ('title', 'description')\n</code></pre> <p>In this corrected version:</p> <ul> <li>HasAddPermissionMixin is listed before admin.ModelAdmin in the inheritance list of ServiceAdmin, ensuring that its has_add_permission method takes precedence.</li> <li>The ServiceAdmin class now inherits from HasAddPermissionMixin and admin.ModelAdmin in the correct order.</li> </ul> <p>With this setup, HasAddPermissionMixin should work as expected in the ServiceAdmin class.</p> category in django <pre><code>class ProjectItem(models.Model):\n    title = models.CharField(max_length=120)\n    description = models.TextField(null=True, blank=True)\n    image = models.ImageField(null=True, blank=True, upload_to=\"project/\")\n    link = models.CharField(null=True, blank=True, max_length=120)\n    category = models.ForeignKey('ProjectCategory', on_delete=models.CASCADE, related_name='items')\n\n    class Meta:\n        db_table = \"bishow_project_item\"\n        verbose_name = \"Project Item\"\n        verbose_name_plural = \"Project Items\"\n\nclass ProjectCategory(models.Model):\n    name = models.CharField(max_length=120)\n\n    class Meta:\n        db_table = \"bishow_project_category\"\n        verbose_name = \"Project Category\"\n        verbose_name_plural = \"Project Categories\"\n</code></pre>"},{"location":"backend/django/builtin/django-contrib-admin/#rename-app-name-in-admin","title":"Rename app name in admin","text":"<p>To rename the app name in the Django admin interface,</p> <p>you can customize the display name by providing a custom AppConfig for your app and then specifying the verbose name. Here's how you can do it:</p> <p>Create an AppConfig class in your app's apps.py file:</p> <pre><code>  # myapp/apps.py\n\n  from django.apps import AppConfig\n\n  class MyAppConfig(AppConfig):\n        name = 'myapp'\n        verbose_name = 'New Display Name'\n</code></pre> <p></p>"},{"location":"backend/django/builtin/django-contrib-admin/#customizing-django-admin-display","title":"Customizing Django Admin Display","text":"example 1:example 2: admin.py<pre><code>class BlogItemAdmin(admin.ModelAdmin):\n    list_display = ('created')\n\n    # Define a custom method to display the value of the 'created_at' field with the custom name 'created'\n    def created(self, obj):\n        return obj.created_at\n\n    # Set a custom label for the column header in the admin interface\n    created.short_description = 'Created'\n</code></pre> admin.py<pre><code>from django.contrib import admin\nfrom .models import Blog, BlogItem\n\nclass BlogItemAdmin(admin.ModelAdmin):\n    list_display = ('title', 'description', 'image', 'published', 'created_at', 'publish_status')\n\n    # Specify the order of fields in the form\n    fields = ('title', 'description', 'image', 'published', 'updated_at')\n\n    # CUSTOMIZE the Column name of model name\n    def publish_status(self, obj):\n        return \"Published\" if obj.published else \"Not Published\"\n\n    publish_status.short_description = 'Publication Status' \n    # publish_status.admin_order_field = 'published'\n\nadmin.site.register(Blog, BlogAdmin)\n</code></pre>"},{"location":"backend/django/builtin/django-contrib-admin/#model-admin","title":"Model Admin","text":"<p>Each registered admin.ModelAdmin class gets a set of CRUD pages. CRUD, besides being a very fun acronym, stands for: Create, Read, Update, and Delete, the actions you take on most pieces of data.</p> <p>The default behavior of the admin.ModelAdmin class includes all the CRUD pages, so your new class can have an empty body, using just the <code>pass</code> keyword. </p> <p>Figure 5.3. The Django Admin is an app that ships with Django giving administrators the ability to create and modify registered Model objects</p>"},{"location":"backend/django/builtin/django-contrib-admin/#reference","title":"Reference","text":"<ul> <li>Books by Agiliq - Django Books (FREE)</li> <li>Django Admin Cookbook</li> </ul>"},{"location":"backend/django/builtin/django-contrib-auth/","title":"django contrib auth","text":""},{"location":"backend/django/builtin/django-contrib-auth/#djangocontribauth","title":"django.contrib.auth","text":"<pre><code># django_project/settings.py\nINSTALLED_APPS = [\n    \"django.contrib.admin\",\n    \"django.contrib.auth\", # Yoohoo!!!!\n    \"django.contrib.contenttypes\",\n    \"django.contrib.sessions\",\n    \"django.contrib.messages\",\n    \"django.contrib.staticfiles\",\n    # Local\n    \"accounts.apps.AccountsConfig\",\n    \"pages.apps.PagesConfig\",\n]\n</code></pre> <p>There are, in fact, 6 apps already there that Django provides for us which power the site. The first is <code>admin</code> and the second is <code>auth</code>. This is how we know the auth app is already present in our Django project.</p> <p>When we earlier ran the migrate command for the first time all of these apps were linked together in the initial database. And remember that we used the AUTH_USER_MODEL setting to tell Django to use our custom user model, not the default User model here. This is why we had to wait until that configuration was complete before running migrate for the first time.</p>"},{"location":"backend/django/builtin/django-contrib-auth/#auth-urls-and-views","title":"Auth URLs and Views","text":"<p>To use Django\u2019s built-in auth app we must explicitly add it to our <code>config/urls.py</code> file. The easiest approach is to use accounts/ as the prefix since that is commonly used in the Django community.</p> <p>Make the one line change below. Note that as our <code>urls.py</code> file grows in length, adding comments for each type of URL\u2013admin, user management, local apps, etc.\u2013helps with readability.</p> <pre><code># django_project/urls.py\nfrom django.contrib import admin\nfrom django.urls import path, include\n\nurlpatterns = [\n    # Django admin\n    path(\"admin/\", admin.site.urls),\n    # User management\n    path(\"accounts/\", include(\"django.contrib.auth.urls\")),\n    # new\n    # Local apps\n    path(\"\", include(\"pages.urls\")),\n]\n</code></pre> <p>What\u2019s included in the auth app? A lot it turns out. First off, there are a number of associated urls.</p> <pre><code>accounts/login/ [name=\"login\"]\naccounts/logout/ [name=\"logout\"]\naccounts/password_change/ [name=\"password_change\"]\naccounts/password_change/done/ [name=\"password_change_done\"]\naccounts/password_reset/ [name=\"password_reset\"]\naccounts/password_reset/done/ [name=\"password_reset_done\"]\naccounts/reset/&lt;uidb64&gt;/&lt;token&gt;/ [name=\"password_reset_confirm\"]\naccounts/reset/done/ [name=\"password_reset_complete\"]\n</code></pre>"},{"location":"backend/django/builtin/django-contrib-auth/#authentication-views","title":"Authentication Views","text":"<p>Django provides several views that you can use for handling login, logout, and password management. </p> <p>Django provides no default template for the authentication views. You should create your own templates for the views you want to use. The template context is documented in each view, see All authentication views.</p> <p>Using the views</p> <p>There are different methods to implement these views in your project. The easiest way is to include the provided URLconf in <code>django.contrib.auth.urls</code> in your own **URLconf, for example:</p> <pre><code>urlpatterns = [\n    path(\"accounts/\", include(\"django.contrib.auth.urls\")),\n]\n</code></pre> <p>This will include the following URL patterns:</p> <pre><code>accounts/login/ [name='login']\naccounts/logout/ [name='logout']\naccounts/password_change/ [name='password_change']\naccounts/password_change/done/ [name='password_change_done']\naccounts/password_reset/ [name='password_reset']\naccounts/password_reset/done/ [name='password_reset_done']\naccounts/reset/&lt;uidb64&gt;/&lt;token&gt;/ [name='password_reset_confirm']\naccounts/reset/done/ [name='password_reset_complete']\n</code></pre>"},{"location":"backend/django/builtin/django-contrib-auth/#create-templates-for-authentication-views","title":"Create Templates for Authentication Views","text":"<p>Django's authentication views use specific template names. You need to create these templates in your project. For example, create the following templates:</p> <p>Example</p> <pre><code>registration/login.html\nregistration/logged_out.html\nregistration/password_change_form.html\nregistration/password_change_done.html\nregistration/password_reset_form.html\nregistration/password_reset_done.html\nregistration/password_reset_confirm.html\nregistration/password_reset_complete.html\n</code></pre> login.htmlviews.pyurls.pysettings.py <p>Here's an example of a simple <code>login.html</code> template:</p> <pre><code>&lt;!-- templates/registration/login.html --&gt;\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;title&gt;Login&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;h2&gt;Login&lt;/h2&gt;\n    &lt;form method=\"post\"&gt;\n        {% csrf_token %}\n        {{ form.as_p }}\n        &lt;button type=\"submit\"&gt;Login&lt;/button&gt;\n    &lt;/form&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <p>Update <code>Views</code> in Your App</p> <p>If you want to extend the functionality or customize the behavior of the authentication views, you can create custom views in your app and update the URL configuration accordingly.</p> <p>For example, you can create a custom login view in <code>myapp/views.py</code>:</p> <pre><code># myapp/views.py\nfrom django.contrib.auth.views import LoginView\n\nclass CustomLoginView(LoginView):\n    template_name = 'registration/login.html'\n</code></pre> <p>And update the URL configuration to use this custom view:</p> <pre><code># myapp/urls.py\nfrom django.urls import path\nfrom .views import CustomLoginView\n\nurlpatterns = [\n    path('login/', CustomLoginView.as_view(), name='login'),\n    # Other URL patterns for your app\n]\n</code></pre> <pre><code># myproject/settings.py\nLOGIN_REDIRECT_URL = '/'\nLOGOUT_REDIRECT_URL = '/accounts/login/'\n</code></pre> Question <p>In Django, django.contrib.auth.views and django.views are modules that provide various functionalities related to authentication and generic views, respectively.</p> django.contrib.auth.viewsdjango.views <p>The <code>django.contrib.auth.views</code> module specifically deals with authentication-related views and functionalities. Here are some key components it provides:</p> <ol> <li> <p>Login and Logout Views:</p> <ul> <li>LoginView: Allows users to log in to the site.</li> <li>LogoutView: Allows users to log out from the site.</li> </ul> </li> <li> <p>Password Management:</p> <ul> <li>PasswordChangeView: Allows users to change their password.</li> <li>PasswordChangeDoneView: Confirmation view after a password change.</li> <li>PasswordResetView: Allows users to request a password reset.</li> <li>PasswordResetDoneView, PasswordResetConfirmView, PasswordResetCompleteView: Views for handling password reset flow.</li> </ul> </li> <li> <p>User Management:</p> <ul> <li>UserCreationForm, UserChangeForm: Forms for creating and changing user accounts.</li> <li>UserDetailView: View for displaying user details.</li> </ul> </li> <li> <p>Permissions and Authorization:</p> <ul> <li>Views and forms related to permissions and authorization checks.</li> </ul> </li> </ol> <p>These views and functionalities provided by django.contrib.auth.views help developers quickly implement common authentication-related features in their Django applications.</p> <p>On the other hand, <code>django.views</code> is a module that provides generic views for handling common web development patterns. Some of the generic views provided by django.views include:</p> <ul> <li>View: The base class for all views. It handles HTTP request processing.</li> <li>TemplateView: Renders a given template, with the context passed through.</li> <li>RedirectView: Redirects to a specified URL.</li> <li>ListView: Renders a list of objects from a queryset.</li> <li>DetailView: Renders the details of a single object from a queryset.</li> </ul> <p>These generic views simplify the implementation of common tasks in Django web development, such as rendering data from models, handling redirects, or displaying static templates.</p> <p>Summary</p> <ul> <li><code>django.contrib.auth.views</code>: Deals with authentication-related views and functionalities like login, logout, password management, and user management.</li> <li><code>django.views</code>: Provides generic views for handling common web development patterns such as rendering templates, handling redirects, and displaying lists or details of objects.</li> </ul> <p>Both modules are essential in Django development, offering convenient abstractions and utilities to streamline the creation of robust web applications.</p>"},{"location":"backend/django/builtin/django-contrib-auth/#reference","title":"Reference","text":"<ul> <li>Django for Professionals by William S. Vincent</li> <li>Authentication Views</li> <li>learndjango auth</li> <li>Django Authentication</li> <li>Django auth: official</li> </ul>"},{"location":"backend/django/builtin/django-contrib-contenttypes/","title":"django contrib contenttypes","text":""},{"location":"backend/django/builtin/django-contrib-contenttypes/#djangocontribcontenttypes","title":"django.contrib.contenttypes","text":""},{"location":"backend/django/builtin/django-contrib-contenttypes/#the-contenttypes-framework","title":"The contenttypes framework","text":"<p>Django includes a contenttypes application that can track all of the models installed in your Django-powered project, providing a high-level, generic interface for working with your models.</p> <p><code>django.contrib.contenttypes</code> is a Django app that provides a framework for content types. It allows you to create relationships between different models without having to hardcode the model classes. Instead of directly referring to a model class, you can use the ContentType framework to get the model's metadata, such as the app label and the model's name. This is particularly useful for generic relationships where you want to associate an object with any type of model without specifying the model directly.</p> <p>For example, let's say you have a <code>Tag</code> model and you want to associate it with any other model in your project. You can use ContentType to create a generic foreign key:</p> <pre><code>from django.contrib.contenttypes.fields import GenericForeignKey\nfrom django.contrib.contenttypes.models import ContentType\nfrom django.db import models\n\nclass TaggedItem(models.Model):\n    content_type = models.ForeignKey(ContentType, on_delete=models.CASCADE)\n    object_id = models.PositiveIntegerField()\n    content_object = GenericForeignKey('content_type', 'object_id')\n    tag = models.CharField(max_length=50)\n\n    # Other fields and methods\n</code></pre> <p>With this setup, you can associate any model instance with a tag without explicitly defining a foreign key for each model.</p> <p><code>django.contrib.contenttypes</code> also provides utilities for working with content types programmatically, such as retrieving the model class for a given content type, getting all related objects for a given object, and so on. It's a powerful tool for building flexible and reusable Django applications.</p>"},{"location":"backend/django/builtin/django-contrib-contenttypes/#reference","title":"Reference","text":"<ul> <li>how does django content types work? stackoverflow</li> </ul>"},{"location":"backend/django/builtin/django-contrib-messages/","title":"django contrib messages","text":"<p>django</p>"},{"location":"backend/django/builtin/django-paginator/","title":"Django Paginator","text":""},{"location":"backend/django/builtin/django-paginator/#django-paginator","title":"django paginator","text":""},{"location":"backend/django/builtin/django-paginator/#reference","title":"Reference","text":"<ul> <li> <p>pagination: official django</p> </li> <li> <p>Pagination for a User-Friendly Django App</p> </li> </ul>"},{"location":"backend/django/builtin/intro/","title":"Intro","text":""},{"location":"backend/django/builtin/intro/#intro","title":"Intro","text":"<p><code>django.contrib</code> is a package in Django that contains a collection of optional, reusable components contributed by the Django community. These components are maintained by the Django core team but are not essential to the core functionality of Django. Instead, they provide additional features that can be integrated into Django projects as needed.</p> <p>Some of the most commonly used packages within <code>django.contrib</code> include:</p> <p>Note</p> <ol> <li>admin: Provides the Django administration site, which allows you to manage your site's data through a web interface.</li> <li>auth: Provides user authentication and authorization functionality, including user management, permissions, and groups.</li> <li>contenttypes: Provides a framework for content types, allowing you to create relationships between different models without hardcoding model classes.</li> <li>sessions: Provides session management functionality for maintaining state across HTTP requests.</li> <li>messages: Provides a way to display temporary messages (e.g., success messages, error messages) to users.</li> <li>staticfiles: Provides utilities for managing static files (e.g., CSS, JavaScript) in Django projects.</li> <li>gis: Provides geographic information system (GIS) functionality for working with spatial data.</li> </ol> <p>These packages can be included in your Django project by adding them to the <code>INSTALLED_APPS</code> setting in your project's <code>settings.py</code> file. For example:</p> <pre><code>INSTALLED_APPS = [\n    ...\n    'django.contrib.admin',\n    'django.contrib.auth',\n    'django.contrib.contenttypes',\n    'django.contrib.sessions',\n    'django.contrib.messages',\n    'django.contrib.staticfiles',\n    ...\n]\n</code></pre> <p>By including these packages, you can leverage their functionality in your Django project without having to build everything from scratch.</p>"},{"location":"backend/django/builtin/intro/#packages","title":"packages","text":"<ul> <li> <p>An administration site</p> <p><code>django.contrib.admin</code></p> <p> Reference</p> </li> <li> <p>An authentication framework</p> <p><code>django.contrib.auth</code></p> <p> Reference</p> </li> <li> <p>A framework for handling content types</p> <p><code>django.contrib.contenttypes</code></p> <p> Reference</p> </li> <li> <p>A session framework</p> <p><code>django.contrib.sessions</code></p> <p> Reference</p> </li> <li> <p>A messaging framework</p> <p><code>django.contrib.messages</code></p> <p> Reference</p> </li> <li> <p>A framework for managing static files </p> <p><code>django.contrib.staticfiles</code></p> <p> Reference</p> </li> </ul>"},{"location":"backend/django/builtin/intro/#class-based-view-vs-function-based-view","title":"Class-based view vs Function-based view","text":"<p>Those are the main differences between <code>function-based views</code> and <code>class-based views</code>. Now, Django\u2019s generic <code>class-based views</code> are a different story.</p> <p>Generic Class-Based Views</p> <p>The generic <code>class-based-views was</code> introduced to address the common use cases in a Web application, such as creating new objects, form handling, list views, pagination, archive views and so on.</p> <ul> <li>They come in the Django core, and you can implement them from the module <code>django.views.generic</code>.</li> <li>They are great and can speed up the development process.</li> </ul> <p>Here is an overview of the available views:</p> <ul> <li> <p>GENERIC BASE</p> <ul> <li>View</li> <li>TemplateView</li> <li>RedirectView</li> </ul> </li> <li> <p>GENERIC DETAIL</p> <ul> <li>DetailView</li> </ul> </li> <li> <p>GENERIC LIST</p> <ul> <li>ListView</li> </ul> </li> <li> <p>GENERIC EDIT</p> <ul> <li>FormView</li> <li>CreateView</li> <li>UpdateView</li> <li>DeleteView</li> </ul> </li> <li> <p>GENERIC DATES</p> <ul> <li>ArchiveIndexView</li> <li>YearArchiveView</li> <li>MonthArchiveView</li> <li>WeekArchiveView</li> <li>DayArchiveView</li> <li>TodayArchiveView</li> <li>DateDetailView</li> </ul> </li> <li> <p>AUTH VIEWS</p> <ul> <li>LoginView</li> <li>LogoutView</li> <li>PasswordChangeDoneView</li> <li>PasswordChangeView</li> <li>PasswordResetCompleteView</li> <li>PasswordResetConfirmView</li> <li>PasswordResetDoneView</li> <li>PasswordResetView</li> </ul> </li> </ul> <ul> <li>Class-Based Views vs. Function-Based Views</li> <li>Classy Class-Based Views.</li> </ul>"},{"location":"backend/django/builtin/intro/#reference","title":"Reference","text":"<ul> <li>Django 4 By Example Fourth Edition by Antonio Mel\u00e9: pg-12</li> </ul>"},{"location":"backend/django/celery/celery-theory/","title":"Theory","text":""},{"location":"backend/django/celery/celery-theory/#celery-theory","title":"Celery Theory","text":"Installation <ul> <li> <p>pip install celery[redis]: </p> <p>Installs Celery with the additional dependency of Redis (redis package) using pip's extras feature. It's a concise way to ensure you get Celery configured to work with Redis. The <code>[redis]</code> part specifies that you want to include the Redis package as an additional dependency for Celery.</p> </li> <li> <p>pip install celery redis:</p> <p>Installs Celery and Redis separately. This method gives you more control over versions and dependencies but requires more manual management.</p> </li> </ul> <p>In most cases, using <code>pip install celery[redis]</code> is recommended when you specifically want to use Celery with Redis, as it handles the dependencies automatically and ensures compatibility between the versions of Celery and Redis that are installed.</p>"},{"location":"backend/django/celery/celery-theory/#questions","title":"Questions","text":"can we use celery with django without using any message broker like redis and rabbitmq? <p>No, Celery requires a message broker to function properly, so you cannot use Celery with Django without using any message broker like Redis or RabbitMQ. Here\u2019s why:</p> <p>Why Celery Needs a Message Broker:</p> <ul> <li> <p>Communication Channel: Celery uses a message broker as a communication channel between the Django application and Celery workers (background task processors).</p> </li> <li> <p>Task Queues: When a Django application enqueues a task (i.e., sends a task to Celery for processing), it places a message describing the task into the message broker.</p> </li> <li> <p>Concurrency: Celery workers continuously monitor the message broker for new tasks. When they detect a new task, they retrieve it from the broker and execute it. This allows for concurrent task execution and scaling across multiple workers.</p> </li> <li> <p>Reliability and Durability: Message brokers like <code>Redis</code> or <code>RabbitMQ</code> ensure that tasks are not lost even if the worker or the Django application goes down temporarily. They provide mechanisms for task persistence and reliability.</p> </li> </ul> <p>Alternatives and Considerations:</p> <ul> <li> <p>Using Django Database as a Broker (Not Recommended): In some cases, developers might attempt to use the Django database as a message broker by configuring Celery to use the database backend. However, this approach is not recommended for production use due to performance limitations, potential database locks, and lack of scalability.</p> </li> <li> <p>Impact on Performance: Directly using a database as a broker can severely impact performance, especially under heavy load, as databases are optimized for different types of operations compared to message brokers.</p> </li> </ul> <p>Conclusion:</p> <p>To use Celery with Django, you must configure and use a message broker like <code>Redis</code> or <code>RabbitMQ</code>. These brokers are integral to Celery\u2019s architecture, facilitating reliable and efficient asynchronous task processing. They ensure that tasks can be distributed across multiple workers, scaled as needed, and managed effectively within the Django ecosystem. Therefore, while it might seem convenient to skip the message broker setup, doing so would undermine Celery's core functionality and reliability in handling background tasks for your Django applications.</p> How Can You Leverage Celery for Your Django App? <ul> <li>Asynchronous Tasks With Django and Celery</li> </ul>"},{"location":"backend/django/celery/celery-theory/#reference","title":"Reference","text":"<ul> <li>Hands-On Microservices with Django by Tieme Woldman</li> <li>Asynchronous Tasks With Django and Celery</li> <li>How to use Celery with Django</li> </ul>"},{"location":"backend/django/celery/celery/","title":"celery","text":""},{"location":"backend/django/celery/celery/#installing-celery","title":"Installing Celery","text":"<p>Success</p> <pre><code>pip install celery==5.2.7\n</code></pre>"},{"location":"backend/django/celery/celery/#using-django-with-celery-and-rabbitmq","title":"Using Django with <code>Celery</code> and <code>RabbitMQ</code>","text":"<p>Celery is a distributed task queue that can process vast amounts of messages. We will use Celery to define asynchronous tasks as Python functions within our Django applications. We will run Celery workers that will listen to the message broker to get new messages to process asynchronous tasks.</p> <p>Using Celery, not only can you create asynchronous tasks easily and let them be executed by workers as soon as possible, but you can also schedule them to run at a specific time. You can find the Celery documentation at <code>https://docs.celeryq.dev/en/stable/index.html</code>.</p> <p>Celery communicates via messages and requires a message broker to mediate between clients and workers. There are several options for a message broker for Celery, including key/value stores such as <code>Redis</code>, or an actual message broker such as <code>RabbitMQ</code>.</p> <p>RabbitMQ is the most widely deployed message broker. It supports multiple messaging protocols, such as the Advanced Message Queuing Protocol (AMQP), and it is the recommended message worker for Celery. RabbitMQ is lightweight, easy to deploy, and can be configured for scalability and high availability.</p> <p></p>"},{"location":"backend/django/celery/celery/#monitoring-celery-with-flower","title":"Monitoring Celery with Flower","text":"<p>Besides the RabbitMQ management UI, you can use other tools to monitor the asynchronous tasks that are executed with Celery. Flower is a useful web-based tool for monitoring Celery. Install Flower using the following command:</p> <p>Success</p> <pre><code>pip install flower==1.1.0\n\ncelery -A myshop flower\n</code></pre>"},{"location":"backend/django/celery/celery/#celery-defination","title":"Celery Defination","text":"<p>Celery is an open-source task queue system written in Python and available as a Python package</p> Celery offers this functionality: <ul> <li>Offload tasks asynchronously</li> <li>Schedule tasks</li> </ul> <p>Because we focus on reactive microservices, we\u2019ll only address offloading tasks with Celery.</p> <p>Celery runs on top of message queue brokers like <code>RabbitMQ</code> and <code>Redis</code>. Celery has become a standard for Django microservices because Celery:</p> <ul> <li>Abstracts the technical details of RabbitMQ and Redis and lets us concentrate on offloading tasks from Django.</li> <li>Integrates well with Django.</li> </ul>"},{"location":"backend/django/celery/celery/#reference","title":"Reference","text":"<ul> <li> <p>Hands-On Microservices with Django by Tieme Woldman</p> </li> <li> <p>How to use Celery with Django</p> </li> <li>Asynchronous Tasks With Django and Celery</li> <li>django-celery-example : github</li> </ul>"},{"location":"backend/django/mixins/context-processors/","title":"context processors","text":"<p>utils/context_processors.py</p> <pre><code>from myapps.commons.models import FooterSocialMedia, Logo\n\ndef united_context(req):\n    social_media = FooterSocialMedia.objects.all()\n    logo = Logo.objects.first()\n\n    return {\n        'social_media': social_media,\n        'logo': logo,\n    }\n</code></pre>"},{"location":"backend/django/mixins/custom-char-field-widget/","title":"custom char field widget","text":"<p>utils/custom_char_field_widget.py</p> <pre><code>from django.forms import TextInput\n\nclass CustomCharFieldWidget(TextInput):\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.attrs.update({'style': 'width: 100%;'})\n</code></pre>"},{"location":"backend/django/mixins/custom-char-field-widget/#usage","title":"Usage","text":"<p>admin.py</p> <pre><code>from django.contrib import admin\nfrom django.db import models\nfrom .models import Business\nfrom utils.custom_char_field_widget import CustomCharFieldWidget\n\n@admin.register(Business)\nclass BusinessAdmin(admin.ModelAdmin):\n    formfield_overrides = {\n        models.CharField: { 'widget': CustomCharFieldWidget }\n    }\n    list_display = ('title', 'content')\n</code></pre>"},{"location":"backend/django/mixins/custom-text-field-widget/","title":"custom text field widget","text":"<p>utils/custom_text_field_widget.py</p> <pre><code>from django.forms import Textarea\n\n# class CustomTextFieldWidget(Textarea):\n#     def __init__(self, *args, **kwargs):\n#         super().__init__(*args, **kwargs)\n#         self.attrs.update({'style': 'width: 100%;', 'rows': '10'})\n\nclass CustomTextFieldWidget(Textarea):\n    def __init__(self, *args, **kwargs):\n        # Default to 10 rows if not provided\n        rows = kwargs.pop('rows', '10')\n        super().__init__(*args, **kwargs)\n        self.attrs.update({'style': 'width: 100%;', 'rows': rows})\n        # CustomTextFieldWidget(rows='5')\n</code></pre>"},{"location":"backend/django/mixins/custom-text-field-widget/#usage","title":"Usage","text":"<p>admin.py</p> <pre><code>from django.contrib import admin\nfrom django.db import models\nfrom .models import About\nfrom utils.custom_text_field_widget import CustomTextFieldWidget\n\n@admin.register(About)\nclass AboutAdmin(admin.ModelAdmin):\n    formfield_overrides = {\n        models.TextField: { 'widget': CustomTextFieldWidget }\n    }\n\n    list_display = ('title', 'content')\n</code></pre>"},{"location":"backend/django/mixins/image-display-mixins/","title":"image display mixins","text":"<p>utils/image_display_mixins.py</p> <pre><code>from django.utils.safestring import mark_safe\n\nclass ImageDisplayMixin:\n    \"\"\"\n    Mixin class to display image preview in the Django admin.\n    \"\"\"\n    @staticmethod\n    def display_image(obj):\n        if obj.image:\n            return mark_safe('&lt;img src=\"{}\" width=\"100\" height=\"100\" /&gt;'.format(obj.image.url))\n        else:\n            return \"No Image\"\n\n    display_image.short_description = 'Image Preview'\n</code></pre>"},{"location":"backend/django/mixins/image-display-mixins/#usage","title":"Usage","text":"<p>admin.py</p> <pre><code>from django.contrib import admin\nfrom utils.image_display_mixins import ImageDisplayMixin\nfrom .models import Gallery\n\n@admin.register(Gallery)\nclass GalleryAdmin(ImageDisplayMixin, admin.ModelAdmin):\n    list_display = ('title', 'display_image') \n</code></pre>"},{"location":"backend/django/mixins/image-size-validators/","title":"image size validators","text":"<p>utils/image_size_validators.py</p> <pre><code>from django.core.exceptions import ValidationError\n\ndef validate_image_size(value):\n    \"\"\"\n    Validates that the uploaded image is at most 2MB.\n    \"\"\"\n    # Limit file size to 5MB\n    max_size = 2 * 1024 * 1024 \n\n    # Check if the uploaded file exceeds the maximum size\n    if value.size &gt; max_size:\n        raise ValidationError('The maximum image size allowed is 2MB.')\n</code></pre>"},{"location":"backend/django/mixins/image-size-validators/#usage","title":"Usage","text":"<p>models.py</p> <pre><code>from django.db import models\nfrom utils.image_size_validators import validate_image_size\n\nclass Gallery(models.Model):\n    title = models.CharField(max_length=120, null=True, blank=True, help_text='Optional')\n    image = models.ImageField(upload_to='gallery/',  validators=[validate_image_size])\n</code></pre>"},{"location":"backend/django/mixins/image-type-validators/","title":"image type validators","text":"<p>utils/image-type-validators.py</p> <pre><code>from PIL import Image\nfrom django.core.exceptions import ValidationError\n\ndef validate_image_type(image):\n    \"\"\"\n    Validate the uploaded image.\n    \"\"\"\n    try:\n        # Open the image file\n        img = Image.open(image)\n\n        # Ensure it's in a supported format\n        supported_formats = ('JPEG', 'PNG', 'GIF', 'WEBP')\n        if img.format not in supported_formats:\n            raise ValidationError(\"Unsupported image format. Supported formats: JPEG, PNG, GIF\")\n\n        # Additional validation checks can be added here if needed\n\n    except IOError:\n        # Unable to open image file\n        raise ValidationError(\"Invalid image file\")\n</code></pre>"},{"location":"backend/django/mixins/image-type-validators/#usage","title":"Usage","text":"<p>models.py</p> <pre><code>from django.db import models\nfrom utils.image_type_validators import validate_image_type\n\nclass YourModel(models.Model):\n    image = models.ImageField(upload_to='gallery/')\n\n    def clean(self):\n        \"\"\"\n        Validate the uploaded image before saving.\n        \"\"\"\n        if self.image:\n            validate_image_type(self.image)\n\n    def save(self, *args, **kwargs):\n        \"\"\"\n        Override the save method to perform image validation before saving.\n        \"\"\"\n        self.clean()\n        super().save(*args, **kwargs)\n</code></pre>"},{"location":"backend/django/mixins/intro/","title":"Intro","text":"<p>When you need to provide a specific behavior for several class-based views, it is recommended that you use <code>mixins</code>.</p>"},{"location":"backend/django/mixins/intro/#using-mixins-for-class-based-views","title":"Using mixins for class-based views","text":"<p>Mixins are a special kind of multiple inheritance for a class. You can use them to provide common discrete functionality that, when added to other <code>mixins</code>, allows you to define the behavior of a class.</p> <p>There are two main situations to use mixins:</p> <ul> <li>You want to provide multiple optional features for a class</li> <li>You want to use a particular feature in several classes</li> </ul> <p>Django comes with several mixins that provide additional functionality to your class-based views.</p> <p>You can learn more about mixins at <code>https://docs.djangoproject.com/en/4.1/topics/class-based-views/mixins/</code>.</p> <p>Django by Example <code>pg: 542</code></p>"},{"location":"backend/django/mixins/intro/#image-validation-in-the-django","title":"Image Validation in the django","text":"<p>Success</p> modelReusestructuremy structure<code>__init__.py</code> models.py<pre><code>from django.core.exceptions import ValidationError\n\ndef validate_image_size(value):\n    \"\"\"\n    Validates that the uploaded image is at most 2MB.\n    \"\"\"\n    # Limit file size to 2MB\n    max_size = 2 * 1024 * 1024 \n\n    # Check if the uploaded file exceeds the maximum size\n    if value.size &gt; max_size:\n        raise ValidationError('The maximum image size allowed is 2MB.')\n\n\n# Now use this in the class\nclass Contact(models.Model):\n    title = models.CharField(max_length=120)\n    description = models.TextField(null=True, blank=True)\n    image = models.ImageField(upload_to=\"contact/\", validators=[validate_image_size])\n</code></pre> <p>Note:</p> <p>In this code:</p> <ul> <li>We define a custom validator function <code>validate_image_size</code> that checks if the uploaded image size exceeds 2MB. If it does, it raises a <code>ValidationError</code>.</li> <li>We then apply this custom validator to the <code>image</code> field of the Contact model.</li> </ul> <p>With this setup, when you attempt to upload an image larger than 2MB via the Django admin interface, it will raise a validation error and prevent the image from being saved. </p> <p>To reuse the image validation code across multiple Django apps, you can create a separate module for your custom validators and import them wherever needed. Here's how you can do it:</p> validatormodelanother apps <p>First, create a new file named <code>validators.py</code> (or any name you prefer) inside your Django app directory or within a shared utilities package:</p> validators.py<pre><code>from django.core.exceptions import ValidationError\n\ndef validate_image_size(value, max_size=2 * 1024 * 1024):\n    \"\"\"\n    Validates that the uploaded image is at most the specified size.\n    \"\"\"\n    if value.size &gt; max_size:\n        raise ValidationError(f'The maximum image size allowed is {max_size/(1024*1024)}MB.')\n</code></pre> validators.py<pre><code>from django.core.exceptions import ValidationError\n\ndef validate_image_size(value):\n    \"\"\"\n    Validates that the uploaded image is at most 2MB.\n    \"\"\"\n    # Limit file size to 2MB\n    max_size = 2 * 1024 * 1024 \n\n    # Check if the uploaded file exceeds the maximum size\n    if value.size &gt; max_size:\n        raise ValidationError('The maximum image size allowed is 2MB.')\n</code></pre> <p>Now, you can import and use this validator function in any of your models across your Django project. For example, to use it in your Contact model and any other models that require image validation:</p> models.py<pre><code>from django.db import models\nfrom .validators import validate_image_size\n\nclass Contact(models.Model):\n    title = models.CharField(max_length=120)\n    description = models.TextField(null=True, blank=True)\n    image = models.ImageField(upload_to=\"contact/\", validators=[validate_image_size])\n\n    def __str__(self):\n        return self.title\n</code></pre> <p>And if you have another model in a different app that also requires image size validation, you can import and use the validator in that model as well:</p> models.py<pre><code># models.py in another app\n\nfrom django.db import models\nfrom shared_utils.validators import validate_image_size\n\nclass AnotherModel(models.Model):\n    title = models.CharField(max_length=120)\n    image = models.ImageField(upload_to=\"another_model/\", validators=[validate_image_size])\n\n    def __str__(self):\n        return self.title\n</code></pre> <p>This way, you can reuse the <code>validate_image_size</code> function across multiple apps within your Django project without duplicating code. It promotes code organization and maintainability.</p> <p>Creating a shared utilities folder is a good practice to organize reusable code in a Django project. However, the <code>templates</code> directory is typically reserved for HTML template files used by your Django views, so it's not the appropriate place for Python code.</p> <p>Instead, you can create a separate directory within your Django project structure to hold shared utilities. Here's a common structure:</p> <pre><code>project_name/\n\u2502\n\u251c\u2500\u2500 project_name/\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 settings.py\n\u2502   \u251c\u2500\u2500 urls.py\n\u2502   \u2514\u2500\u2500 wsgi.py\n\u2502\n\u251c\u2500\u2500 app1/\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 models.py\n\u2502   \u251c\u2500\u2500 views.py\n\u2502   \u2514\u2500\u2500 ...\n\u2502\n\u251c\u2500\u2500 app2/\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 models.py\n\u2502   \u251c\u2500\u2500 views.py\n\u2502   \u2514\u2500\u2500 ...\n\u2502\n\u2514\u2500\u2500 utils/\n    \u251c\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 validators.py\n    \u2514\u2500\u2500 other_utils.py\n</code></pre> <p>In the structure above:</p> <ul> <li><code>project_name/</code> is the root directory of your Django project.</li> <li><code>app1/</code> and <code>app2/</code> are Django apps within your project.</li> <li><code>utils/</code> is a directory where you can place shared utility functions and modules.</li> </ul> <p>So, you would create your <code>validators.py</code> file inside the <code>utils/</code> directory:</p> <pre><code>project_name/\n\u2502\n\u251c\u2500\u2500 utils/\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2514\u2500\u2500 validators.py\n</code></pre> <p>Then, you can import and use these validators wherever needed in your Django project, as shown in the previous example. This structure keeps your project organized and makes it easy to locate and manage shared utility code.</p> <p>If you have an <code>apps</code> directory where you put all your Django apps, and you want to import the <code>validators.py</code> module located in a shared utilities folder from within one of those apps, you can use a relative import.</p> <p>Here's how you can organize your project structure to achieve this:</p> <pre><code>project_name/\n\u2502\n\u251c\u2500\u2500 apps/\n\u2502   \u251c\u2500\u2500 app1/\n\u2502   \u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2502   \u251c\u2500\u2500 models.py\n\u2502   \u2502   \u2514\u2500\u2500 ...\n\u2502   \u251c\u2500\u2500 app2/\n\u2502   \u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2502   \u251c\u2500\u2500 models.py\n\u2502   \u2502   \u2514\u2500\u2500 ...\n\u2502   \u2514\u2500\u2500 ...\n\u2502\n\u2514\u2500\u2500 utils/\n    \u251c\u2500\u2500 __init__.py\n    \u2514\u2500\u2500 validators.py\n</code></pre> <p>In this structure, your <code>validators.py</code> file is located in the utils directory alongside the <code>apps</code> directory, both at the same level within your project.</p> <p>To import the <code>validators.py</code> module from within one of your apps, you can use a relative import like this:</p> python<pre><code># Inside models.py of app1 or app2\nfrom ..utils.validators import validate_image_size\n# or\nfrom shared_utils.validators import validate_image_size\n</code></pre> <p>This import statement goes up one level (<code>..</code>) from the current directory (<code>app1</code> or <code>app2</code>) to the parent directory, where both <code>utils</code> and <code>apps</code> directories are located. Then it imports the <code>validate_image_size</code> function from the <code>validators.py</code> module within the <code>utils</code> directory.</p> <p>Using relative imports ensures that your code remains portable and independent of the absolute paths within your project structure.</p> <p>In Python, the <code>__init__.py</code> file serves as an indicator that the directory should be treated as a package. Although it can be an empty file, it has several important functions:</p> <ul> <li> <p>Package Initialization: It initializes the package when it is imported. This means any code you put in <code>__init__.py</code> will be executed when the package is imported.</p> </li> <li> <p>Namespace Organization: It helps organize the namespace. Without an <code>__init__.py</code> file, Python won't recognize the directory as a package, and you won't be able to import modules from it using dot notation.</p> </li> <li> <p>Python 3 Namespace Packages: In Python 3, <code>__init__.py</code> is not required to create a package; you can have namespace packages without them. However, it's still common practice to include <code>__init__.py</code> files for compatibility and to support older Python versions.</p> </li> <li> <p>Explicit Initialization: It makes package initialization explicit. By including an <code>__init__.py</code> file, you can add any necessary initialization code or imports, making it clear that the directory is intended to be a package.</p> </li> </ul> <p>In the context of Django projects, including an <code>__init__.py</code> file in your utils directory is not strictly required, especially for Django projects using Python 3 and above. However, it's still considered a good practice for consistency and compatibility with older Python versions. It also allows you to extend your utilities package in the future if needed, by adding initialization code or additional modules.</p>"},{"location":"backend/django/mixins/intro/#other","title":"other","text":""},{"location":"backend/django/mixins/intro/#overview","title":"Overview","text":"<p>Tip</p> <pre><code>pip install django~=4.2\n</code></pre> <pre><code>utils\n\u251c\u2500\u2500 __init__.py\n\u251c\u2500\u2500 custom_char_field_widget.py\n\u251c\u2500\u2500 custom_text_field_widget.py\n\u251c\u2500\u2500 image_display_mixins.py\n\u251c\u2500\u2500 image_validators.py\n\u2514\u2500\u2500 permission_mixins.py\n</code></pre>"},{"location":"backend/django/mixins/intro/#utils-mixins","title":"Utils Mixins","text":"<p>Success</p> char widgettext widgetimage displayimage validationpermissionincremental serial num custom_char_field_widget.py<pre><code>from django.forms import TextInput\n\nclass CustomCharFieldWidget(TextInput):\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.attrs.update({'style': 'width: 100%;'})\n</code></pre> custom_text_field_widget.py<pre><code>from django.forms import Textarea\n\n# class CustomTextFieldWidget(Textarea):\n#     def __init__(self, *args, **kwargs):\n#         super().__init__(*args, **kwargs)\n#         self.attrs.update({'style': 'width: 100%;', 'rows': '10'})\n\nclass CustomTextFieldWidget(Textarea):\n    def __init__(self, *args, **kwargs):\n        # Default to 10 rows if not provided\n        rows = kwargs.pop('rows', '10')\n        super().__init__(*args, **kwargs)\n        self.attrs.update({'style': 'width: 100%;', 'rows': rows})\n        # CustomTextFieldWidget(rows='5')\n</code></pre> image_display_mixins.py<pre><code>from django.utils.safestring import mark_safe\n\nclass ImageDisplayMixin:\n    \"\"\"\n    Mixin class to display image preview in the Django admin.\n    \"\"\"\n    @staticmethod\n    def display_image(obj):\n        if obj.image:\n            return mark_safe('&lt;img src=\"{}\" width=\"100\" height=\"100\" /&gt;'.format(obj.image.url))\n        else:\n            return \"No Image\"\n\n    display_image.short_description = 'Image Preview'\n</code></pre> image_validators.py<pre><code>from django.core.exceptions import ValidationError\n\ndef validate_image_size(value):\n    \"\"\"\n    Validates that the uploaded image is at most 2MB.\n    \"\"\"\n    # Limit file size to 2MB\n    max_size = 2 * 1024 * 1024 \n\n    # Check if the uploaded file exceeds the maximum size\n    if value.size &gt; max_size:\n        raise ValidationError('The maximum image size allowed is 2MB.')\n</code></pre> permission_mixins.py<pre><code>class HasAddPermissionMixin:\n    \"\"\"\n    Mixin class to control the add permission based on the existence of objects.\n    \"\"\"\n    def has_add_permission(self, request):\n        model = self.model\n        return not model.objects.exists()\n</code></pre> Incremental_serialnum_mixins.py<pre><code># mixins.py\nclass IncrementalSerialNumberMixin:\n    def get_serial_number(self, obj):\n        # Get the position of the object in the reversed queryset and add 1 to start from 1 instead of 0\n        queryset = self.model.objects.all().order_by('-pk')  # Assuming pk is the primary key\n        # queryset = self.model.objects.all()\n        return list(queryset).index(obj) + 1\n    get_serial_number.short_description = 'S.N.'\n</code></pre> <p>Tip</p> Removing `Add` &amp; `Update`<pre><code>@admin.register(ContactModel)\nclass ContactModelAdmin(admin.ModelAdmin):\n    list_display = (\"name\", \"email\", \"service\",\"message\", \"number\", \"timestamp\")\n\n    def has_add_permission(self, request):\n        return False\n\n    def has_change_permission(self, request, obj=None):\n        return False\n</code></pre>"},{"location":"backend/django/mixins/intro/#views-mixins","title":"Views Mixins","text":"<pre><code>views\n\u251c\u2500\u2500 __init__.py\n\u2514\u2500\u2500 header_mixins.py\n</code></pre> <p>Success</p> header mixin header_mixins.py<pre><code>from django.views.generic.base import ContextMixin\nfrom industries.models import IndustriesItem\nfrom business.models import BusinessItem\n\nclass HeaderMixin(ContextMixin):\n    def get_context_data(self, **kwargs):\n        context = super().get_context_data(**kwargs)\n\n        industry_items = IndustriesItem.objects.all()\n        context['industry_items'] = industry_items\n\n        business_items = BusinessItem.objects.all()\n        context['business_items'] = business_items\n\n        return context\n</code></pre> <p>Usage</p> views.py<pre><code>from django.views.generic import TemplateView\nfrom views.header_mixins import HeaderMixin\n\nclass IndexView(HeaderMixin, TemplateView):\n    template_name = 'index.html'\n\n    def get_context_data(self, **kwargs):\n        context = super().get_context_data(**kwargs)\n        return context\n</code></pre>"},{"location":"backend/django/mixins/intro/#beginner-vs-senior-code","title":"Beginner <code>vs</code> Senior Code","text":"<p>Handling Nullable Fields in Django Models</p> Beginner VersionSenior Programmer Version Python<pre><code># Import necessary module\nfrom django.db import models\n\n# Define the model class\nclass YourModel(models.Model):\n    # Define the title field with maximum length and nullable option\n    title = models.CharField(max_length=100, null=True)\n\n    # Define a method to return a string representation of the object\n    def __str__(self):\n        # Check if title is not None\n        if self.title is not None:\n            # Return the title\n            return self.title\n        else:\n            # Return a default string if title is None\n            return \"Untitled\"\n</code></pre> <pre><code># Utilize a concise import statement\nfrom django.db import models\n\n# Define the model class with clear and descriptive naming\nclass YourModel(models.Model):\n    # Use descriptive variable names and specify field options clearly\n    title = models.CharField(max_length=100, null=True)\n\n    # Implement a straightforward method for string representation\n    def __str__(self):\n        # Use a ternary operator for brevity and readability\n        return self.title if self.title is not None else \"Untitled\"\n</code></pre> <p>In the senior programmer version, you'll notice more concise variable naming, clearer documentation, and the use of a ternary operator for the <code>__str__</code> method, which improves readability. Additionally, comments are used sparingly, as the code itself is self-explanatory. This version demonstrates a more efficient and professional coding style, reflecting the experience and expertise of a senior developer.</p>"},{"location":"backend/django/mixins/permission-mixins/","title":"permission mixins","text":"<p>utils/permission_mixins.py</p> <pre><code>class HasAddPermissionMixin:\n\"\"\"\nMixin class to control the add permission based on the existence of objects.\n\"\"\"\ndef has_add_permission(self, request):\n    model = self.model\n    return not model.objects.exists()\n</code></pre>"},{"location":"backend/django/mixins/permission-mixins/#usage","title":"Usage","text":"<p>admin.py</p> <pre><code>from django.contrib import admin\nfrom utils.permission_mixins import HasAddPermissionMixin\nfrom .models import Contact\n\n@admin.register(Contact)\nclass ContactAdmin(HasAddPermissionMixin, admin.ModelAdmin):\n    list_display = ('mail', )\n</code></pre>"},{"location":"backend/django/shell/intro/","title":"Intro","text":"<p>Mastering the Django shell can significantly enhance your development workflow and debugging processes. Here are some tips and techniques to help you become proficient with the Django shell:</p>"},{"location":"backend/django/shell/intro/#1-basic-commands","title":"1. Basic Commands","text":"<ul> <li>Start the Shell:</li> </ul> <pre><code>python manage.py shell\n</code></pre> <ul> <li>Exit the Shell:</li> </ul> <pre><code>exit()\n</code></pre>"},{"location":"backend/django/shell/intro/#2-importing-models","title":"2. Importing Models","text":"<ul> <li>Get familiar with importing your models. Use the <code>from</code> statement:</li> </ul> <pre><code>from yourapp.models import YourModel\n</code></pre>"},{"location":"backend/django/shell/intro/#3-creating-and-manipulating-objects","title":"3. Creating and Manipulating Objects","text":"<ul> <li>Create Objects:</li> </ul> <pre><code>instance = YourModel.objects.create(field1='value', field2='value')\n</code></pre> <ul> <li>Update Objects:</li> </ul> <pre><code>instance.field1 = 'new value'\ninstance.save()\n</code></pre> <ul> <li>Delete Objects:</li> </ul> <pre><code>instance.delete()\n</code></pre> Create a Normal UserCreate a Superuser <pre><code>from django.contrib.auth.models import User\n\n# Create a normal user\nnormal_user = User.objects.create_user(\n    username='normaluser',\n    email='normaluser@example.com',\n    password='yourpassword'\n)\n</code></pre> <pre><code>super_user = User.objects.create_superuser(\n    username='adminuser',\n    email='adminuser@example.com',\n    password='yourpassword'\n)\n</code></pre>"},{"location":"backend/django/shell/intro/#4-querying-the-database","title":"4. Querying the Database","text":"<ul> <li>Use QuerySet methods like <code>all()</code>, <code>filter()</code>, <code>exclude()</code>, and <code>get()</code>:</li> </ul> <pre><code>all_objects = YourModel.objects.all()\nfiltered_objects = YourModel.objects.filter(field='value')\nspecific_object = YourModel.objects.get(id=1)\n</code></pre>"},{"location":"backend/django/shell/intro/#5-using-the-shell-with-django-extensions","title":"5. Using the Shell with Django Extensions","text":"<ul> <li>Consider using Django Extensions for a more powerful shell:</li> </ul> <pre><code>pip install django-extensions\n</code></pre> <ul> <li> <p>Add <code>'django_extensions'</code> to your <code>INSTALLED_APPS</code>.</p> </li> <li> <p>Start the enhanced shell:</p> </li> </ul> <pre><code>python manage.py shell_plus\n</code></pre>"},{"location":"backend/django/shell/intro/#6-utilizing-ipython-or-jupyter","title":"6. Utilizing IPython or Jupyter","text":"<ul> <li>If you prefer a more interactive shell, you can use IPython or Jupyter Notebook:</li> </ul> <pre><code>pip install ipython\n</code></pre> <ul> <li>Use:</li> </ul> <pre><code>python manage.py shell -i ipython\n</code></pre>"},{"location":"backend/django/shell/intro/#7-debugging-with-the-shell","title":"7. Debugging with the Shell","text":"<ul> <li>Use the shell to test out snippets of code or debug issues directly.</li> <li>Print statements and interact with objects to understand their state.</li> </ul>"},{"location":"backend/django/shell/intro/#8-using-context-managers","title":"8. Using Context Managers","text":"<ul> <li>Use context managers for transactions:</li> </ul> <pre><code>from django.db import transaction\nwith transaction.atomic():\n    # Your database operations here\n</code></pre>"},{"location":"backend/django/shell/intro/#9-writing-helper-functions","title":"9. Writing Helper Functions","text":"<ul> <li>Create reusable functions for frequent tasks, such as creating test data:</li> </ul> <pre><code>def create_test_user(username, email):\n    return User.objects.create_user(username=username, email=email, password='password123')\n</code></pre>"},{"location":"backend/django/shell/intro/#10-experiment-with-admin","title":"10. Experiment with Admin","text":"<ul> <li>Test out how your models look and behave in the Django admin:</li> </ul> <pre><code>from django.contrib.admin import site\nsite.register(YourModel)\n</code></pre>"},{"location":"backend/django/shell/intro/#11-utilize-the-help-function","title":"11. Utilize the Help Function","text":"<ul> <li>Use <code>help()</code> to get more information about methods and classes:</li> </ul> <pre><code>help(YourModel)\n</code></pre>"},{"location":"backend/django/shell/intro/#12-scripting","title":"12. Scripting","text":"<ul> <li>For repetitive tasks, consider writing scripts that can be run from the shell. Create a .<code>py</code> file and run it:</li> </ul> <pre><code>python script.py\n</code></pre>"},{"location":"backend/django/shell/intro/#conclusion","title":"Conclusion","text":"<p>Regularly practicing these techniques will help you become more comfortable with the Django shell. Use it for testing, debugging, and rapid prototyping to make your development process more efficient. Happy coding!</p>"},{"location":"backend/middleware/intro/","title":"Intro","text":"<p>Middleware in computing refers to software that acts as an intermediary between different components of a system, enabling them to communicate and interact with each other. In the context of web development and Django, middleware is a layer of processing that sits between the request and the response phases of handling a web request.</p>"},{"location":"backend/middleware/intro/#what-is-middleware-in-django","title":"What is Middleware in Django?","text":"<p>In Django, middleware is a series of hooks into Django's request/response processing. It\u2019s a way to process requests and responses globally before they reach the view or after they leave the view. Middleware can perform functions like:</p> <ul> <li>Request logging</li> <li>User authentication and authorization</li> <li>Content filtering or modification</li> <li>Response processing (e.g., compression, caching)</li> </ul>"},{"location":"backend/middleware/intro/#why-do-we-need-middleware-in-django","title":"Why Do We Need Middleware in Django?","text":"<ol> <li> <p>Cross-cutting Concerns: Middleware helps manage concerns that are relevant to multiple parts of an application, such as security, logging, and session management. These are tasks that need to be performed across various views but don\u2019t necessarily belong to any specific view logic.</p> </li> <li> <p>Separation of Concerns: By using middleware, you can keep your view functions clean and focused on their primary responsibilities, while middleware handles tasks that affect requests and responses globally.</p> </li> <li> <p>Reusability: Middleware components can be reused across different projects or views. For example, authentication middleware can be used to handle user sessions in various views without duplicating code.</p> </li> </ol>"},{"location":"backend/middleware/intro/#where-do-you-need-middleware","title":"Where Do You Need Middleware?","text":"<p>Middleware is used in scenarios where you need to process requests or responses in a way that affects multiple parts of the application or the entire request/response lifecycle. Common use cases include:</p> <ul> <li>Security: Checking if requests are coming from trusted sources or adding security headers.</li> <li>Session Management: Managing user sessions and cookies.</li> <li>Logging and Monitoring: Recording details of incoming requests and outgoing responses.</li> <li>Request Transformation: Modifying requests or responses before they reach the view or the client.</li> <li>Performance: Implementing caching or throttling mechanisms.</li> </ul>"},{"location":"backend/middleware/intro/#when-to-use-middleware","title":"When to Use Middleware?","text":"<p>You should use middleware when you need to:</p> <ol> <li>Apply Logic Globally: Implement logic that applies to all or many views, rather than writing it into individual view functions.</li> <li>Enhance Performance: Add functionality like caching or rate limiting.</li> <li>Enforce Policies: Implement cross-cutting concerns such as authentication, authorization, or security measures.</li> </ol>"},{"location":"backend/middleware/intro/#how-to-use-middleware-in-django","title":"How to Use Middleware in Django?","text":"<ol> <li> <p>Creating Middleware: Write a custom middleware class by subclassing <code>MiddlewareMixin</code> (in Django versions prior to 1.10) or using simple classes in newer versions. Implement the required methods: <code>__init__</code>, <code>process_request</code>, <code>process_view</code>, <code>process_response</code>, and/or <code>process_exception</code>.</p> <pre><code>from django.utils.deprecation import MiddlewareMixin\n\nclass CustomMiddleware(MiddlewareMixin):\n    def process_request(self, request):\n        # Code to execute for each request\n        pass\n\n    def process_response(self, request, response):\n        # Code to execute for each response\n        return response\n</code></pre> </li> <li> <p>Adding Middleware to Settings: Register your middleware in the <code>MIDDLEWARE</code> setting in <code>settings.py</code>. The order of middleware classes in this list is significant because they are executed in the order they are listed.</p> <pre><code>MIDDLEWARE = [\n    'django.middleware.security.SecurityMiddleware',\n    'django.contrib.sessions.middleware.SessionMiddleware',\n    'django.middleware.common.CommonMiddleware',\n    'django.middleware.csrf.CsrfViewMiddleware',\n    'myapp.middleware.CustomMiddleware',  # Your custom middleware\n    # Other middleware...\n]\n</code></pre> </li> <li> <p>Testing Middleware: Ensure you test your middleware thoroughly to check that it interacts correctly with requests and responses and doesn\u2019t introduce any unexpected behavior or performance issues.</p> </li> </ol>"},{"location":"backend/middleware/intro/#summary","title":"Summary","text":"<p>Middleware in Django is a powerful tool for processing requests and responses globally across your application. It allows you to handle cross-cutting concerns, enhance performance, and enforce security measures effectively. By understanding where and when to use middleware, you can maintain clean and manageable code while ensuring consistent behavior across your application.</p>"},{"location":"backend/middleware/topic/","title":"Topic","text":"<p>To master middleware in Django from basic to advanced levels, you should cover a range of topics that encompass the fundamental concepts, practical applications, and advanced techniques. Here's a structured approach:</p> Basic Level TopicExplaination <ol> <li> <p>Understanding Middleware:</p> <ul> <li>What is middleware?</li> <li>Role and purpose of middleware in Django.</li> <li>Middleware architecture and lifecycle.</li> </ul> </li> <li> <p>Basic Middleware Structure:</p> <ul> <li>Creating a simple middleware class.</li> <li><code>__init__</code>, <code>__call__</code>, and <code>process_request</code> methods.</li> <li>Understanding the <code>process_request</code> and <code>process_response</code> methods.</li> <li>Writing middleware that processes requests and responses.</li> </ul> </li> <li> <p>Built-in Middleware:</p> <ul> <li>Overview of Django's built-in middleware (e.g., <code>AuthenticationMiddleware</code>, <code>SessionMiddleware</code>, <code>CommonMiddleware</code>).</li> <li>How these middlewares interact with requests and responses.</li> </ul> </li> <li> <p>Adding Middleware to Settings:</p> <ul> <li>Configuring middleware in <code>MIDDLEWARE</code> setting.</li> <li>Order of middleware and its importance.</li> </ul> </li> </ol> Basic Level <ol> <li> <p>Understanding Middleware:</p> <ul> <li>Concept: Middleware is a way to process requests and responses globally before they reach the view or after the view has processed them.</li> <li>Example: Imagine a logging middleware that records each request\u2019s URL and method for analytics.</li> </ul> </li> <li> <p>Basic Middleware Structure:</p> <ul> <li> <p>Example:</p> <pre><code># myapp/middleware.py\nclass SimpleLoggingMiddleware:\n    def __init__(self, get_response):\n        self.get_response = get_response\n\n    def __call__(self, request):\n        print(f\"Request URL: {request.path}\")\n        response = self.get_response(request)\n        return response\n</code></pre> </li> <li> <p>This middleware logs the URL of every incoming request.</p> </li> </ul> </li> <li> <p>Built-in Middleware:</p> <ul> <li> <p>Example:</p> <ul> <li>AuthenticationMiddleware: Ensures the request user is available as request.user.</li> <li>SessionMiddleware: Manages sessions by associating requests with session data.</li> <li>These are automatically included and managed by Django and provide foundational functionalities like user authentication and session management.</li> </ul> </li> </ul> </li> <li> <p>Adding Middleware to Settings:</p> <ul> <li> <p>Example:</p> <pre><code># settings.py\nMIDDLEWARE = [\n    'django.middleware.security.SecurityMiddleware',\n    'django.contrib.sessions.middleware.SessionMiddleware',\n    'django.middleware.common.CommonMiddleware',\n    'django.middleware.csrf.CsrfViewMiddleware',\n    'django.contrib.auth.middleware.AuthenticationMiddleware',\n    'django.contrib.messages.middleware.MessageMiddleware',\n    'django.middleware.clickjacking.XFrameOptionsMiddleware',\n    'myapp.middleware.SimpleLoggingMiddleware',\n]\n</code></pre> </li> </ul> </li> </ol> Intermediate Level TopicExplanation <ol> <li> <p>Advanced Middleware Methods:</p> <ul> <li><code>process_exception</code> and its use cases.</li> <li>Creating middleware that handles exceptions.</li> </ul> </li> <li> <p>Middleware for Authentication and Permissions:</p> <ul> <li>Writing custom middleware for authentication.</li> <li>Implementing middleware for user permissions and roles.</li> </ul> </li> <li> <p>Performance Considerations:</p> <ul> <li>Evaluating the impact of middleware on performance.</li> <li>Techniques for optimizing middleware performance.</li> </ul> </li> <li> <p>Middleware for Caching:</p> <ul> <li>Implementing caching middleware.</li> <li>Integrating with Django's caching framework.</li> </ul> </li> <li> <p>Handling Requests and Responses:</p> <ul> <li>Manipulating request and response objects.</li> <li>Adding or modifying headers, cookies, or data.</li> </ul> </li> </ol> Intermediate Level <ol> <li> <p>Advanced Middleware Methods:</p> <ul> <li> <p>Example:</p> <pre><code># myapp/middleware.py\nclass ExceptionHandlingMiddleware:\n    def __init__(self, get_response):\n        self.get_response = get_response\n\n    def __call__(self, request):\n        try:\n            response = self.get_response(request)\n        except Exception as e:\n            # Log the exception or perform some action\n            print(f\"An error occurred: {e}\")\n            return HttpResponse(\"Something went wrong!\", status=500)\n        return response\n</code></pre> </li> </ul> </li> <li> <p>Middleware for Authentication and Permissions:</p> <ul> <li> <p>Example: A middleware that ensures only logged-in users can access certain views:</p> <pre><code># myapp/middleware.py\nclass AuthRequiredMiddleware:\n    def __init__(self, get_response):\n        self.get_response = get_response\n\n    def __call__(self, request):\n        if request.path.startswith('/admin/') and not request.user.is_authenticated:\n            return HttpResponse(\"Unauthorized\", status=401)\n        return self.get_response(request)\n</code></pre> </li> </ul> </li> <li> <p>Performance Considerations:</p> <ul> <li>Example: Avoid performing heavy computations inside middleware. Use asynchronous tasks or cache results if needed.</li> </ul> </li> <li> <p>Middleware for Caching:</p> <ul> <li> <p>Example:</p> <pre><code># myapp/middleware.py\nfrom django.core.cache import cache\n\nclass CachingMiddleware:\n    def __init__(self, get_response):\n        self.get_response = get_response\n\n    def __call__(self, request):\n        cache_key = f\"cache_{request.path}\"\n        response = cache.get(cache_key)\n        if not response:\n            response = self.get_response(request)\n            cache.set(cache_key, response, timeout=60*15)  # Cache for 15 minutes\n        return response\n</code></pre> </li> </ul> </li> <li> <p>Handling Requests and Responses:</p> <ul> <li> <p>Example:</p> <pre><code># myapp/middleware.py\nclass HeaderMiddleware:\n    def __init__(self, get_response):\n        self.get_response = get_response\n\n    def __call__(self, request):\n        response = self.get_response(request)\n        response['X-Custom-Header'] = 'MyValue'\n        return response\n</code></pre> </li> </ul> </li> </ol> Advanced Level TopicExplanation <ol> <li> <p>Custom Middleware for Complex Scenarios:</p> <ul> <li>Writing middleware for specific business logic.</li> <li>Handling complex data transformations and validations.</li> </ul> </li> <li> <p>Middleware with Asynchronous Support:</p> <ul> <li>Understanding async middleware in Django 3.1+.</li> <li>Creating asynchronous middleware using <code>async def</code>.</li> </ul> </li> <li> <p>Testing Middleware:</p> <ul> <li>Techniques for unit testing middleware.</li> <li>Mocking request and response objects.</li> <li>Using Django's test client to simulate middleware behavior.</li> </ul> </li> <li> <p>Security and Error Handling:</p> <ul> <li>Middleware for enhancing security (e.g., security headers).</li> <li>Handling and logging errors in middleware.</li> </ul> </li> <li> <p>Performance and Profiling:</p> <ul> <li>Profiling middleware to identify performance bottlenecks.</li> <li>Strategies for optimizing middleware execution.</li> </ul> </li> <li> <p>Middleware Integration with Third-Party Libraries:</p> <ul> <li>Integrating with external systems or services (e.g., third-party authentication).</li> <li>Writing middleware that interacts with APIs or external services.</li> </ul> </li> <li> <p>Middleware and Django Signals:</p> <ul> <li>Using Django signals within middleware.</li> <li>Handling signals to modify request/response behavior.</li> </ul> </li> </ol> Advanced Level <ol> <li> <p>Custom Middleware for Complex Scenarios:</p> <ul> <li> <p>Example: A middleware that compresses responses for specific types of requests:</p> <pre><code># myapp/middleware.py\nfrom django.utils.deprecation import MiddlewareMixin\nimport gzip\nfrom io import BytesIO\n\nclass GZipMiddleware(MiddlewareMixin):\n    def process_response(self, request, response):\n        if response['Content-Type'] == 'text/html':\n            buf = BytesIO()\n            with gzip.GzipFile(fileobj=buf, mode='wb') as f:\n                f.write(response.content)\n            response.content = buf.getvalue()\n            response['Content-Encoding'] = 'gzip'\n        return response\n</code></pre> </li> </ul> </li> <li> <p>Middleware with Asynchronous Support:</p> <ul> <li> <p>Example:</p> <pre><code># myapp/middleware.py\nclass AsyncMiddleware:\n    async def __call__(self, request):\n        response = await self.get_response(request)\n        return response\n</code></pre> </li> </ul> </li> <li> <p>Testing Middleware::</p> <ul> <li> <p>Example:</p> <pre><code># myapp/tests.py\nfrom django.test import TestCase, RequestFactory\nfrom myapp.middleware import SimpleLoggingMiddleware\n\nclass MiddlewareTestCase(TestCase):\n    def setUp(self):\n        self.factory = RequestFactory()\n\n    def test_logging_middleware(self):\n        request = self.factory.get('/some-url/')\n        middleware = SimpleLoggingMiddleware(lambda req: HttpResponse('OK'))\n        response = middleware(request)\n        self.assertEqual(response.status_code, 200)\n</code></pre> </li> </ul> </li> <li> <p>Security and Error Handling:</p> <ul> <li> <p>Example: Middleware to add security headers:</p> <pre><code># myapp/middleware.py\nclass SecurityHeadersMiddleware:\n    def __init__(self, get_response):\n        self.get_response = get_response\n\n    def __call__(self, request):\n        response = self.get_response(request)\n        response['X-Content-Type-Options'] = 'nosniff'\n        response['X-Frame-Options'] = 'DENY'\n        return response\n</code></pre> </li> </ul> </li> <li> <p>Performance and Profiling:</p> <ul> <li>Example: Use Django Debug Toolbar or custom logging to analyze middleware performance.</li> </ul> </li> <li> <p>Middleware Integration with Third-Party Libraries:</p> <ul> <li> <p>Example: Middleware to integrate with a third-party analytics service:</p> <pre><code># myapp/middleware.py\nimport requests\n\nclass AnalyticsMiddleware:\n    def __init__(self, get_response):\n        self.get_response = get_response\n\n    def __call__(self, request):\n        response = self.get_response(request)\n        # Send request data to third-party analytics service\n        requests.post('https://analytics.example.com', data={\n            'url': request.path,\n            'status': response.status_code,\n        })\n        return response\n</code></pre> </li> </ul> </li> <li> <p>Middleware and Django Signals:</p> <ul> <li> <p>Example: Middleware that triggers a signal when a certain condition is met:</p> <pre><code># myapp/middleware.py\nfrom django.core.signals import request_finished\nfrom django.dispatch import receiver\n\nclass SignalMiddleware:\n    def __init__(self, get_response):\n        self.get_response = get_response\n\n    def __call__(self, request):\n        response = self.get_response(request)\n        if request.path == '/special-url/':\n            request_finished.send(sender=self.__class__)\n        return response\n\n@receiver(request_finished)\ndef handle_request_finished(sender, **kwargs):\n    print(\"Request finished for special URL\")\n</code></pre> </li> </ul> </li> </ol> <p>This progression from basic to advanced topics, coupled with practical examples, should give you a comprehensive understanding of Django middleware and how to implement and utilize it effectively in various scenarios.</p>"},{"location":"backend/middleware/topic/#how-to-really-master-the-middeware-in-django","title":"how to really master the middeware in django","text":"<p>Mastering middleware in Django involves a combination of theoretical understanding, practical implementation, and advanced problem-solving skills. Here\u2019s a structured path to achieving mastery:</p> Abstract <ol> <li> <p>Deep Understanding of Middleware Concepts</p> <ul> <li> <p>Core Concepts:</p> <ul> <li>Middleware Lifecycle: Understand the request-response cycle and how middleware fits in. Learn about request processing (<code>process_request</code>), response processing (<code>process_response</code>), and exception handling (<code>process_exception</code>).</li> <li>Order of Execution: Study how the order of middleware in the <code>MIDDLEWARE</code> setting affects behavior. Middleware is executed in the order it\u2019s listed when processing requests and in reverse order when processing responses.</li> </ul> </li> <li> <p>Reading Materials:</p> <ul> <li>Django Documentation: Thoroughly read Django's official middleware documentation.</li> <li>Books &amp; Tutorials: Look for books and tutorials focused on Django middleware and its advanced usage.</li> </ul> </li> </ul> </li> <li> <p>Hands-On Practice</p> <ul> <li> <p>Start Simple:</p> <ul> <li>Create basic middleware that logs request details or modifies responses.</li> <li>Example: Middleware that logs request URLs and response status codes.</li> </ul> </li> <li> <p>Build Projects:</p> <ul> <li>Mini Projects: Implement custom middleware for specific needs, such as request rate limiting or user authentication.</li> <li>Real Projects: Integrate middleware into real Django projects to handle logging, authentication, or security features.</li> </ul> </li> </ul> </li> <li> <p>Experiment with Advanced Middleware Features</p> <ul> <li> <p>Async Middleware:</p> <ul> <li>Experiment with async middleware using <code>async def</code> for handling asynchronous requests in Django 3.1+.</li> <li>Example: Asynchronous middleware that interacts with an async API.</li> </ul> </li> <li> <p>Exception Handling:</p> <ul> <li>Create middleware that handles different types of exceptions and provides custom error pages or logging.</li> <li>Example: Middleware that logs errors to a monitoring service and provides a user-friendly error page.</li> </ul> </li> <li> <p>Performance Optimization:</p> <ul> <li>Profile middleware performance using tools like Django Debug Toolbar or custom logging.</li> <li>Implement caching or optimize middleware operations to enhance performance.</li> </ul> </li> </ul> </li> <li> <p>Testing and Debugging</p> <ul> <li> <p>Unit Testing:</p> <ul> <li>Write unit tests for middleware to ensure it behaves as expected. Use Django\u2019s test client and request factory.</li> <li>Example: Test that your caching middleware correctly caches and serves cached responses.</li> </ul> </li> <li> <p>Debugging:</p> <ul> <li>Use debugging tools to inspect middleware behavior. Log request and response data to troubleshoot issues.</li> <li>Example: Add detailed logging to trace how middleware processes requests and responses.</li> </ul> </li> </ul> </li> <li> <p>Study Built-In Middleware</p> <ul> <li> <p>Explore Built-In Middleware:</p> <ul> <li>Examine how Django\u2019s built-in middleware works and why it\u2019s designed the way it is.</li> <li>Example: Look into <code>SessionMiddleware</code> to understand how session management is handled.</li> </ul> </li> <li> <p>Contribute to Django:</p> <ul> <li>Read the source code of Django\u2019s built-in middleware to see best practices and advanced techniques.</li> <li>Contribute to Django or review pull requests related to middleware.</li> </ul> </li> </ul> </li> <li> <p>Security and Best Practices</p> <ul> <li> <p>Security:</p> <ul> <li>Implement security-focused middleware, such as adding security headers or protecting against common vulnerabilities.</li> <li>Example: Middleware that adds HTTP security headers like <code>Content-Security-Policy</code>.</li> </ul> </li> <li> <p>Best Practices:</p> <ul> <li>Follow best practices for writing clean, efficient, and maintainable middleware.</li> <li>Example: Ensure middleware is not too complex and does only one job well.</li> </ul> </li> </ul> </li> <li> <p>Stay Updated and Engage with the Community</p> <ul> <li> <p>Follow Django Updates:</p> <ul> <li>Stay updated with new Django releases and middleware improvements.</li> <li>Example: Keep an eye on Django\u2019s release notes and migration guides.</li> </ul> </li> <li> <p>Community Engagement:</p> <ul> <li>Engage with the Django community through forums, mailing lists, or conferences.</li> <li>Example: Participate in discussions about middleware on Django forums or contribute to Django-related open-source projects.</li> </ul> </li> </ul> </li> <li> <p>Practical Application and Continuous Learning</p> <ul> <li> <p>Real-World Scenarios:</p> <ul> <li>Apply your middleware knowledge to solve real-world problems in your projects.</li> <li>Example: Use middleware for a custom logging solution in a production application.</li> </ul> </li> <li> <p>Continuous Learning:</p> <ul> <li>Continuously explore new middleware techniques and patterns.</li> <li>Example: Learn about emerging patterns or tools related to middleware in the Django ecosystem.</li> </ul> </li> </ul> </li> </ol>"},{"location":"backend/middleware/topic/#example-path-to-mastery","title":"Example Path to Mastery","text":"<ol> <li>Week 1-2: Study basic middleware concepts and write simple middleware for logging.</li> <li>Week 3-4: Implement middleware for authentication and caching in a mini project.</li> <li>Week 5-6: Explore advanced middleware features, such as async middleware and exception handling.</li> <li>Week 7-8: Write unit tests and debug existing middleware. Optimize for performance.</li> <li>Ongoing: Engage with Django\u2019s source code, stay updated with new Django releases, and participate in the community.</li> </ol> <p>By following these steps and consistently applying and refining your skills, you'll achieve a high level of mastery in Django middleware.</p>"},{"location":"backend/package/0.draft/","title":"Draft Package","text":"<p>djangopackages</p> list of django packages <p>When working with Django, there are several essential packages beyond <code>django-debug-toolbar</code> that can enhance your development process, improve security, or provide additional functionality. Here's a list of some essential packages:</p> <p>1. Django Rest Framework (DRF): If you're building RESTful APIs with Django, DRF provides powerful tools for serialization, authentication, and views.</p> <p>2. Celery: Celery is a distributed task queue that can be used for running tasks asynchronously. It's commonly used for background processing, such as sending emails or processing data.</p> <p>3. django-crispy-forms: This package helps you manage Django forms. It allows you to easily control the rendering of forms in your templates.</p> <p>4. django-allauth: If you need user authentication in your Django project, django-allauth provides a flexible and customizable solution with support for social authentication.</p> <p>5. django-cors-headers: If you're building a backend that serves APIs consumed by frontend applications, CORS (Cross-Origin Resource Sharing) headers can be necessary. This package simplifies configuring CORS headers in your Django application.</p> <p>6. django-environ: It simplifies handling environment variables in your Django project, making it easier to manage settings across different environments (development, staging, production, etc.).</p> <p>7. django-filter: This package provides a simple way to filter queryset dynamically in your Django views, especially useful when dealing with RESTful APIs.</p> <p>8. django-ckeditor: If you need a rich text editor in your Django application, django-ckeditor integrates CKEditor into your forms.</p> <p>9. django-debug-toolbar-template-timings: This is an extension for django-debug-toolbar that adds template rendering times to the toolbar, helping you identify performance bottlenecks.</p> <p>10. django-extensions: This package provides various extensions for Django, including management commands, model mixins, and template tags, which can boost productivity during development.</p> <p>11. django-redis: If you're using Redis with Django (for caching, session storage, etc.), django-redis provides a simple way to integrate Redis into your Django project.</p> <p>12. django-webpack-loader: If you're using Webpack to manage your frontend assets, django-webpack-loader can help you integrate Webpack with Django's template engine.</p> <p>These are just a few examples of essential packages for Django development. Depending on your specific project requirements, you may find additional packages that suit your needs. Always remember to review a package's documentation and community support before integrating it into your project.</p>"},{"location":"backend/package/0.draft/#modules-vs-libraries-vs-packages-in-django","title":"Modules vs Libraries vs Packages in django","text":""},{"location":"backend/package/0.draft/#reference","title":"Reference","text":"<ul> <li>9 Django Packages That Every Web Development Project Needs</li> <li>10 Essential Django Packages Every Developer Should Know</li> <li>14 Django packages you should know</li> <li>Top 10 Django Packages That Every Developer Should Use </li> <li>Essential Python Packages Every Django Developer Should Know</li> <li>Top 10 Django Packages Every Developer Should Know</li> </ul>"},{"location":"backend/package/dj-rest-auth/","title":"dj rest auth","text":"<p><code>dj-rest-auth</code> package</p> <p>First we will add log in, log out, and password reset API endpoints. These come out-of-the-box with the popular <code>dj-rest-auth</code> package.</p>"},{"location":"backend/package/dj-rest-auth/#step-1-installation","title":"Step 1: Installation","text":"<pre><code>pip install dj-rest-auth==2.1.11\n</code></pre>"},{"location":"backend/package/dj-rest-auth/#step-2-updated-installed_apps","title":"Step 2: Updated <code>INSTALLED_APPS</code>","text":"<p>Add the new app to the <code>INSTALLED_APPS</code> config in our <code>django_project/settings.py</code> file.</p> settings.py<pre><code>INSTALLED_APPS = [\n    \"django.contrib.admin\",\n    \"django.contrib.auth\",\n    \"django.contrib.contenttypes\",\n    \"django.contrib.sessions\",\n    \"django.contrib.messages\",\n    \"django.contrib.staticfiles\",\n\n    # 3rd-party apps\n    \"rest_framework\",\n    \"corsheaders\",\n    \"rest_framework.authtoken\",\n    \"dj_rest_auth\", # new\n\n    # Local\n    \"accounts.apps.AccountsConfig\",\n    \"posts.apps.PostsConfig\",\n]\n</code></pre>"},{"location":"backend/package/dj-rest-auth/#step-3-update-urlspy","title":"Step 3: Update <code>urls.py</code>","text":"<p>Update our <code>django_project/urls.py</code> file with the <code>dj_rest_auth</code> package. We\u2019re setting the URL routes to <code>api/v1/dj-rest-auth</code>. Make sure to note that URLs should have a dash <code>-</code> not an underscore <code>_</code>, which is an easy mistake to make.</p> urls.py<pre><code>from django.contrib import admin\nfrom django.urls import path, include\n\nurlpatterns = [\n    path(\"admin/\", admin.site.urls),\n    path(\"api/v1/\", include(\"posts.urls\")),\n    path(\"api-auth/\", include(\"rest_framework.urls\")),\n    path(\"api/v1/dj-rest-auth/\", include(\"dj_rest_auth.urls\")), # new\n]\n</code></pre> <p>And we\u2019re done! If you have ever tried to implement your own user authentication endpoints, it is truly amazing how much time and headache <code>dj-rest-auth</code> saves for us. Now we can spin up the server to see what <code>dj-rest-auth</code> has provided.</p> <p>Run the server</p> <pre><code>python manage.py runserver\n</code></pre> <p>API Log In Endpoint</p> <pre><code># Login\nhttp://127.0.0.1:8000/api/v1/dj-rest-auth/login/\n\n# Logout\nhttp://127.0.0.1:8000/api/v1/dj-rest-auth/logout/\n\n# Password Reset\nhttp://127.0.0.1:8000/api/v1/dj-rest-auth/password/reset\n\n# Password Reset Confirm\nhttp://127.0.0.1:8000/api/v1/dj-rest-auth/password/reset/confirm\n</code></pre>"},{"location":"backend/package/dj-rest-auth/#reference","title":"Reference","text":"<ul> <li>Django for APIs by William S. Vincent, page number: 140</li> </ul>"},{"location":"backend/package/django-allauth/","title":"django allauth","text":"<p>User Registration</p> <p>Next up is our user registration, or sign up, endpoint. Traditional Django does not ship with built-in views or URLs for user registration and neither does Django REST Framework. Which means we need to write our own code from scratch; a somewhat risky approach given the seriousness\u2013 and security implications\u2013of getting this wrong.</p> <p>A popular approach is to use the third-party package <code>django-allauth</code> which comes with user registration as well as a number of additional features to the Django auth system such as social authentication via Facebook, Google, Twitter, etc.</p> <p>If we add <code>dj_rest_auth.registration</code> from the <code>dj-rest-auth</code> package then we have user registration endpoints too!</p>"},{"location":"backend/package/django-allauth/#step-1-install-django-allauth","title":"Step 1: Install <code>django-allauth</code>","text":"<pre><code>pip install django-allauth~=0.48.0\n</code></pre> <p>Then update our <code>INSTALLED_APPS</code> setting. We must add several new configs:</p> <ul> <li><code>django.contrib.sites</code></li> <li><code>allauth</code></li> <li><code>allauth.account</code></li> <li><code>allauth.socialaccount</code></li> <li><code>dj_rest_auth.registration</code></li> </ul> <pre><code>INSTALLED_APPS = [\n    \"django.contrib.admin\",\n    \"django.contrib.auth\",\n    \"django.contrib.contenttypes\",\n    \"django.contrib.sessions\",\n    \"django.contrib.messages\",\n    \"django.contrib.staticfiles\",\n    \"django.contrib.sites\", # new\n\n    # 3rd-party apps\n    \"rest_framework\",\n    \"corsheaders\",\n    \"rest_framework.authtoken\",\n    \"allauth\", # new\n    \"allauth.account\", # new\n    \"allauth.socialaccount\", # new\n    \"dj_rest_auth\",\n    \"dj_rest_auth.registration\", # new\n\n    # Local\n    \"accounts.apps.AccountsConfig\",\n    \"posts.apps.PostsConfig\",\n]\n</code></pre> <p><code>django-allauth</code> needs to be added to the <code>TEMPLATES</code> configuration after existing context processors as well as setting the <code>EMAIL_BACKEND</code> to console and adding a <code>SITE_ID</code> of 1.</p> settings.py<pre><code>TEMPLATES = [\n    {\n        \"BACKEND\": \"django.template.backends.django.DjangoTemplates\",\n        \"DIRS\": [],\n        \"APP_DIRS\": True,\n        \"OPTIONS\": {\n            \"context_processors\": [\n                \"django.template.context_processors.debug\",\n                \"django.template.context_processors.request\",\n                \"django.contrib.auth.context_processors.auth\",\n                \"django.contrib.messages.context_processors.messages\",\n                \"django.template.context_processors.request\", # new\n            ],\n        },\n    },\n]\n\nEMAIL_BACKEND = \"django.core.mail.backends.console.EmailBackend\" # new\nSITE_ID = 1 # new\n</code></pre> <p>The email back-end config is needed since by default an email will be sent when a new user is registered, asking them to confirm their account. Rather than also set up an email server, we will output the emails to the console with the <code>console.EmailBackend</code> setting.</p> <p><code>SITE_ID</code> is part of the built-in Django \u201csites\u201d framework97 , which is a way to host multiple websites from the same Django project. We only have one site we are working on here but <code>django-allauth</code> uses the sites framework, so we must specify a default setting.</p> <p>Ok. We\u2019ve added new apps so it\u2019s time to update the database.</p> <pre><code>python manage.py migrate\n</code></pre> <p>Then add a new URL route for registration.</p> <pre><code>    # django_project/urls.py\n    from django.contrib import admin\n    from django.urls import path, include\n    urlpatterns = [\n        path(\"admin/\", admin.site.urls),\n        path(\"api/v1/\", include(\"posts.urls\")),\n        path(\"api-auth/\", include(\"rest_framework.urls\")),\n        path(\"api/v1/dj-rest-auth/\", include(\"dj_rest_auth.urls\")),\n        path(\"api/v1/dj-rest-auth/registration/\", include(\"dj_rest_auth.registration.urls\")), # new\n    ]\n</code></pre> <p>And we\u2019re done. We can run the local server.</p> <pre><code>python manage.py runserver\n</code></pre> <p>There is now a user registration endpoint at:</p> <pre><code>http://127.0.0.1:8000/api/v1/dj-rest-auth/registration/.\n</code></pre>"},{"location":"backend/package/django-allauth/#conclusion","title":"Conclusion","text":"<p>As a result, a popular, powerful, and secure approach is to rely on the third-party packages dj-rest-auth and django-allauth to minimize the amount of code we have to write from scratch.</p>"},{"location":"backend/package/django-allauth/#reference","title":"Reference","text":"<ul> <li>Django for APIs by William S. Vincent</li> </ul>"},{"location":"backend/package/django-autoslug/","title":"django autoslug","text":"<p><code>django-autoslug</code> library</p> <p>The AutoSlugField is not a built-in field provided by Django itself. It appears to be from a third-party library called django-autoslug. This library provides a field for Django models that automatically generates a unique slug for each instance of the model.</p> <p>To use AutoSlugField, you need to install the django-autoslug library via pip. You can do this by running:</p> Bash<pre><code>pip install django-autoslug\n</code></pre> <p>Once installed, you can import AutoSlugField in your Django model file and use it like any other field. Here's a basic example of how you might use it:</p> Python<pre><code>  from django.db import models\n  from autoslug import AutoSlugField\n\n  class YourModel(models.Model):\n  title = models.CharField(max_length=100)\n  slug = AutoSlugField(populate_from='title', unique=True)\n</code></pre> <p>In this example, the slug field will automatically generate a slug based on the title field whenever a new instance of YourModel is created. The unique=True parameter ensures that each generated slug is unique within the database.</p>"},{"location":"backend/package/django-cors-headers/","title":"django cors headers","text":""},{"location":"backend/package/django-cors-headers/#cross-origin-resource-sharing","title":"Cross-Origin Resource Sharing","text":"<p>In a decoupled setup, JavaScript is the main consumer for REST and GraphQL APIs.</p> <p>By default, JavaScript can request resources with <code>XMLHttpRequest</code> or <code>fetch</code>, as long as the server and the frontend live in the same origin.</p> <p>An origin in HTTP is the combination of the scheme or protocol, the domain, and the port. This means that the origin <code>http://localhost:8000</code> is not equal to <code>http://localhost:3000</code>. </p> <p>When JavaScript attempts to fetch a resource from a different origin than its own, a mechanism known as Cross-Origin Resource Sharing (CORS) kicks in the browser. In any REST or GraphQL project, CORS is necessary to control what origins can connect to the API. To enable CORS in Django, we can install <code>django-cors-headers</code> in our project with the following command:</p> Python<pre><code>pip install django-cors-headers\n</code></pre>"},{"location":"backend/package/django-cors-headers/#enabling-django-cors-headers-in-django","title":"Enabling <code>django-cors-headers</code> in Django","text":"<p>To enable the package, include corsheaders in <code>decoupled_dj/settings/base.py</code>, as shown in Listing 7-10.</p> <pre><code>INSTALLED_APPS = [\n...\n'corsheaders',\n...\n]\n</code></pre>"},{"location":"backend/package/django-cors-headers/#enabling-cors-middleware","title":"Enabling CORS Middleware","text":"<pre><code>MIDDLEWARE = [\n...\n'corsheaders.middleware.CorsMiddleware',\n'django.middleware.common.CommonMiddleware',\n...\n]\n</code></pre> <p>With this change in place, we can configure <code>django-cors-headers</code>. In development, we may want to allow all origins to bypass CORS altogether. To <code>decoupled_dj/settings/development.py</code>, add the configuration shown in Listing 7-12.</p>"},{"location":"backend/package/django-cors-headers/#relaxing-cors-in-development","title":"Relaxing CORS in Development","text":"<pre><code>CORS_ALLOW_ALL_ORIGINS = True\n</code></pre> <p>In production, we have to be more restrictive. <code>django-cors-headers</code> allows us to define a list of allowed origins, which can be configured in <code>decoupled_dj/settings/production.py</code></p>"},{"location":"backend/package/django-cors-headers/#hardening-cors-in-production","title":"Hardening CORS in Production","text":"<pre><code>CORS_ALLOWED_ORIGINS = [\n    \"https://example.com\",\n    \"http://another1.io\",\n    \"http://another2.io\",\n]\n</code></pre> <p>Since we are using variables per environment, we can make this configuration directive a list</p> <pre><code>CORS_ALLOWED_ORIGINS = env.list(\n    \"CORS_ALLOWED_ORIGINS\",\n    default=[]\n)\n</code></pre> <p>This way we can define allowed origins as a comma-separated list in <code>.env</code> for production. CORS is a basic form of protection for users, since without this mechanism in place, any website would be able to fetch and inject malicious code in the page, and a protection for REST APIs, which can explicitly allow a list of predefined origins instead of being open to the world. Of course, CORS does not absolutely replace authentication, which is covered briefly in the next section.</p>"},{"location":"backend/package/django-cors-headers/#reference","title":"Reference","text":"<p>Book</p> <ul> <li>Decoupled Django :pg-101</li> </ul>"},{"location":"backend/package/django-crispy-forms/","title":"django crispy forms","text":"<p>The best way to have DRY Django forms. </p> <pre><code>pip install django-crispy-forms crispy-bootstrap5\n</code></pre> <pre><code># myproject/settings.py\nINSTALLED_APPS = [\n    ...\n    'crispy_forms',\n    'crispy_bootstrap5',\n    ...\n]\n\nCRISPY_TEMPLATE_PACK = 'bootstrap5'  # You can choose 'bootstrap4', 'bootstrap5', 'uni_form', etc.\n</code></pre> <pre><code># example\n# Path to custom crispy-forms template pack\nCRISPY_TEMPLATE_PACK = 'crispy-tailwind'\n\n# Allow the use of our custom template pack\nCRISPY_ALLOWED_TEMPLATE_PACKS = ('bootstrap4', 'crispy-tailwind')\n</code></pre>"},{"location":"backend/package/django-crispy-forms/#reference","title":"Reference","text":"<ul> <li>django-crispy-forms.readthedocs.io</li> <li>django-crispy-forms: github</li> </ul>"},{"location":"backend/package/django-debug-toolbar/","title":"django debug toolbar","text":"<p>Abstract</p> <ul> <li>debug toolbar :youtube</li> <li>official doc debug</li> </ul> Django Settings Exampleprod vs local in settings.pyDJANGO_SETTINGS_MODULE <pre><code>if settings.DEBUG:\n    import debug_toolbar\n\n    urlpatterns += [\n        path('__debug__/', include(debug_toolbar.urls)),\n    ]\n\n    urlpatterns += static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)\n\n#or\n\nif settings.DEBUG:\n    import debug_toolbar\n    urlpatterns = [\n        path('__debug__/', include(debug_toolbar.urls)),\n    ] + urlpatterns\n</code></pre> <p>Separating Django settings for production and local development environments is a common practice to ensure that sensitive information (like database credentials, secret keys, debug mode, etc.) used in production remains secure and different from those used in development. Here's how a senior programmer might typically approach this:</p> <p>1. Create Separate Settings Files: The senior programmer would typically create separate <code>settings.py</code> files for each environment.</p> <p>For example:</p> <ul> <li>settings.py: Main settings file containing common settings.</li> <li>settings_production.py: Settings specific to the production environment.</li> <li>settings_local.py: Settings specific to the local development environment.</li> </ul> <p>2. Common Settings: Keep common settings in the main <code>settings.py</code> file. These are settings that are shared between both production and local environments.</p> <p>3. Environment-Specific Settings: Place environment-specific settings in their respective files (<code>settings_production.py</code> for production and <code>settings_local.py</code> for local development). This includes sensitive information like database credentials, secret keys, debug mode settings, etc.</p> <p>4. Use Environment Variables: Instead of hardcoding sensitive information directly into the settings files, utilize environment variables. This allows for greater flexibility and security. For instance, you might read the database credentials from environment variables in both <code>settings_production.py</code> and <code>settings_local.py</code>.</p> <p>5. Use Conditional Imports: In <code>settings.py</code>, import the environment-specific settings based on the current environment.</p> <p>For example:</p> <pre><code>import os\n\nif os.environ.get('DJANGO_SETTINGS_MODULE') == 'project.settings_production':\n    from .settings_production import *\nelse:\n    from .settings_local import *\n</code></pre> <p>6. Set DJANGO_SETTINGS_MODULE: Ensure that the DJANGO_SETTINGS_MODULE environment variable is set appropriately for each environment. For production, it should point to <code>project.settings_production</code>, and for local development, it should point to <code>project.settings_local</code>.</p> <p>7. Version Control: Ensure that sensitive settings are not committed to version control repositories. Use techniques like <code>.gitignore</code> to exclude sensitive files or environment variables from being tracked by version control systems.</p> <p>8. Documentation: Clearly document the purpose and usage of each settings file to help other developers understand the project's configuration.</p> <p>By following these practices, the senior programmer ensures that the Django project can seamlessly switch between different environments while maintaining security and consistency across deployments.</p> <p><code>DJANGO_SETTINGS_MODULE</code> is an environment variable used by Django to determine which settings file to use for a particular Django project.</p> <p>When you run a Django management command (such as <code>runserver</code>, <code>makemigrations</code>, <code>migrate</code>, etc.) or deploy a Django application, Django needs to know which settings file to load to configure the project. This is where the <code>DJANGO_SETTINGS_MODULE</code> environment variable comes into play.</p> <p>The value of <code>DJANGO_SETTINGS_MODULE</code> specifies the Python path to the settings module for the Django project. For example, if your project is named <code>myproject</code> and your settings module is named <code>settings</code>, then the value of <code>DJANGO_SETTINGS_MODULE</code> would be <code>myproject.settings</code>.</p> <p>Here's how it works:</p> <ol> <li>When you run a Django management command, Django looks for the <code>DJANGO_SETTINGS_MODULE</code> environment variable.</li> <li>If <code>DJANGO_SETTINGS_MODULE</code> is set, Django loads the settings module specified by its value.</li> <li>If <code>DJANGO_SETTINGS_MODULE</code> is not set, Django falls back to the default settings module (<code>settings.py</code>).</li> </ol> <p>You can set the DJANGO_SETTINGS_MODULE environment variable in various ways:</p> <ul> <li>Manually in your shell or terminal before running Django commands or deploying your application.</li> <li>In your development environment, you might set it in your IDE's configuration or in your virtual environment's activation script.</li> <li>In production environments, it's often set in the server configuration or deployment scripts.</li> </ul> <p>For example, if you're using Bash or a compatible shell, you can set the environment variable like this:</p> <pre><code>export DJANGO_SETTINGS_MODULE=myproject.settings\n</code></pre> <p>And in Windows Command Prompt or PowerShell:</p> <pre><code>set DJANGO_SETTINGS_MODULE=myproject.settings\n</code></pre> <p>Or, you can specify it inline when running Django management commands:</p> <pre><code>python manage.py runserver --settings=myproject.settings\n</code></pre> <p>By setting <code>DJANGO_SETTINGS_MODULE</code> appropriately, you can ensure that Django loads the correct settings for your project in different environments.</p> <ul> <li>Django Settings official doc</li> </ul>"},{"location":"backend/package/django-environ/","title":"django environ","text":""},{"location":"backend/package/django-environ/#installation","title":"Installation","text":"Bash<pre><code>pip install django-environ\n</code></pre>"},{"location":"backend/package/django-environ/#splitting-the-settings-file","title":"Splitting the Settings File","text":"<p>Particularly useful when deploying in production, split settings are a way to partition Django settings depending on the environment. In a typical project, you may have:</p> <ul> <li>The <code>base</code> environment, common for all scenarios</li> <li>The <code>development</code> environment, with settings for development</li> <li>The <code>test</code> environment, with settings that apply only to testing</li> <li>The <code>staging</code> environment</li> <li>The <code>production</code> environment</li> </ul> <p>The theory is that depending on the environment, Django loads its settings from a <code>.env</code> file. This approach is known as the Twelve-Factor app, first popularized by Heroku in 2011. </p> <p>There are many libraries for Twelve-Factor in Django. Some developers prefer to use <code>os.environ</code> to avoid additional dependencies altogether. My favorite library is <code>django-environ</code>.</p> <p>For our project we set up three environments: base, development, and later production.</p> <p>Once the folder is in place, create another file for the base environment in <code>decoupled_dj/settings/base.py</code>. In this file, we import django-environ, and we place everything Django needs to run, regardless of the specific environment. Among these settings are:</p> <p>Abstract</p> <ul> <li>SECRET_KEY</li> <li>DEBUG</li> <li>INSTALLED_APPS</li> <li>MIDDLEWARE</li> <li>AUTH_USER_MODEL</li> </ul> <p>Remember that in the previous section we configured a custom Django user. In the base settings we need to include the custom user app in INSTALLED_APPS, and most   important, configure AUTH_USER_MODEL. Our base settings file like this:</p> <p>Base Settings for Our Project</p> settings/base.py<pre><code>import environ\nfrom pathlib import Path\n\nBASE_DIR = Path(__file__).resolve().parent.parent\nenv = environ.Env()\nenviron.Env.read_env()\nSECRET_KEY = env(\"SECRET_KEY\")\nDEBUG = env.bool(\"DEBUG\", False)\n\nINSTALLED_APPS = [\n    \"django.contrib.admin\",\n    \"django.contrib.auth\",\n    \"django.contrib.contenttypes\",\n    \"django.contrib.sessions\",\n    \"django.contrib.messages\",\n    \"django.contrib.staticfiles\",\n    \"users.apps.UsersConfig\",\n]\n\nMIDDLEWARE = [ # OMITTED FOR BREVITY ]\nROOT_URLCONF = \"decoupled_dj.urls\"\nTEMPLATES = [ # OMITTED FOR BREVITY ]\nWSGI_APPLICATION = \"decoupled_dj.wsgi.application\n\nDATABASES = {\"default\": env.db()\nAUTH_PASSWORD_VALIDATORS = [ # OMITTED FOR BREVITY ]\nLANGUAGE_CODE = \"en-GB\"\nTIME_ZONE = \"UTC\"\nUSE_I18N = True\nUSE_L10N = True\nUSE_TZ = Tru\nSTATIC_URL = env(\"STATIC_URL\")\nAUTH_USER_MODEL = \"users.User\"\n</code></pre> <p>Note  I have omitted for brevity the complete code for the following configurations: MIDDLEWARE, TEMPLATES, and AUTH_PASSWORD_VALIDATORS. These should have the default values that come from stock Django.</p> <p>Next up we create an .env file in the <code>decoupled_dj/settings</code> folder. This file will have different values depending on the environment. For development we use the values in Listing.</p> <p>Environment File for Development</p> .env<pre><code>DEBUG=yes\nSECRET_KEY=!changethis!\nDATABASE_URL=psql://decoupleddjango:localpassword@127.0.0.1/decoupleddjango\nSTATIC_URL=/static/\n</code></pre> <p>If you want to use SQLite in place of Postgres, change DATABASE_URL to:</p> <pre><code>DATABASE_URL=sqlite:/decoupleddjango.sqlite3\n</code></pre> <p>To complete the setup, create a new file called <code>decoupled_dj/settings/development.py</code> and import everything from the base settings. In addition, we also customize the configuration. Here we are going to enable <code>django-extensions</code>, a handy library for Django in development</p> <p>The Settings File for Development</p> settings/development.py<pre><code># noqa\nfrom .base import *\nINSTALLED_APPS = INSTALLED_APPS + [\"django_extensions\"]\n</code></pre> <p>Let\u2019s also install the library:</p> <pre><code>pip install django-extensions\n</code></pre>"},{"location":"backend/package/django-environ/#use-allowed_hosts-in-env","title":"Use <code>ALLOWED_HOSTS</code> in <code>.env</code>","text":"settings.py<pre><code># settings.py\n\nimport environ\n\n# Initialize environment variables\nenv = environ.Env()\nenviron.Env.read_env()\n\n# SECURITY WARNING: don't run with debug turned on in production!\nDEBUG = env.bool('DEBUG', default=False)\n\n# SECURITY WARNING: keep the secret key used in production secret!\nSECRET_KEY = env('SECRET_KEY', default='your-default-secret-key')\n\n# Define ALLOWED_HOSTS based on DEBUG\nif DEBUG:\n    ALLOWED_HOSTS = ['*']  # Allow all hosts during development\nelse:\n    ALLOWED_HOSTS = env.list('ALLOWED_HOSTS', default=['.example.com'])\n\n# Other settings...\n</code></pre>"},{"location":"backend/package/django-environ/#env","title":"<code>.env</code>","text":".env<pre><code>DEBUG=False\nSECRET_KEY=your-production-secret-key\nALLOWED_HOSTS=.example.com,.anotherdomain.com\n</code></pre>"},{"location":"backend/package/django-environ/#reference","title":"Reference","text":"<ul> <li>Decoupled Django :pg-56</li> <li>12-Factor Pattern</li> <li>django-environ: readthedocs</li> <li>django-environ: github</li> </ul>"},{"location":"backend/package/django-extensions/","title":"django extensions","text":""},{"location":"backend/package/django-extensions/#django-extensions","title":"django-extensions","text":""},{"location":"backend/package/django-extensions/#install","title":"Install","text":"<pre><code>pip install django-extensions\n</code></pre> <p>The Settings File for Development</p> settings/development.py<pre><code># noqa\nfrom .base import *\nINSTALLED_APPS = INSTALLED_APPS + [\"django_extensions\"]\n</code></pre> <p></p>"},{"location":"backend/package/django-extensions/#reference","title":"Reference","text":"<ul> <li> <p>Decoupled Django :pg-56</p> </li> <li> <p>django-extension: readthedocs</p> </li> </ul>"},{"location":"backend/package/django-filter/","title":"django filter","text":"<p>Django-filter is a reusable Django application for allowing users to filter querysets dynamically.</p> <p>Installation</p> <pre><code>pip install django-filter\n</code></pre> <p>Then add <code>django_filters</code> to your INSTALLED_APPS.</p> <pre><code>INSTALLED_APPS = [\n    ...\n    'django_filters',\n]\n</code></pre> Example ModelFilterSetViewTemplateURL Configuration <p>Define a Model</p> <p>Let's say you have a simple model called <code>Book</code>:</p> <pre><code>from django.db import models\n\nclass Book(models.Model):\n    title = models.CharField(max_length=100)\n    author = models.CharField(max_length=100)\n    publication_date = models.DateField()\n    isbn = models.CharField(max_length=13)\n\n    def __str__(self):\n        return self.title\n</code></pre> <p>Create a FilterSet:</p> <p>Next, you create a filter set for the <code>Book</code> model. A filter set defines which fields you want to filter and how:</p> <pre><code>import django_filters\nfrom .models import Book\n\nclass BookFilter(django_filters.FilterSet):\n    class Meta:\n        model = Book\n        fields = ['title', 'author', 'publication_date']\n</code></pre> <p>Create a View:</p> <p>Then, you create a view that uses the filter set to filter the books. You can use Django's class-based views for this. Here, we'll use the generic <code>ListView</code> and integrate the filter:</p> <pre><code>from django.shortcuts import render\nfrom django.views.generic import ListView\nfrom django_filters.views import FilterView\nfrom .models import Book\nfrom .filters import BookFilter\n\nclass BookListView(FilterView, ListView):\n    model = Book\n    context_object_name = 'books'\n    template_name = 'books/book_list.html'\n    filterset_class = BookFilter\n</code></pre> <p>Create a Template:</p> <p>Finally, create a template <code>book_list.html</code> to display the filtered list of books:</p> <pre><code>&lt;!-- books/templates/books/book_list.html --&gt;\n\n&lt;form method=\"get\"&gt;\n    {{ filter.form.as_p }}\n    &lt;button type=\"submit\"&gt;Search&lt;/button&gt;\n&lt;/form&gt;\n\n&lt;ul&gt;\n{% for book in books %}\n    &lt;li&gt;{{ book.title }} by {{ book.author }} ({{ book.publication_date }})&lt;/li&gt;\n{% endfor %}\n&lt;/ul&gt;\n</code></pre> <p>Add URL Configuration:</p> <p>Add a URL pattern to map to the <code>BookListView</code>:</p> <pre><code>from django.urls import path\nfrom .views import BookListView\n\nurlpatterns = [\n    path('books/', BookListView.as_view(), name='book_list'),\n]\n</code></pre> <p>How It Works</p> <ul> <li>When you navigate to <code>/books/</code>, the <code>BookListView</code> will be rendered.</li> <li>The BookFilter form will be displayed, allowing you to filter books by <code>title</code>, <code>author</code>, and <code>publication_date</code>.</li> <li>Once you submit the form, the view will filter the <code>Book</code> objects based on the criteria you specified and display the filtered list.</li> </ul> <p>This setup leverages django-filter to simplify the filtering of querysets, providing a clean and intuitive user interface for filtering data.</p>"},{"location":"backend/package/django-filter/#reference","title":"Reference","text":"<ul> <li>django-filter: pypi</li> <li>django-filter.readthedocs</li> </ul>"},{"location":"backend/package/django-recaptcha/","title":"django recaptcha","text":""},{"location":"backend/package/django-recaptcha/#installation","title":"Installation","text":"<ol> <li>Sign up for reCAPTCHA.</li> <li>Install with pip install <code>django-recaptcha</code>.</li> <li>Add <code>django_recaptcha</code> to your INSTALLED_APPS setting.</li> </ol> <pre><code>INSTALLED_APPS = [\n    ...,\n    'django_recaptcha',\n    ...\n]\n</code></pre>"},{"location":"backend/package/django-recaptcha/#for-example","title":"For example:","text":"<p>.env.example</p> <pre><code>RECAPTCHA_PUBLIC_KEY = 'MyRecaptchaKey123'\nRECAPTCHA_PRIVATE_KEY = 'MyRecaptchaPrivateKey456'\n</code></pre> <p>settings.py</p> <pre><code>from dotenv import load_dotenv\n\n#RECAPTCHA\nRECAPTCHA_PUBLIC_KEY = os.environ.get('RECAPTCHA_PUBLIC_KEY')\nRECAPTCHA_PRIVATE_KEY = os.environ.get('RECAPTCHA_PRIVATE_KEY')\nRECAPTCHA_DOMAIN = 'www.recaptcha.net'\n</code></pre>"},{"location":"backend/package/django-recaptcha/#usage","title":"Usage","text":"<p>Fields</p> <p>The quickest way to add reCAPTCHA to a form is to use the included <code>ReCaptchaField</code> field class. A <code>ReCaptchaV2Checkbox</code> will be rendered by default. For example:</p> <pre><code>from django import forms\nfrom django_recaptcha.fields import ReCaptchaField\n\nclass FormWithCaptcha(forms.Form):\n    captcha = ReCaptchaField()\n</code></pre> <p>Be sure to include the captcha field in your forms. There are many ways to add fields to forms in Django. We recommend you refer to the form rendering options and rendering fields manually sections of the official Django documentation for forms.</p> <p>To allow for runtime specification of keys you can optionally pass the <code>private_key</code> or <code>public_key</code> parameters to the constructor. For example:</p> <pre><code>captcha = ReCaptchaField(\n    public_key='76wtgdfsjhsydt7r5FFGFhgsdfytd656sad75fgh',\n    private_key='98dfg6df7g56df6gdfgdfg65JHJH656565GFGFGs',\n)\n</code></pre> <p>If specified, these parameters will be used instead of your reCAPTCHA project settings.</p> <p>Widgets</p> <p>There are three widgets that can be used with the ReCaptchaField class:</p> <ul> <li><code>ReCaptchaV2Checkbox</code> for Google reCAPTCHA V2 - Checkbox</li> <li><code>ReCaptchaV2Invisible</code> for Google reCAPTCHA V2 - Invisible</li> <li><code>ReCaptchaV3</code> for Google reCAPTCHA V3</li> </ul> <p>To make use of widgets other than the default Google reCAPTCHA V2 - Checkbox widget, simply replace the <code>ReCaptchaField</code> widget. For example:</p> <pre><code>from django import forms\nfrom django_recaptcha.fields import ReCaptchaField\nfrom django_recaptcha.widgets import ReCaptchaV2Invisible\n\nclass FormWithCaptcha(forms.Form):\n    captcha = ReCaptchaField(widget=ReCaptchaV2Invisible)\n</code></pre>"},{"location":"backend/package/django-recaptcha/#reference","title":"Reference","text":"<ul> <li>django-recaptcha: pypi</li> <li>captcha: djangopackages.org</li> </ul>"},{"location":"backend/package/django-simple-history/","title":"django simple history","text":""},{"location":"backend/package/django-simple-history/#audit-logging","title":"Audit Logging","text":"<p>Audit logging refers to the practice of writing logs for each action carried in a system\u2014be it a web application, a REST API, or a database\u2014as a way to record \u201cwho did what\u201d at a particular point in time.</p> <p>Out of the box, Django already provides some minimal form of audit logging in the admin. Also, the user table in Django records the last login of each user in the system.</p> <p>But these two trails are far from being a full-fledged audit logging solution and do not cover the REST API. There are a couple of packages for Django to add audit logging capabilities:</p> <p>Note</p> <ul> <li>django-simple-history</li> <li>django-auditlog</li> </ul> <p><code>django-simple-history</code> can track changes on models. This capability, paired with access logging, can provide effective audit logging for Django projects. <code>django-simple-\u00adhistory</code> is a mature package, actively supported. </p> <p>On the other hand, <code>django-auditlog</code>provides the same functionalities, but it is still in development at the time of this writing.</p>"},{"location":"backend/package/django-simple-history/#install","title":"Install","text":"bash<pre><code>pip install django-simple-history\n</code></pre>"},{"location":"backend/package/django-simple-history/#reference","title":"Reference","text":"<ul> <li>django-simple-history :readthedocs</li> <li> django-auditlog : readthedocs</li> </ul> <p>Book</p> <ul> <li>Decoupled Django :pg-</li> </ul>"},{"location":"backend/package/django-taggit/","title":"django taggit","text":""},{"location":"backend/package/django-taggit/#installation","title":"Installation","text":"<pre><code>$ pip install django-taggit\n</code></pre> <p>Add <code>taggit</code> to your project\u2019s INSTALLED_APPS setting.</p> <pre><code>from django.db import models\n\nfrom taggit.managers import TaggableManager\n\nclass Food(models.Model):\n    # ... fields here\n\n    tags = TaggableManager()\n</code></pre>"},{"location":"backend/package/django-taggit/#related-blogs","title":"Related Blogs","text":"<p>To display the title of the other suggested blogs as clickable links in your <code>NewsDetailsView</code>, you can modify the template to include links to the suggested blog items. Here's how you can do it:</p> <p>Tip</p> models.pyviews.pyadmin.pyitem.html <pre><code>from django.db import models\nfrom django.urls import reverse\nfrom taggit.managers import TaggableManager\n\nclass NewsItem(models.Model):\n    title = models.CharField(max_length=100)\n    content = models.TextField()\n    tags = TaggableManager()\n    # Other fields as needed\n\n    def __str__(self):\n        return self.title\n\n    def get_absolute_url(self):\n        return reverse('news_detail', kwargs={'slug': self.slug})\n\n    def get_related_blogs(self):\n        return NewsItem.objects.filter(tags__in=self.tags.all()).exclude(id=self.id).distinct()[:5]\n</code></pre> <pre><code>class NewsDetailsView(DetailView):\n    model = NewsItem\n    template_name = \"news/item.html\"\n    context_object_name = \"news_detail\"\n    slug_field = \"slug\"\n\n    def get_context_data(self, **kwargs):\n        context = super().get_context_data(**kwargs)\n        context['related_blogs'] = self.object.get_related_blogs()\n        return context\n</code></pre> <pre><code>@admin.register(NewsItem)\nclass NewsItemAdmin(admin.ModelAdmin):\n    formfield_overrides = {\n        models.CharField: { 'widget': CustomCharFieldWidget }\n    }\n    list_display = ('title', 'content', 'status',  'tag_list', 'publish')\n\n    def get_queryset(self, request):\n        return super().get_queryset(request).prefetch_related('tags')\n\n    def tag_list(self, obj):\n        return u\", \".join(o.name for o in obj.tags.all())\n</code></pre> <pre><code>{% extends 'base.html' %}\n\n{% block content %}\n\n&lt;section class=\"bt-news bt-section-common\"&gt;\n    &lt;div class=\"container\"&gt;\n        &lt;div class=\"row\"&gt;\n\n            &lt;!-- RELATED BLOGS --&gt;\n            &lt;div class=\"col-md-12\"&gt;\n                {% if related_blogs %}\n                    &lt;h3&gt;Related Blogs:&lt;/h3&gt;\n                    &lt;ul&gt;\n                        {% for blog in related_blogs %}\n                            &lt;li&gt;&lt;a href=\"{{ blog.get_absolute_url }}\"&gt;{{ blog.title }}&lt;/a&gt;&lt;/li&gt;\n                        {% endfor %}\n                    &lt;/ul&gt;\n                {% endif %}\n            &lt;/div&gt;\n        &lt;/div&gt;\n    &lt;/div&gt;\n&lt;/section&gt;\n\n{% endblock %}\n</code></pre>"},{"location":"backend/package/django-taggit/#tags","title":"Tags","text":"<p>To include the <code>tags</code> associated with a NewsItem instance in your <code>NewsDetailsView</code>, you can modify the <code>get_context_data</code> method to pass the tags along with other context data. Here's how you can do it:</p> <pre><code>class NewsDetailsView(DetailView):\n    model = NewsItem\n    template_name = \"news/item.html\"\n    context_object_name = \"news_detail\"\n    slug_field = \"slug\"\n\n    def get_context_data(self, **kwargs):\n        context = super().get_context_data(**kwargs)\n        # Retrieve tags associated with the NewsItem instance\n        context['tags'] = self.object.tags.all()\n        return context\n</code></pre> <p>Now, in your <code>news/item.html</code> template, you can access these tags:</p> <pre><code>&lt;!-- news/item.html --&gt;\n&lt;h1&gt;{{ news_detail.title }}&lt;/h1&gt;\n&lt;!-- Other details of the news item --&gt;\n&lt;ul&gt;\n    {% for tag in tags %}\n        &lt;li&gt;{{ tag.name }}&lt;/li&gt;\n    {% endfor %}\n&lt;/ul&gt;\n</code></pre> <p>This will display all the tags associated with the <code>NewsItem</code> instance in your <code>NewsDetailsView</code>. Make sure you have properly associated tags with your <code>NewsItem</code> instances.</p>"},{"location":"backend/package/django-taggit/#reference","title":"Reference","text":"<ul> <li>django-taggit</li> </ul>"},{"location":"backend/package/intro/","title":"Intro","text":""},{"location":"backend/package/intro/#3rd-package","title":"3rd package","text":""},{"location":"backend/package/intro/#creating-image-thumbnails-using-easy-thumbnails","title":"Creating image thumbnails using easy-thumbnails","text":"<p>We are displaying the original image on the detail page, but dimensions for different images may vary considerably. The file size for some images may be very large, and loading them might take too long.</p> <p>The best way to display optimized images in a uniform manner is to generate thumbnails. A thumbnail is a small image representation of a larger image. Thumbnails will load faster in the browser and are a great way to homogenize images of very different sizes. We will use a Django application called easy-thumbnails to generate thumbnails for the images bookmarked by users.</p> <pre><code>pip install easy-thumbnails==2.8.1\n</code></pre> <pre><code>INSTALLED_APPS = [\n    # ...\n    'easy_thumbnails',\n]\n</code></pre> <p>The easy-thumbnails application offers you different ways to define image thumbnails. The application provides a <code>{% thumbnail %}</code> template tag to generate thumbnails in templates and a custom ImageField if you want to define thumbnails in your models. Let\u2019s use the template tag approach.</p> <p>Edit the <code>images/image/detail.html</code> template and consider the following line:</p> <pre><code>&lt;img src=\"{{ image.image.url }}\" class=\"image-detail\"&gt;\n</code></pre> <p>The following lines should replace the preceding one:</p> <pre><code>{% load thumbnail %}\n\n&lt;a href=\"{{ image.image.url }}\"&gt;\n    &lt;img src=\"{% thumbnail image.image 300x0 %}\" class=\"image-detail\"&gt;\n&lt;/a&gt;\n</code></pre> <p>We have defined a thumbnail with a fixed width of 300 pixels and a flexible height to maintain the aspect ratio by using the value 0. The first time a user loads this page, a thumbnail image will be created. The thumbnail is stored in the same directory as the original file. The location is defined by the MEDIA_ROOT setting and the <code>upload_to</code> attribute of the image field of the Image model. The generated thumbnail will then be served in the following requests.</p> <p>The original filename is followed by additional details of the settings used to create the thumbnail. For a JPEG image, you will see a filename like filename.jpg.300x0_q85.jpg, where 300x0 are the size parameters used to generate the thumbnail, and 85 is the value for the default JPEG quality used by the library to generate the thumbnail.</p> <p>You can use a different quality value using the quality parameter. To set the highest JPEG quality, you can use the value 100, like this: <code>{% thumbnail image.image 300x0 quality=100 %}</code>. A higher quality will imply a larger file size.</p> <p>The easy-thumbnails application offers several options to customize your thumbnails, including cropping algorithms and different effects that can be applied. If you run into any issues generating thumbnails, you can add THUMBNAIL_DEBUG = True to the settings.py file to obtain the debug information. You can read the full documentation of easy-thumbnails at easy-thumbnails.readthedocs.io.</p>"},{"location":"backend/package/intro/#adding-the-tagging-functionality","title":"Adding the tagging functionality","text":"<p>A very common functionality in blogs is to categorize posts using tags. Tags allow you to categorize content in a non-hierarchical manner, using simple keywords. A tag is simply a label or keyword that can be assigned to posts. We will create a tagging system by integrating a third-party Django tagging application into the project.</p> <p>django-taggit is a reusable application that primarily offers you a Tag model and a manager to easily add tags to any model. You can take a look at its source code at https://github.com/jazzband/django-taggit.</p> <p>First, you need to install django-taggit via pip by running the following command:</p> <pre><code>pip install django-taggit==3.0.0\n</code></pre> <p>Then, open the <code>settings.py</code> file of the mysite project and add taggit to your INSTALLED_APPS setting, as follows:</p> <pre><code>INSTALLED_APPS = [\n    'django.contrib.admin',\n    'django.contrib.auth',\n    'django.contrib.contenttypes',\n    'django.contrib.sessions',\n    'django.contrib.messages',\n    'django.contrib.staticfiles',\n    'blog.apps.BlogConfig',\n    'taggit',\n]\n</code></pre> <p>Open the <code>models.py</code> file of your blog application and add the TaggableManager manager provided by django-taggit to the Post model using the following code:</p> <pre><code>from taggit.managers import TaggableManager\n\nclass Post(models.Model):\n    # ...\n    tags = TaggableManager()\n</code></pre> <p>The tags manager will allow you to add, retrieve, and remove tags from Post objects.</p> <p>The Tag model is used to store tags. It contains a name and a slug field.</p>"},{"location":"backend/package/intro/#creating-custom-template-tags-and-filters","title":"Creating custom template tags and filters","text":"<p>Django provides the following helper functions that allow you to easily create template tags:</p> <ul> <li>simple_tag: Processes the given data and returns a string</li> <li>inclusion_tag: Processes the given data and returns a rendered template</li> </ul> <p>Template tags must live inside Django applications.</p>"},{"location":"backend/package/intro/#cleaning-form-fields","title":"Cleaning form fields","text":"forms.py<pre><code>def clean_url(self):\n    url = self.cleaned_data['url']\n    valid_extensions = ['jpg', 'jpeg', 'png']\n    extension = url.rsplit('.', 1)[1].lower()\n    if extension not in valid_extensions:\n        raise forms.ValidationError('The given URL does not match valid image extensions.')\n    return url\n</code></pre>"},{"location":"backend/package/intro/#reference","title":"Reference","text":"<ul> <li>[Django 4 by example: pg-265]</li> </ul>"},{"location":"backend/package/python-dotenv/","title":"python dotenv","text":""},{"location":"backend/package/python-dotenv/#python-dotenv","title":"Python-dotenv","text":"<p>Python-dotenv reads key-value pairs from a .env file and can set them as environment variables</p> <pre><code>$ pip install python-dotenv\n</code></pre> <pre><code>// .env.example\n</code></pre> <ul> <li>python-dotenv</li> </ul>"},{"location":"backend/package/python-mysqlclient/","title":"mysqlclient","text":""},{"location":"backend/package/python-mysqlclient/#_1","title":"mysqlclient","text":"<pre><code>$ pip install mysqlclient\n</code></pre> <ul> <li>mysqlclient </li> </ul>"},{"location":"backend/package/simplejwt/","title":"simplejwt","text":""},{"location":"backend/package/simplejwt/#jwt","title":"jwt","text":"<p>Example</p> InstallationVirtual envsettings.py.env example <pre><code>pip install django\n\npip install djangorestframework-simplejwt\n\n# env\npip install python-dotenv\n\n# database\npip install mysqlclient\n\n# Django REST framework\npip install djangorestframework, markdown, django-filter\n</code></pre> <pre><code>INSTALLED_APPS = [\n    ...'\n    'rest_framework',\n    'rest_framework_simplejwt',\n    ...\n]\n</code></pre> <pre><code>$ python -m venv venv\n$ cd venv/Scripts\n$ activate\n</code></pre> <pre><code># settings.py\nfrom dotenv import load_dotenv\nimport os\n\nload_dotenv()\n\nSECRET_KEY = os.environ.get('SECRET_KEY')\n\n# Database\nDATABASES = {\n    'default': {\n        'ENGINE': 'django.db.backends.mysql',\n        'NAME': os.environ.get('DB_NAME'), #here\n        'USER': os.environ.get('DB_USER'), #here\n        'PASSWORD': os.environ.get('DB_PASS'), #here\n        'HOST': '127.0.0.1',\n        'PORT': '3306',\n        'OPTIONS': {'init_command': \"SET sql_mode='STRICT_TRANS_TABLES'\"},\n    }\n}\n\n# Add\nREST_FRAMEWORK = {\n    'DEFAULT_AUTHENTICATION_CLASSES': [\n        'rest_framework_simplejwt.authentication.JWTAuthentication',\n        'rest_framework.authentication.SessionAuthentication',\n    ],\n}\n</code></pre> <pre><code>SECRET_KEY=\"\"\nDB_NAME=django_db\nDB_USER=root\nDB_PASS=\nDB_HOST=localhost\nDB_PORT=3308\n</code></pre>"},{"location":"backend/package/simplejwt/#simple-jwt","title":"Simple JWT","text":"<p>Simple JWT provides a JSON Web Token authentication backend for the Django REST Framework. A JSON Web Token authentication plugin for the Django REST Framework.</p> <p>Installation</p> <pre><code>pip install djangorestframework-simplejwt\n</code></pre> <p>Tip</p> <pre><code># add rest_framework_simplejwt to INSTALLED_APPS.\n\nINSTALLED_APPS = [\n    ...\n    'rest_framework_simplejwt',\n    ...\n]\n</code></pre>"},{"location":"backend/package/simplejwt/#project-configuration","title":"Project Configuration","text":"<p>Then, your django project must be configured to use the library. In <code>settings.py</code>, add <code>rest_framework_simplejwt.authentication.JWTAuthentication</code> to the list of authentication classes:</p> <p>Tip</p> <pre><code>REST_FRAMEWORK = {\n    ...\n    'DEFAULT_AUTHENTICATION_CLASSES': (\n        ...\n        'rest_framework_simplejwt.authentication.JWTAuthentication',\n    )\n    ...\n}\n</code></pre> <p>Also, in your root <code>urls.py</code> file (or any other url config), include routes for Simple JWT\u2019s <code>TokenObtainPairView</code> and <code>TokenRefreshView</code> views:</p> <p>Tip</p> <pre><code>from rest_framework_simplejwt.views import (\n    TokenObtainPairView,\n    TokenRefreshView,\n)\n\nurlpatterns = [\n    ...\n    path('api/token/', TokenObtainPairView.as_view(), name='token_obtain_pair'),\n    path('api/token/refresh/', TokenRefreshView.as_view(), name='token_refresh'),\n    ...\n]\n</code></pre>"},{"location":"backend/package/simplejwt/#reference","title":"Reference","text":"<ul> <li>Simple JWT</li> <li>Django Environment - python-dotenv</li> <li>python-dotenv</li> <li>Generating Secret key in django app</li> <li>mkdocs dropdown - github</li> <li>mkdocs dropdown - stackoverflow </li> </ul>"},{"location":"backend/package/social-auth-app-django/","title":"social auth app django","text":"<p>Python Social Auth is an easy to setup social authentication/registration mechanism with support for several frameworks and auth providers.</p> <pre><code>$ pip install social-auth-app-django\n</code></pre> settings.py<pre><code>INSTALLED_APPS = (\n    ...\n    'social_django',\n    ...\n)\n</code></pre> urls.py<pre><code>urlpatterns = [\n    ...\n    url('', include('social_django.urls', namespace='social'))\n    ...\n]\n</code></pre>"},{"location":"backend/package/social-auth-app-django/#reference","title":"Reference","text":"<ul> <li>python-social-auth.readthedocs</li> </ul>"},{"location":"backend/package/tinymce/","title":"tinymce","text":"<pre><code># 1: Install django-tinymce using pip\npip install django-tinymce\n\n# 2: Add tinymce to INSTALLED_APPS in settings.py for your project:\n\nINSTALLED_APPS = (\n    ...\n    'tinymce',\n    ...\n)\n\n# 3: Add tinymce.urls to urls.py for your project:\n\nurlpatterns = patterns('',\n    ...\n    path('tinymce/', include('tinymce.urls')),\n    ...\n)\n</code></pre>"},{"location":"backend/package/tinymce/#reference","title":"Reference","text":"<ul> <li>tinymce: Django Editor</li> </ul>"},{"location":"backend/tools/intro/","title":"Intro","text":"<p>To become a top-tier Python programmer, it's important to master a range of tools and technologies beyond pyenv and pipenv. Here are some key areas and tools you should consider:</p> <p>1. Package Management and Virtual Environments</p> <ul> <li><code>virtualenv</code>: A tool for creating isolated Python environments. Although pipenv is an alternative, knowing virtualenv is still valuable.</li> <li><code>conda</code>: A package manager and environment manager that supports multiple languages, including Python. It's commonly used in data science and machine learning.</li> </ul> <p>2. Version Control</p> <ul> <li><code>Git</code>: A distributed version control system. Mastering Git, including branching, merging, and rebasing, is crucial for collaborative development.</li> <li><code>GitHub/GitLab/Bitbucket</code>: Platforms for hosting Git repositories, code reviews, and continuous integration.</li> </ul> <p>3. Testing Frameworks</p> <ul> <li><code>pytest</code>: A testing framework that makes it easy to write simple and scalable test cases.</li> <li><code>unittest</code>: The built-in Python testing framework. It\u2019s good to understand its structure as it\u2019s widely used.</li> <li><code>tox</code>: A tool for testing across multiple Python environments.</li> </ul> <p>4. Development Tools</p> <ul> <li><code>black</code>: An opinionated code formatter that helps maintain code consistency.</li> <li><code>flake8</code>: A linting tool that checks for style violations and programming errors.</li> <li><code>mypy</code>: A static type checker for Python, which helps catch type errors before runtime.</li> </ul> <p>5. Build Tools</p> <ul> <li><code>setuptools</code>: A library for packaging Python projects. It\u2019s important for distributing your Python packages.</li> <li><code>wheel</code>: A packaging format for Python that helps in building and distributing packages.</li> </ul> <p>6. Dependency Management</p> <ul> <li><code>poetry</code>: An alternative to pipenv for dependency management and packaging. It simplifies managing dependencies and packaging projects.</li> </ul> <p>7. Web Development Frameworks</p> <ul> <li><code>Django</code>: A high-level web framework for building robust and scalable web applications.</li> <li><code>Flask</code>: A lightweight web framework for creating simple and flexible web applications.</li> </ul> <p>8. Asynchronous Programming</p> <ul> <li><code>asyncio</code>: A library for writing concurrent code using the async/await syntax.</li> <li><code>aiohttp</code>: A library for asynchronous HTTP requests.</li> </ul> <p>9. Database Management</p> <ul> <li><code>SQLAlchemy</code>: An ORM (Object-Relational Mapping) library for working with databases in a Pythonic way.</li> <li><code>Django ORM</code>: The built-in ORM for Django, useful if you're working with Django projects.</li> <li><code>Alembic</code>: A lightweight database migration tool for use with SQLAlchemy.</li> </ul> <p>10. APIs and Web Services</p> <ul> <li><code>requests</code>: A simple and elegant HTTP library for making API requests.</li> <li><code>FastAPI</code>: A modern, fast (high-performance) web framework for building APIs with Python 3.6+ based on standard Python type hints.</li> </ul> <p>11. CI/CD Tools</p> <ul> <li><code>Jenkins</code>: An open-source automation server for building, deploying, and automating projects.</li> <li><code>GitHub Actions</code>: Integrated CI/CD workflows directly within GitHub repositories. Travis CI: A continuous integration service for building and testing code.</li> </ul> <p>12. Cloud Platforms</p> <ul> <li><code>AWS</code>: Amazon Web Services for cloud computing, storage, and more. Google Cloud Platform (GCP): Cloud services from Google.</li> <li><code>Azure</code>: Microsoft\u2019s cloud computing service.</li> </ul> <p>13. Containerization and Orchestration</p> <ul> <li><code>Docker</code>: A platform for developing, shipping, and running applications inside containers.</li> <li><code>Kubernetes</code>: An orchestration platform for managing containerized applications at scale.</li> </ul> <p>14. Performance and Profiling</p> <ul> <li><code>cProfile</code>: A built-in profiler to help identify performance bottlenecks in your code.</li> <li><code>timeit</code>: A module for measuring the execution time of small code snippets.</li> </ul> <p>15. Documentation</p> <ul> <li><code>Sphinx</code>: A tool for generating documentation for Python projects.</li> <li><code>MkDocs</code>: A static site generator that's geared towards project documentation.</li> </ul> <p>Mastering these tools and technologies will help you develop a broad skill set, making you a more effective and versatile Python programmer.</p>"},{"location":"backend/tools/intro/#package-vs-package-manager","title":"package <code>vs</code> package manager","text":"<p>The terms \"package installer\" and \"package manager\" are often used interchangeably, but they refer to slightly different concepts in the context of software and Python development. Here's a breakdown of the differences:</p> Package InstallerPackage Manager <p>A package installer is a tool or utility that primarily focuses on installing, updating, and removing packages (software libraries or modules). Its main function is to handle the installation of individual packages from a repository or source.</p> Characteristics: <ul> <li>Primary Function: Install, upgrade, and uninstall packages.</li> <li>Scope: Typically handles only the installation and management of packages.</li> <li>Examples:<ul> <li>pip (Python's package installer)</li> <li>npm (for Node.js)</li> <li>gem (for Ruby)</li> </ul> </li> </ul> pip<pre><code>pip install requests\n</code></pre> <p>A package manager encompasses a broader set of responsibilities beyond just installing packages. It typically includes the following features:</p> <ul> <li>Dependency Management: Manages dependencies between packages, ensuring that all required packages are installed with correct versions.</li> <li>Environment Management: May handle creating and managing isolated environments for different projects.</li> <li>Configuration Management: Can use configuration files (like <code>requirements.txt</code>, <code>Pipfile</code>, <code>pyproject.toml</code>) to define and lock dependencies.</li> <li>Version Control: Manages different versions of packages and resolves conflicts between them.</li> <li>Build Tools: Sometimes includes tools for building packages or projects.</li> <li>Distribution: May provide mechanisms to publish packages to repositories.</li> </ul> Characteristics: <ul> <li>Primary Function: Comprehensive management of packages and their dependencies, often including environment management.</li> <li>Scope: Handles more than just package installation, including configuration and environment management.</li> <li>Examples:<ul> <li>conda: Manages both packages and environments; can handle non-Python packages.</li> <li>poetry: Manages dependencies and packaging, using pyproject.toml.</li> <li>pipenv: Combines package installation and virtual environment management, using Pipfile and Pipfile.lock.</li> <li>pdm: Focuses on dependency management and building, using pyproject.toml.</li> <li>hatch: Offers project management, including dependency and environment management.</li> </ul> </li> </ul> conda<pre><code>conda create --name myenv python=3.9\nconda activate myenv\nconda install numpy\n</code></pre> Summary <ul> <li>Package Installer: Primarily deals with installing, upgrading, and removing packages. Examples include <code>pip</code> and <code>npm</code>.</li> <li>Package Manager: Provides a more comprehensive suite of tools for managing packages and their dependencies, often including environment management, version control, and configuration. Examples include <code>conda</code>, <code>poetry</code>, and <code>pipenv</code>.</li> </ul> <p>In essence, a package manager often includes a package installer as part of its functionality but offers additional features that make it a more holistic tool for managing software projects.</p>"},{"location":"backend/tools/intro/#package-manager","title":"Package Manager","text":"<ul> <li> <p> pip</p> <p>The default package installer for Python.</p> <p> Reference</p> </li> <li> <p> conda</p> <p>A package manager and environment manager from the Anaconda distribution.</p> <p> Reference</p> </li> <li> <p> poetry</p> <p>A dependency manager and build tool for Python projects.</p> <p> Reference</p> </li> <li> <p> pipenv</p> <p>A tool that combines <code>pip</code> and <code>virtualenv</code> into one for managing dependencies and virtual environments.</p> <p> Reference</p> </li> </ul>"},{"location":"backend/tools/pip/","title":"pip","text":"<p>pip is the package installer for Python. It allows you to install and manage additional libraries and dependencies that are not included in the Python standard library.</p>"},{"location":"backend/tools/pip/#installation-and-basic-usage","title":"Installation and Basic Usage","text":"<ul> <li> <p>Install a Package:</p> <pre><code>pip install requests\n</code></pre> </li> <li> <p>Uninstall a Package:</p> <pre><code>pip uninstall requests\n</code></pre> </li> <li> <p>Check Installed Packages:</p> <pre><code>pip list\n</code></pre> </li> <li> <p>Check for Package Updates:</p> <pre><code>pip list --outdated\n</code></pre> </li> </ul>"},{"location":"backend/tools/pip/#managing-dependencies","title":"Managing Dependencies","text":"<ul> <li> <p>Install from <code>requirements.txt</code>: Create a <code>requirements.txt</code> file with a list of packages and versions:</p> <pre><code>requests==2.28.1\nnumpy==1.24.2\n</code></pre> <p>Install dependencies:</p> <pre><code>pip install -r requirements.txt\n</code></pre> </li> <li> <p>Freeze Installed Packages: Generate a <code>requirements.txt</code> file from the current environment:</p> <pre><code>pip freeze &gt; requirements.txt\n</code></pre> </li> <li> <p>Upgrade a Package:</p> <pre><code>pip install --upgrade requests\n</code></pre> </li> </ul>"},{"location":"backend/tools/pip/#environment-and-compatibility","title":"Environment and Compatibility","text":"<ul> <li> <p>Create a Virtual Environment: Although <code>pip</code> itself doesn\u2019t create virtual environments, it works seamlessly with <code>venv</code> or <code>virtualenv</code>.</p> <pre><code>python -m venv myenv\n</code></pre> </li> <li> <p>Activate the Virtual Environment:</p> <ul> <li> <p>On Windows:</p> <pre><code>myenv\\Scripts\\activate\n</code></pre> </li> <li> <p>On macOS/Linux:</p> <pre><code>source myenv/bin/activate\n</code></pre> </li> </ul> </li> <li> <p>Check pip Version:</p> <pre><code>pip --version\n</code></pre> </li> <li> <p>Upgrade <code>pip</code>:</p> <pre><code>pip install --upgrade pip\n</code></pre> </li> </ul>"},{"location":"backend/tools/pip/#scripting-and-automation","title":"Scripting and Automation","text":"<ul> <li> <p>Install Multiple Packages in a Single Command:</p> <pre><code>pip install requests numpy pandas\n</code></pre> </li> <li> <p>Automate Package Installation: Use shell scripts or batch files to automate installation in multiple environments.</p> </li> </ul>"},{"location":"backend/tools/pip/#other","title":"Other","text":"<p>In pip, the concept of \"development\" dependencies (i.e., packages needed only for development, not for production) is not directly supported in the same way as some other tools like Poetry or Pipenv. However, you can manage development dependencies in a few ways using pip:</p> <ol> <li> <p>Using <code>requirements.txt</code> with Separate Files</p> <p>You can maintain separate <code>requirements.txt</code> files for different environments, such as one for production and one for development.</p> Production <code>requirements.txt</code>: <ul> <li> <p>List only the packages required for your application to run in production</p> <pre><code>requests==2.28.1\nnumpy==1.24.2\n</code></pre> </li> </ul> Development <code>requirements-dev.txt</code>: <ul> <li> <p>List the additional packages needed for development, such as testing and linting tools.</p> <pre><code>pytest==7.4.0\nflake8==6.0.0\n</code></pre> </li> </ul> <p>To install production dependencies:</p> <pre><code>pip install -r requirements.txt\n</code></pre> <p>To install development dependencies:</p> <pre><code>pip install -r requirements-dev.txt\n</code></pre> <p>Alternatively, you can include development dependencies in a single file with markers or comments, and install them conditionally.</p> </li> </ol>"},{"location":"backend/tools/pipenv/","title":"Pipenv","text":""},{"location":"backend/tools/pipenv/#what-is-pipenv","title":"What is Pipenv?","text":"<p><code>pipenv</code> is a tool that combines <code>pip</code> (Python\u2019s package installer) and <code>virtualenv</code> (a tool to create isolated Python environments) into one workflow. It simplifies dependency management for Python projects by automatically creating and managing a virtual environment and handling package installation.</p>"},{"location":"backend/tools/pipenv/#key-features-of-pipenv","title":"Key Features of Pipenv:","text":"<ul> <li>Virtual Environment Management: Automatically creates a virtual environment for your project.</li> <li>Dependency Management: Uses a <code>Pipfile</code> to manage project dependencies, and a <code>Pipfile.lock</code> to ensure deterministic builds.</li> <li>Security: Checks for known security vulnerabilities in the dependencies you install.</li> <li>Easy Project Setup: Simplifies the setup process for new projects by managing dependencies and environments automatically.</li> </ul>"},{"location":"backend/tools/pipenv/#when-to-use-pipenv","title":"When to Use Pipenv:","text":"<ul> <li>Project Dependency Management: When you want to easily manage dependencies and virtual environments for a project.</li> <li>Isolated Development Environments: When you want to ensure that each project has its own isolated environment with specific dependencies.</li> <li>Reproducibility: When you want to ensure that others can replicate your development environment exactly, using the <code>Pipfile.lock</code>.</li> </ul> When to Use <p>Use <code>pipenv</code> when you need to manage dependencies for a specific project and want to create an isolated environment for that project, ensuring that dependencies are consistent across different environments and machines.</p>"},{"location":"backend/tools/pipenv/#example","title":"Example","text":"<pre><code># 1. Create a New Virtual Environment with a Specific Python Version\npipenv --python 3.9\n\n# 2. Install a Package and Add It to the Pipfile\npipenv install requests\n\n# 3. Install a Development Package and Add It to the Pipfile\npipenv install --dev pytest\n\n# 4. Activate the Virtual Environment Shell\npipenv shell\n\n# 5. Deactivate the Virtual Environment\nexit  # or use `deactivate` if not using `pipenv shell`\n\n# 6. Check the Installed Packages and Their Dependencies\npipenv graph\n\n# 7. Uninstall a Package and Remove It from the Pipfile\npipenv uninstall requests\n\n# 8. Generate a Lockfile for Deterministic Builds\npipenv lock\n\n# 9. Install All Dependencies from Pipfile.lock\npipenv sync\n\n# 10. Create a Pipenv Environment from an Existing requirements.txt\npipenv install -r requirements.txt\n\n# 11. List All Installed Virtual Environments Managed by Pipenv\npipenv --venv\n\n# 12. Remove the Virtual Environment and All Dependencies\npipenv --rm\n\n# 13. Update the Lockfile and Reinstall All Packages\npipenv update\n</code></pre> Differences Between Pyenv and Pipenv Feature Pyenv Pipenv Purpose Manage multiple Python versions Manage project dependencies and virtual environments Manages Python versions Python packages and virtual environments Global vs Local Can set global and local Python versions Manages dependencies per project Virtual Environment Does not create virtual environments Automatically creates and manages virtual environments Dependency Management No Yes, via <code>Pipfile</code> and <code>Pipfile.lock</code> Info <p>In many cases, you might use both tools together: pyenv to manage Python versions and pipenv to manage project-specific dependencies within the chosen Python version.</p>"},{"location":"backend/tools/pipenv/#1-understand-pipenv-basics","title":"1. Understand Pipenv Basics","text":"<ul> <li> <p>What is Pipenv?: Pipenv is a tool for managing Python dependencies, virtual environments, and project settings. It combines the functionality of <code>pip</code> and <code>virtualenv</code> into one tool.</p> </li> <li> <p>Key Files:</p> <ul> <li>Pipfile: Specifies your project dependencies.</li> <li>Pipfile.lock: Locks the dependencies to specific versions for consistent environments.</li> </ul> </li> </ul>"},{"location":"backend/tools/pipenv/#2-installation","title":"2. Installation","text":"<ul> <li> <p>Make sure you have Pipenv installed. You can install it via pip:</p> <pre><code>pip install pipenv\n</code></pre> </li> </ul>"},{"location":"backend/tools/pipenv/#3-creating-a-project","title":"3. Creating a Project","text":"<ol> <li> <p>Set Up a New Project: Navigate to your project directory and run:</p> <pre><code>pipenv install\n</code></pre> <p>This creates a new <code>Pipfile</code> in the directory.</p> </li> <li> <p>Install Dependencies: To install a new package, use:</p> <pre><code>pipenv install package_name\n</code></pre> <p>For development dependencies, use:</p> <pre><code>pipenv install package_name --dev\n</code></pre> </li> <li> <p>Lock Dependencies: Pipenv automatically updates the <code>Pipfile.lock</code> when you install or uninstall packages. You can also manually generate or update it with:</p> <pre><code>pipenv lock\n</code></pre> </li> </ol>"},{"location":"backend/tools/pipenv/#4-using-the-virtual-environment","title":"4. Using the Virtual Environment","text":"<ol> <li> <p>Activate the Virtual Environment:</p> <pre><code>pipenv shell\n</code></pre> <p>This spawns a new shell with the virtual environment activated.</p> </li> <li> <p>Run Commands in the Virtual Environment: Instead of activating the shell, you can run commands directly:</p> <pre><code>pipenv run python script.py\n</code></pre> </li> </ol>"},{"location":"backend/tools/pipenv/#5-managing-dependencies","title":"5. Managing Dependencies","text":"<ol> <li> <p>Remove Packages:</p> <pre><code>pipenv uninstall package_name\n</code></pre> <p>For development packages:</p> <pre><code>pipenv uninstall package_name --dev\n</code></pre> </li> <li> <p>Check for Security Issues:</p> <pre><code>pipenv check\n</code></pre> </li> <li> <p>Update Packages:</p> <pre><code>pipenv update\n</code></pre> </li> </ol>"},{"location":"backend/tools/pipenv/#6-advanced-usage","title":"6. Advanced Usage","text":"<ol> <li> <p>Specify Python Version: You can specify the Python version for your project in the <code>Pipfile</code>:</p> <pre><code>[requires]\npython_version = \"3.8\"\n</code></pre> </li> <li> <p>Environment Variables: Set environment variables for your project by adding them to <code>.env</code> files in your project directory.</p> </li> <li> <p>Work with Multiple Environments: Use the <code>Pipfile</code> to manage different environments, and <code>Pipenv</code> will help maintain them separately. </p> </li> </ol>"},{"location":"backend/tools/pipenv/#7-best-practices","title":"7. Best Practices","text":"<ol> <li> <p>Commit <code>Pipfile</code> and <code>Pipfile.lock</code>: Always commit both files to version control to ensure consistent environments across different machines.</p> </li> <li> <p>Avoid Mixing <code>pip</code> and <code>pipenv</code>: Stick to using <code>pipenv</code> for managing dependencies to avoid conflicts.</p> </li> <li> <p>Regularly Update Dependencies: Keep your dependencies up-to-date to benefit from security fixes and improvements.</p> </li> <li> <p>Leverage <code>pipenv graph</code>: Use this command to visualize your dependency tree and understand your project\u2019s dependency graph.</p> </li> </ol>"},{"location":"backend/tools/pipenv/#8-troubleshooting","title":"8. Troubleshooting","text":"<ul> <li> <p>Dependency Conflicts: If you encounter issues, try regenerating the <code>Pipfile.lock</code> by deleting it and running <code>pipenv lock</code> again.</p> </li> <li> <p>Environment Issues: Ensure that you\u2019re using the correct version of Python as specified in your <code>Pipfile</code>.</p> </li> </ul> <p>By following these steps and exploring Pipenv\u2019s documentation and commands, you\u2019ll become more adept at using it to manage your Python projects effectively.</p>"},{"location":"backend/tools/pyenv/","title":"Pyenv","text":""},{"location":"backend/tools/pyenv/#what-is-pyenv","title":"What is Pyenv?","text":"<p><code>pyenv</code> is a tool that allows you to easily switch between multiple versions of Python on your machine. It manages Python installations and allows you to set global or project-specific Python versions.</p>"},{"location":"backend/tools/pyenv/#key-features-of-pyenv","title":"Key Features of Pyenv:","text":"<ul> <li>Multiple Python Versions: Install and manage multiple versions of Python on the same system.</li> <li>Global Version Management: Set a global Python version that is used system-wide.</li> <li>Local Version Management: Set a Python version for a specific project directory, which overrides the global version.</li> <li>Version Switching: Easily switch between different Python versions using simple commands.</li> </ul>"},{"location":"backend/tools/pyenv/#when-to-use-pyenv","title":"When to Use Pyenv:","text":"<ul> <li>Managing Multiple Python Versions: If you work on projects that require different versions of Python (e.g., one project requires Python 2.7 and another Python 3.10).</li> <li>Isolating Python Versions: To avoid conflicts between projects that need different Python versions.</li> </ul> When to Use <p>Use <code>pyenv</code> when you need to switch between different versions of Python for different projects or want to ensure that you can run old or new Python code on your machine without conflicts.</p>"},{"location":"backend/tools/pyenv/#example","title":"Example","text":"<pre><code># 1. Install a Python Version\npyenv install 3.9.6\n\n# 2. List All Installed Python Versions\npyenv versions\n\n# 3. Set a Global Python Version\npyenv global 3.9.6\n\n# 4. Set a Local Python Version for a Project\ncd /path/to/project\npyenv local 3.8.10\n\n# 5. Display the Current Active Python Version\npyenv version\n\n# 6. Uninstall a Python Version\npyenv uninstall 3.7.9\n\n# 7. Display the Path to the Active Python Executable\npyenv which python\n\n# 8. Display Help for Pyenv Commands\npyenv help\n\n# 9. List All Available Python Versions for Installation\npyenv install --list\n\n# 10. Remove a Local Python Version for a Project\npyenv local --unset\n</code></pre> Differences Between Pyenv and Pipenv Feature Pyenv Pipenv Purpose Manage multiple Python versions Manage project dependencies and virtual environments Manages Python versions Python packages and virtual environments Global vs Local Can set global and local Python versions Manages dependencies per project Virtual Environment Does not create virtual environments Automatically creates and manages virtual environments Dependency Management No Yes, via <code>Pipfile</code> and <code>Pipfile.lock</code> Info <p>In many cases, you might use both tools together: <code>pyenv</code> to manage Python versions and <code>pipenv</code> to manage project-specific dependencies within the chosen Python version.</p>"},{"location":"blog/","title":"Index","text":""},{"location":"blog/#blog","title":"Blog","text":""},{"location":"blog/2024/05/06/active-link-in-django/","title":"Active link in django","text":"","tags":["Django","Python"]},{"location":"blog/2024/05/06/active-link-in-django/#active-link-in-django","title":"Active link in django","text":"<p>we'll explore different techniques to add an 'active' class to navigation elements based on the user's location, providing visual cues that enhance navigation clarity.</p>","tags":["Django","Python"]},{"location":"blog/2024/05/06/active-link-in-django/#method-1-url-comparison-with-template-tags","title":"Method 1: URL Comparison with Template Tags","text":"<p>method 1</p> <p>The first method involves straightforward URL comparison using Django's template tags. By comparing the request's path with the URLs associated with each navigation item, we can dynamically add the <code>active</code> class.</p> <pre><code>&lt;ul class=\"nav\"&gt;\n    &lt;li class=\"{% if request.path == '/' %}active{% endif %}\"&gt;\n        &lt;a href=\"/\"&gt;Home&lt;/a&gt;\n    &lt;/li&gt;\n    &lt;li class=\"{% if request.path == '/about/' %}active{% endif %}\"&gt;\n        &lt;a href=\"/about/\"&gt;About&lt;/a&gt;\n    &lt;/li&gt;\n    &lt;!-- Add more navigation items here --&gt;\n&lt;/ul&gt;\n</code></pre>","tags":["Django","Python"]},{"location":"blog/2024/05/06/active-link-in-django/#method-2-assigning-url-to-variables","title":"Method 2: Assigning URL to Variables","text":"<p>method 2</p> <p>A more organized approach involves assigning URLs to variables using Django's <code>{% url %}</code> tag. This allows for cleaner template code and easier maintenance.</p> <pre><code>{% url 'home' as home_url %}\n{% url 'about' as about_url %}\n\n&lt;ul class=\"nav\"&gt;\n    &lt;li class=\"{% if request.path == home_url %}active{% endif %}\"&gt;\n        &lt;a href=\"{% url 'home' %}\"&gt;Home&lt;/a&gt;\n    &lt;/li&gt;\n    &lt;li class=\"{% if request.path == about_url %}active{% endif %}\"&gt;\n        &lt;a href=\"{% url 'about' %}\"&gt;About&lt;/a&gt;\n    &lt;/li&gt;\n    &lt;!-- Add more navigation items here --&gt;\n&lt;/ul&gt;\n</code></pre>","tags":["Django","Python"]},{"location":"blog/2024/05/06/active-link-in-django/#method-3-url-prefix-comparison","title":"Method 3: URL Prefix Comparison","text":"<p>method 3</p> <p>For situations where multiple URLs share a common prefix, such as subpages, the startswith template filter can be utilized to simplify the code.</p> <pre><code>{% url 'home' as home_url %}\n{% url 'about' as about_url %}\n\n&lt;ul class=\"nav\"&gt;\n    &lt;li class=\"{% if request.path == home_url or request.path.startswith('/home/') %}active{% endif %}\"&gt;\n        &lt;a href=\"{% url 'home' %}\"&gt;Home&lt;/a&gt;\n    &lt;/li&gt;\n    &lt;li class=\"{% if request.path == about_url %}active{% endif %}\"&gt;\n        &lt;a href=\"{% url 'about' %}\"&gt;About&lt;/a&gt;\n    &lt;/li&gt;\n    &lt;!-- Add more navigation items here --&gt;\n&lt;/ul&gt;\n</code></pre>","tags":["Django","Python"]},{"location":"blog/2024/05/06/active-link-in-django/#conclusion","title":"Conclusion","text":"<p>Enhancing navigation with an <code>active</code> state in Django not only improves user experience but also adds a touch of professionalism to your website. By implementing one of these methods, you can guide users seamlessly through your site, ensuring they always know where they are. Choose the approach that best fits your project's requirements and coding style, and elevate your Django website's navigation to new heights.</p>","tags":["Django","Python"]},{"location":"blog/2024/05/06/active-link-in-django/#django-template-patterns","title":"Django Template Patterns","text":"<p>active link</p> <p>Pattern a the active link</p> <p>Problem: The navigation bar is a common component in most pages. However, the active link needs to reflect the current page the user is on.</p> <p>Solution: Conditionally, change the active link markup by setting context variables or based on the request <code>path</code>.</p> <p>Problem details</p> <p>The naive way to implement the active link in a navigation bar is to manually set it in every page. However, this is neither DRY nor foolproof.</p> <p>Solution details</p> <p>There are several solutions to determine the <code>active link</code>. Excluding JavaScript-based approaches, they can be mainly grouped into template-only and custom tag-based solutions.</p> A template only solutionCustom tags <p>In every template, you will need to include the following line (or inherit it):</p> <pre><code>{% include \"_navbar.html\" with active_link='link2' %}\n</code></pre> <p>The <code>_navbar.html</code> file contains the navigation menu with set of checks for the <code>active_link</code> variable:</p> <pre><code>{% _navbar.html %}\n\n&lt;ul class=\"nav nav-pills\"&gt;\n    &lt;li {% if active_link == \"link1\" %} class=\"active\" {% endif %}&gt;\n        &lt;a href=\"{% url 'link1 %}\"&gt;Link1&lt;/a&gt;\n    &lt;/li&gt;\n    &lt;li {% if active_link == \"link2\" %} class=\"active\" {% endif %}&gt;\n        &lt;a href=\"{% url 'link2 %}\"&gt;Link2&lt;/a&gt;\n    &lt;/li&gt;\n    &lt;li {% if active_link == \"link3\" %} class=\"active\" {% endif %}&gt;\n        &lt;a href=\"{% url 'link3 %}\"&gt;Link3&lt;/a&gt;\n    &lt;/li&gt;\n&lt;/ul&gt;\n</code></pre> <p>Django templates offer a versatile set of built-in tags. It is quite easy to create your own custom tag. Since custom tags live inside an app, create a <code>templatetags</code> directory inside an app. This directory must be a package, so it should have an (empty) <code>__init__.py</code> file.</p> <p>Next, write your custom template in an appropriately named Python file. For example, for this active link pattern, we can create a file called <code>nav.py</code> with the following contents:</p> <pre><code># app/templatetags/nav.py\n\n# depreciate in django4\n# from django.core.urlresolvers import resolve\n\nfrom django.template import Library\n\nregister = Library()\n\n@register.simple_tag\ndef active_nav(request, url):\n    url_name = resolve(request.path).url_name\n\n    if url_name == url:\n        return \"active\"\n    return \"\"\n</code></pre> <p>The syntax for calling this custom tag in a template is <code>{% active_nav request 'pattern_name' %}</code>. Notice that the <code>request</code> needs to be passed in every page that this tag is used.</p> <pre><code>{# base.html #}\n\n{% load_nav %}\n&lt;ul class=\"nav nav-pills\"&gt;\n    &lt;li class={% active_nav request 'active1' %}&gt;\n        &lt;a href=\"{% url 'active1' %}\"&gt;Active 1&lt;/a&gt;\n    &lt;/li&gt;\n    &lt;li class={% active_nav request 'active2' %}&gt;\n        &lt;a href=\"{% url 'active2' %}\"&gt;Active 2&lt;/a&gt;\n    &lt;/li&gt;\n&lt;/ul&gt;\n</code></pre>","tags":["Django","Python"]},{"location":"blog/2024/05/06/active-link-in-django/#practical","title":"Practical","text":"<p>Note</p> header.html <pre><code>&lt;ul class=\"menu-section\"&gt;\n    &lt;li class=\"menu-item-has-children\"&gt;\n\n        {% if request.path == '/' %}\n            &lt;a href=\"#business\"&gt;Business&lt;/a&gt; &lt;i class=\"ion ion-ios-arrow-down dropdown-icon\"&gt;&lt;/i&gt;\n        {% else %}\n            &lt;a href=\"{% url 'business:inner' %}\"&gt;Business&lt;/a&gt; &lt;i class=\"ion ion-ios-arrow-down dropdown-icon\"&gt;&lt;/i&gt;\n        {% endif %}\n\n        &lt;div class=\"menu-subs menu-mega menu-column-4\"&gt;\n\n            &lt;div class=\"list-item\"&gt;\n                &lt;h4 class=\"title\"&gt;Product &amp; Services&lt;/h4&gt;\n                &lt;ul&gt;\n                    {% for item in header_business %}\n                        {% if item.category == '1' %}\n                            &lt;li&gt;&lt;a href=\"{% url 'business:item' item.slug %}\"&gt;{{ item.title }}&lt;/a&gt;&lt;/li&gt;\n                        {% endif %}\n                    {% endfor %}\n                &lt;/ul&gt;\n            &lt;/div&gt;\n\n            &lt;div class=\"list-item\"&gt;\n                &lt;h4 class=\"title\"&gt;Business Consulting&lt;/h4&gt;\n                &lt;ul&gt;\n                    {% for item in header_business %}\n                        {% if item.category == '2' %}\n                            &lt;li&gt;&lt;a href=\"{% url 'business:item' item.slug %}\"&gt;{{ item.title }}&lt;/a&gt;&lt;/li&gt;\n                        {% endif %}\n                    {% endfor %}\n                &lt;/ul&gt;\n            &lt;/div&gt;\n\n            &lt;div class=\"list-item\"&gt;\n                &lt;h4 class=\"title\"&gt;IT Services&lt;/h4&gt;\n                &lt;ul&gt;\n                    {% for item in header_business %}\n                        {% if item.category == '3' %}\n                            &lt;li&gt;&lt;a href=\"{% url 'business:item' item.slug %}\"&gt;{{ item.title }}&lt;/a&gt;&lt;/li&gt;\n                        {% endif %}\n                    {% endfor %}\n                &lt;/ul&gt;\n            &lt;/div&gt;\n\n        &lt;/div&gt;\n    &lt;/li&gt;\n\n    &lt;li class=\"menu-item-has-children\"&gt;\n        {% if request.path == '/' %}\n          &lt;a href=\"#about\"&gt;About us&lt;/a&gt;\n        {% else %}\n          &lt;a href=\"{% url 'about:inner' %}\"&gt;About us&lt;/a&gt;\n        {% endif %}\n    &lt;/li&gt;\n\n&lt;/ul&gt;\n</code></pre>","tags":["Django","Python"]},{"location":"blog/2024/05/06/active-link-in-django/#reference","title":"Reference","text":"<ul> <li>Django Design Patterns and Best Practices Second Edition - pg:106</li> </ul>","tags":["Django","Python"]},{"location":"blog/2024/05/02/ensuring-admin-access-control-in-django-models/","title":"Ensuring Admin Access Control in Django Models","text":"","tags":["Django","Python"]},{"location":"blog/2024/05/02/ensuring-admin-access-control-in-django-models/#ensuring-admin-access-control-in-django-models","title":"Ensuring Admin Access Control in Django Models","text":"<p>In a Django project, managing access control to models within the admin interface is crucial for maintaining data integrity and security. While Django provides powerful tools for defining permissions, it's essential to customize these permissions to meet specific requirements.</p> <p>One common scenario is restricting access to certain models so that only superusers can add or modify instances. Let's take the example of a \"Contact\" model within our application.</p> Python<pre><code>from django.contrib import admin\nfrom .models import Contact\n\nclass ContactAdmin(admin.ModelAdmin):\n    def has_add_permission(self, request):\n        # Only superusers can add new contacts\n        if request.user.is_superuser:\n            return True\n        return False\n\n    def has_change_permission(self, request, obj=None):\n        # Only superusers can change existing contacts\n        if request.user.is_superuser:\n            return True\n        return False\n\nadmin.site.register(Contact, ContactAdmin)\n</code></pre> <p>In the above code, we subclass the default admin class for the <code>Contact</code> model and override the has_add_permission and has_change_permission methods. By doing so, we ensure that only superusers have the ability to add or modify instances of the \"Contact\" model.</p> <p>This approach offers fine-grained control over access permissions, preventing unauthorized users from tampering with sensitive data. It's particularly useful when dealing with models containing confidential information or critical settings.</p> <p>By implementing custom access control logic at the model level, we enhance the overall security posture of our Django application. Administrators can confidently manage permissions, knowing that sensitive models are safeguarded against unauthorized modifications.</p> <p>Resuable Mixins</p> <pre><code>from django.contrib import admin\n\nclass SuperuserPermissionMixin:\n    def has_add_permission(self, request):\n        # Only superusers can add new instances\n        if request.user.is_superuser:\n            return True\n        return False\n\n    def has_change_permission(self, request, obj=None):\n        # Only superusers can change existing instances\n        if request.user.is_superuser:\n            return True\n        return False\n</code></pre>","tags":["Django","Python"]},{"location":"blog/2024/05/02/ensuring-admin-access-control-in-django-models/#conclusion","title":"Conclusion","text":"<p>In conclusion, Django's flexibility empowers developers to tailor access control mechanisms to suit specific project requirements. By leveraging custom admin permissions, we can enforce strict access controls, promoting data integrity and enhancing overall security.</p> <p>In Django projects, always remember to carefully evaluate access requirements for each model and implement appropriate permission settings to mitigate risks effectively.</p>","tags":["Django","Python"]},{"location":"blog/2024/04/27/understanding-args-and-kwargs-in-python-functions/","title":"Understanding *args and **kwargs in Python Functions","text":"","tags":["Python"]},{"location":"blog/2024/04/27/understanding-args-and-kwargs-in-python-functions/#understanding-args-and-kwargs-in-python-functions","title":"Understanding <code>*args</code> and <code>**kwargs</code> in Python Functions","text":"<p>In the world of Python programming, understanding how to handle variable numbers of arguments in functions is crucial. Two special syntaxes, <code>*args</code> and <code>**kwargs</code>, offer powerful capabilities for achieving this flexibility.</p>","tags":["Python"]},{"location":"blog/2024/04/27/understanding-args-and-kwargs-in-python-functions/#args","title":"args","text":"<p><code>*args</code> stands for arguments and allows a function to accept a variable number of positional arguments. When using *args in a function definition, any number of arguments can be passed to the function, and they are collected into a tuple within the function.</p> <pre><code>def my_function(*args):\n    for arg in args:\n        print(arg)\n\nmy_function(1, 2, 3)\n</code></pre> Output<pre><code>1\n2\n3\n</code></pre>","tags":["Python"]},{"location":"blog/2024/04/27/understanding-args-and-kwargs-in-python-functions/#kwargs","title":"kwargs","text":"<p><code>**kwargs</code> stands for keyword arguments and enables a function to accept a variable number of keyword arguments. When using <code>**kwargs</code>, any number of keyword arguments can be passed to the function, and they are collected into a dictionary within the function, where the keys are the argument names.</p> <pre><code>def my_function(**kwargs):\n    for key, value in kwargs.items():\n        print(key, \":\", value)\n\nmy_function(name=\"Alice\", age=30, city=\"New York\")\n</code></pre> Output<pre><code>name : Alice\nage : 30\ncity : New York\n</code></pre>","tags":["Python"]},{"location":"blog/2024/04/27/understanding-args-and-kwargs-in-python-functions/#difference-between-args-kwargs","title":"Difference between args &amp; kwargs","text":"","tags":["Python"]},{"location":"blog/2024/04/27/understanding-args-and-kwargs-in-python-functions/#args_1","title":"<code>*args</code>:","text":"<ul> <li>Used to pass a variable number of positional arguments to a function.</li> <li>Collects all positional arguments into a tuple inside the function.</li> <li>When you use <code>*args</code> in a function definition, you can pass any number of positional arguments when calling that function.</li> <li>The arguments are accessed using their position in the tuple.</li> </ul>","tags":["Python"]},{"location":"blog/2024/04/27/understanding-args-and-kwargs-in-python-functions/#kwargs_1","title":"<code>**kwargs</code>:","text":"<ul> <li>Used to pass a variable number of keyword arguments (or named arguments) to a function.</li> <li>Collects all keyword arguments into a dictionary inside the function, where the keys are the argument names and the values are the corresponding values.</li> <li>When you use <code>**kwargs</code> in a function definition, you can pass any number of keyword arguments when calling that function.</li> <li>The arguments are accessed using their names as keys in the dictionary.</li> </ul>","tags":["Python"]},{"location":"blog/2024/04/27/understanding-args-and-kwargs-in-python-functions/#why-are-they-useful","title":"Why are they useful?","text":"<p>These features provide flexibility in function definitions, allowing them to handle various scenarios where the number of arguments might differ. Instead of specifying a fixed number of parameters, <code>*args</code> and <code>**kwargs</code> enable functions to adapt dynamically to different situations.</p> <p>Example</p> <pre><code>def example_function(*args, **kwargs):\n    print(\"Positional arguments (*args):\", args)\n    print(\"Keyword arguments (**kwargs):\", kwargs)\n\nexample_function(1, 2, 3, name=\"Alice\", age=30)\n</code></pre> <pre><code>Positional arguments (*args): (1, 2, 3)\nKeyword arguments (**kwargs): {'name': 'Alice', 'age': 30}\n</code></pre> <p>In this example, <code>example_function()</code> accepts both positional and keyword arguments, demonstrating the versatility provided by args and *kwargs.</p>","tags":["Python"]},{"location":"blog/2024/04/27/understanding-args-and-kwargs-in-python-functions/#conclusion","title":"Conclusion:","text":"<p>Understanding <code>*args</code> and <code>**kwargs</code> empowers Python developers to write more flexible and reusable code. By leveraging these features, functions can gracefully handle varying numbers of arguments, enhancing the overall robustness and adaptability of Python applications.</p>","tags":["Python"]},{"location":"blog/2024/06/26/class-based-views-are-not-always-class-based-generic-views/","title":"Class-Based Views are not always Class-Based Generic Views","text":"","tags":["django","env"]},{"location":"blog/2024/06/26/class-based-views-are-not-always-class-based-generic-views/#class-based-views-are-not-always-class-based-generic-views","title":"Class-Based Views are not always Class-Based Generic Views","text":"<p>Most people confuse Class-Based Views and Class-Based Generic Views. Their names are similar, but they are not the same things. This has led to some interesting misconceptions as follows:</p> <ul> <li> <p>The only generic views are the ones bundled with Django: Thankfully, this is wrong. There is no special magic in the generic class-based views that are provided. You are free to roll your own set of generic class-based views. You can also use a third-party library such as django-vanilla-views.org which has a simpler implementation of the standard generic views. Remember that using custom generic views might make your code unfamiliar to others.</p> </li> <li> <p>Class-based views must always derive from a generic view: Again, there is nothing magical about the generic view classes. Though, 90 percent of the time, you will find a generic class such as <code>View</code> to be ideal for use as a base class, you are free to implement similar features yourself.</p> </li> </ul>","tags":["django","env"]},{"location":"blog/2024/06/26/class-based-views-are-not-always-class-based-generic-views/#reference","title":"Reference","text":"<ul> <li>Django design patterns and best practices - second edition</li> </ul>","tags":["django","env"]},{"location":"blog/2024/07/10/integrating-code-formatting-and-linting-checks-in-github-actions/","title":"Integrating Code Formatting and Linting Checks in GitHub Actions","text":"","tags":["Programming","Django"]},{"location":"blog/2024/07/10/integrating-code-formatting-and-linting-checks-in-github-actions/#integrating-code-formatting-and-linting-checks-in-github-actions","title":"Integrating Code Formatting and Linting Checks in GitHub Actions","text":"<p>In professional software development workflows, the standard approach to handling code formatting and linting issues in CI/CD pipelines involves a combination of automation and manual review.</p> A Practical Guide to Code Formatting and Linting in GitHub Actions Workflows","tags":["Programming","Django"]},{"location":"blog/2024/07/10/integrating-code-formatting-and-linting-checks-in-github-actions/#introduction","title":"Introduction","text":"<p>Here\u2019s a breakdown of the common practices and why they are preferred:</p>","tags":["Programming","Django"]},{"location":"blog/2024/07/10/integrating-code-formatting-and-linting-checks-in-github-actions/#standard-approach-for-handling-code-formatting","title":"Standard Approach for Handling Code Formatting","text":"<ol> <li> <p>Automate Checks and Report Issues</p> <ul> <li>CI/CD Workflow: Run code formatting and linting checks as part of your CI/CD pipeline. This ensures that code quality issues are detected early in the development process.</li> <li> <p>Check-Only Mode: Configure the CI/CD pipeline to use <code>black --check</code>, <code>flake8</code>, and <code>isort --check</code> to report issues without automatically applying changes. This approach ensures that issues are identified but requires manual intervention to fix them.</p> <pre><code>- name: Run Black\n  run: pipenv run black --check .\n\n- name: Run Flake8\n  run: pipenv run flake8 .\n\n- name: Run isort\n  run: pipenv run isort --check .\n</code></pre> </li> </ul> </li> <li> <p>Manual Fixes and Reviews</p> <ul> <li>Local Fixes: Developers run the formatting and linting tools locally before pushing changes. This allows developers to address issues interactively.</li> <li> <p>Pull Request Reviews: Ensure that all formatting issues are resolved before merging code. Code reviews can include checks for formatting compliance.</p> <pre><code>pipenv run black .\npipenv run flake8 .\npipenv run isort .\n</code></pre> </li> </ul> </li> <li> <p>Branch Protection Rules</p> <ul> <li>Enforce Standards: Set up branch protection rules to ensure that code cannot be merged into important branches (e.g., <code>main</code> or <code>develop</code>) unless all required checks pass.</li> <li>Status Checks: Configure required status checks to prevent merging if formatting or linting issues are present.</li> </ul> GitHub Branch Protection Setup: <ul> <li>Go to the repository settings.</li> <li>Add a branch protection rule for the <code>main</code> branch.</li> <li>Enable status checks to require passing results from your CI workflow.</li> </ul> </li> <li> <p>Automated Reformatting (Optional)</p> <ul> <li> <p>Auto-Fix and Commit: Optionally, configure GitHub Actions to automatically reformat code and commit the changes if formatting issues are detected. This can be useful for maintaining consistency but should be used carefully to avoid unwanted changes.</p> <pre><code>-   name: Run Black\n    run: |\n        pipenv run black --check . || true\n\n-   name: Reformat code with Black\n    run: |\n        pipenv run black . || true\n\n-   name: Commit changes\n    if: ${{ github.ref == 'refs/heads/main' }}\n    run: |\n        git config --global user.name 'GitHub Actions'\n        git config --global user.email 'actions@github.com'\n        git add .\n        git commit -m 'Auto-format code with Black'\n        git push\n</code></pre> </li> </ul> </li> </ol>","tags":["Programming","Django"]},{"location":"blog/2024/07/10/integrating-code-formatting-and-linting-checks-in-github-actions/#why-these-practices-are-standard","title":"Why These Practices are Standard","text":"<ul> <li>Automation with Manual Review: Automating checks and reporting issues ensures consistency and quality, while manual fixes and reviews allow for careful code handling and decision-making.</li> <li>Enforcement Through Branch Protection: Protecting branches from being updated with non-compliant code ensures that code quality standards are enforced.</li> <li>Balancing Automation and Manual Effort: Automated reformatting can be useful but should be balanced with manual review to avoid accidental or undesired changes.</li> </ul>","tags":["Programming","Django"]},{"location":"blog/2024/07/10/integrating-code-formatting-and-linting-checks-in-github-actions/#summary","title":"Summary","text":"<p>The standard approach in professional environments is to use automated checks for formatting and linting in your CI/CD pipeline, combined with manual fixes and reviews. This ensures that code quality is maintained while allowing for developer oversight and intervention. Automated reformatting can be used optionally, but it should be implemented carefully to avoid unintended changes.</p>","tags":["Programming","Django"]},{"location":"blog/2024/07/10/integrating-code-formatting-and-linting-checks-in-github-actions/#question-1","title":"Question 1:","text":"Why Manual Code Formatting and Linting Are Preferred Over Automatic Commits in CI/CD <p>If you choose not to use the step that automatically commits and pushes changes in your GitHub Actions workflow, here's what happens and what alternatives you might consider:</p> Consequences of Not Using Automatic Committing <ol> <li> <p>Manual Intervention Required:</p> <ul> <li>Without this step, if black, flake8, or isort find issues that need fixing, those issues will be reported, but the formatting and linting fixes won\u2019t be applied automatically. You or other developers will need to manually run the tools and commit the changes locally.</li> </ul> </li> <li> <p>Workflow Passes Only on Success:</p> <ul> <li>The GitHub Actions workflow will only pass if the code is already compliant with formatting and linting standards at the time of the push or pull request. If the code is not compliant, the workflow will fail, and manual intervention is needed to correct the issues.</li> </ul> </li> <li> <p>Increased Developer Responsibility:</p> <ul> <li>Developers must ensure that code adheres to formatting and linting standards before pushing their changes. This can be done by running the tools locally before pushing.</li> </ul> </li> </ol> Benefits of Not Automatically Committing Changes <ol> <li> <p>Controlled Code Changes:</p> <ul> <li>Manual fixing ensures that changes are reviewed and intentionally applied, maintaining code quality and avoiding unintended changes.</li> </ul> </li> <li> <p>Code Review and Quality Assurance:</p> <ul> <li>Developers can review and discuss code formatting changes during code reviews, ensuring that all changes meet project standards and do not introduce issues.</li> </ul> </li> <li> <p>Avoids Potential Issues:</p> <ul> <li>Automatically committing and pushing changes can sometimes result in conflicts or undesired changes if not managed carefully. Manual intervention can help avoid these issues.</li> </ul> </li> </ol>","tags":["Programming","Django"]},{"location":"blog/2024/07/10/integrating-code-formatting-and-linting-checks-in-github-actions/#alternative-approaches","title":"Alternative Approaches","text":"<ol> <li> <p>Local Formatting and Linting:</p> <ul> <li> <p>Developers can run formatting and linting tools locally before pushing code. This ensures that the code adheres to standards before it reaches the CI/CD pipeline.</p> Local Commands<pre><code>pipenv run black .\npipenv run flake8 .\npipenv run isort .\n</code></pre> </li> </ul> </li> <li> <p>Pre-commit Hooks:</p> <ul> <li> <p>Use pre-commit hooks to automatically format code before committing it. This ensures code is consistently formatted before it\u2019s pushed to the repository.</p> Pre-commit Configuration<pre><code>repos:\n    -   repo: https://github.com/pre-commit/mirrors-black\n        rev: v23.9.0\n        hooks:\n          - id: black\n\n    -   repo: https://github.com/pre-commit/mirrors-flake8\n        rev: v6.0.0\n        hooks:\n          - id: flake8\n\n    -   repo: https://github.com/pre-commit/mirrors-isort\n        rev: v5.12.0\n        hooks:\n          - id: isort\n</code></pre> </li> </ul> </li> <li> <p>Manual Code Reviews:</p> <ul> <li>Ensure code reviews include checks for adherence to formatting and linting standards. This can be combined with CI/CD checks to enforce quality.</li> </ul> </li> <li> <p>Branch Protection Rules:</p> <ul> <li>Set up branch protection rules to ensure that only code passing all required checks (including formatting and linting) can be merged into important branches.</li> </ul> </li> </ol>","tags":["Programming","Django"]},{"location":"blog/2024/07/10/integrating-code-formatting-and-linting-checks-in-github-actions/#summary_1","title":"Summary","text":"<p>Not using the automatic commit step means that formatting and linting issues will not be automatically fixed and committed. This approach requires developers to address formatting issues manually but provides more control over code changes and quality. To ensure code quality, developers should run formatting and linting tools locally or use pre-commit hooks, and code reviews should include checks for adherence to standards. Branch protection rules can help enforce quality by requiring passing checks before merging into protected branches.</p>","tags":["Programming","Django"]},{"location":"blog/2024/07/10/integrating-code-formatting-and-linting-checks-in-github-actions/#question-2","title":"Question 2:","text":"Standard Practices for Code Formatting and Linting in CI/CD Pipelines <p>Automatically committing changes in CI/CD workflows is less common and not generally considered a best practice in most professional development environments. Here\u2019s why and what the standard approaches are:</p> Why Automatic Committing is Less Common <ol> <li> <p>Controlled Code Changes:</p> <ul> <li>Review Process: Automatic commits can bypass code review processes, potentially introducing unwanted changes without proper review.</li> <li>Accidental Changes: Automated changes might inadvertently alter code in ways that were not intended or that could introduce issues.</li> </ul> </li> <li> <p>Conflict Management:</p> <ul> <li>Merge Conflicts: Automatically committing changes can lead to conflicts with other ongoing changes, making it difficult to manage the integration process.</li> </ul> </li> <li> <p>Transparency:</p> <ul> <li>Audit Trails: Automatic commits can obscure the history of changes, making it harder to track why and when certain changes were made.</li> </ul> </li> </ol>","tags":["Programming","Django"]},{"location":"blog/2024/07/10/integrating-code-formatting-and-linting-checks-in-github-actions/#standard-and-popular-practices","title":"Standard and Popular Practices","text":"<ol> <li> <p>Manual Formatting and Linting:</p> <ul> <li>Local Development: Developers run formatting and linting tools locally before committing. This ensures that code adheres to standards before it reaches the CI/CD pipeline.</li> <li> <p>Pre-commit Hooks: Use tools like pre-commit to enforce code quality standards automatically before code is committed. This helps maintain consistency and avoids formatting issues.</p> .pre-commit-config.yaml<pre><code>repos:\n    -   repo: https://github.com/pre-commit/mirrors-black\n        rev: v23.9.0\n        hooks:\n        - id: black\n\n    -   repo: https://github.com/pre-commit/mirrors-flake8\n        rev: v6.0.0\n        hooks:\n        - id: flake8\n\n    -   repo: https://github.com/pre-commit/mirrors-isort\n        rev: v5.12.0\n        hooks:\n        - id: isort\n</code></pre> </li> </ul> </li> <li> <p>CI/CD Pipeline Checks:</p> <ul> <li>Check Mode: Run formatting and linting tools in check mode (<code>--check</code> for <code>black</code>, <code>flake8</code>, and <code>isort</code>) in CI/CD workflows. This reports issues but does not automatically fix them.</li> <li> <p>Fail on Issues: Configure the CI/CD pipeline to fail if formatting or linting issues are detected. This encourages developers to fix issues before merging.</p> GitHub Actions Workflow<pre><code>jobs:\n  build:\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v3\n\n      - name: Install dependencies\n        run: |\n          pip install black flake8 isort\n\n      - name: Run Black\n        run: pipenv run black --check .\n\n      - name: Run Flake8\n        run: pipenv run flake8 .\n\n      - name: Run isort\n        run: pipenv run isort --check .\n</code></pre> </li> </ul> </li> <li> <p>Code Reviews:</p> <ul> <li>Manual Review: Ensure code reviews include checks for formatting and adherence to linting standards. This helps catch issues that automated tools might miss.</li> </ul> </li> <li> <p>Branch Protection Rules:</p> <ul> <li>Enforce Standards: Use branch protection rules to enforce that all required checks, including formatting and linting, must pass before allowing merges.</li> </ul> GitHub Branch Protection Settings: <ul> <li>Navigate to repository settings.</li> <li>Add a branch protection rule for the main branch.</li> <li>Require status checks to pass before merging.</li> </ul> </li> </ol> When Automatic Committing Might Be Used <ul> <li>Internal Tools: Some teams use automatic committing in internal tools or experimental setups, but this is less common for production codebases.</li> <li>Documentation or Generated Code: Automatic commits can be used for non-code files like documentation or generated files where manual review is less critical.</li> </ul>","tags":["Programming","Django"]},{"location":"blog/2024/07/10/integrating-code-formatting-and-linting-checks-in-github-actions/#summary_2","title":"Summary","text":"<p>Automatic committing is not widely used in standard development workflows due to concerns about code control, review processes, and conflict management. The more common and recommended practices are to run formatting and linting tools in CI/CD pipelines in check mode, use pre-commit hooks, and rely on manual code reviews and branch protection rules to enforce code quality standards. This approach ensures code quality while maintaining transparency and control over code changes.</p>","tags":["Programming","Django"]},{"location":"blog/2024/07/06/comparing-django-environ-python-decouple-and-python-dotenv/","title":"Comparing django-environ, python-decouple, and python-dotenv","text":"","tags":["django","env"]},{"location":"blog/2024/07/06/comparing-django-environ-python-decouple-and-python-dotenv/#comparing-django-environ-python-decouple-and-python-dotenv","title":"Comparing django-environ, python-decouple, and python-dotenv","text":"<p>All three libraries \u2014 <code>django-environ</code>, <code>python-decouple</code>, and <code>python-dotenv</code> \u2014 serve similar purposes: managing configuration and environment variables in Python projects. </p> Comparing django-environ, python-decouple, and python-dotenv: Choosing the Right Configuration Management Tool for Your Python Project <p>Here\u2019s a brief overview of each, their differences, and scenarios where each might be most appropriate:</p>","tags":["django","env"]},{"location":"blog/2024/07/06/comparing-django-environ-python-decouple-and-python-dotenv/#1-django-environ","title":"1.  django-environ","text":"<p><code>django-environ</code> is specifically designed for use with Django projects. It provides a way to manage environment variables and configuration settings in a Django application.</p> <ul> <li> <p>Features:</p> <ul> <li>Seamlessly integrates with Django settings.</li> <li>Provides Django-specific configuration management.</li> <li>Supports parsing <code>.env</code> files.</li> </ul> </li> <li> <p>Best For:</p> <ul> <li>Django projects where you want to manage environment variables and settings in a Django-specific manner.</li> <li>When you want to use Django\u2019s <code>settings.py</code> to manage configurations and have a structured way to handle environment variables.</li> </ul> </li> <li> <p>Usage Scenario:</p> <ul> <li>You\u2019re working on a Django project and want to keep your configuration in environment variables while leveraging Django\u2019s settings management.</li> </ul> </li> </ul>","tags":["django","env"]},{"location":"blog/2024/07/06/comparing-django-environ-python-decouple-and-python-dotenv/#2-python-decouple","title":"2. python-decouple","text":"<p><code>python-decouple</code> is a general-purpose library for managing configuration variables and settings. It aims to provide a clear separation between configuration and code.</p> <ul> <li> <p>Features:</p> <ul> <li>Can be used with any Python project, not just Django.</li> <li>Supports <code>.env</code> files and other configuration sources.</li> <li>Provides a clean API for accessing settings and environment variables.</li> </ul> </li> <li> <p>Best For:</p> <ul> <li>General Python projects (Django or otherwise) where you want a clean way to handle configuration.</li> <li>Projects that need to be agnostic of frameworks or have multiple configuration sources.</li> </ul> </li> <li> <p>Usage Scenario:</p> <ul> <li>You have a Python project (possibly Django) and prefer a flexible, framework-agnostic approach to managing configuration and environment variables.</li> </ul> </li> </ul>","tags":["django","env"]},{"location":"blog/2024/07/06/comparing-django-environ-python-decouple-and-python-dotenv/#3-python-dotenv","title":"3.  python-dotenv","text":"<p><code>python-dotenv</code> is another general-purpose library for managing environment variables, and it\u2019s known for its simplicity in loading environment variables from <code>.env</code> files into the environment.</p> <ul> <li> <p>Features:</p> <ul> <li>Easily loads environment variables from <code>.env</code> files.</li> <li>Simple and straightforward API.</li> <li>Works well with different frameworks and standalone Python projects.</li> </ul> </li> <li> <p>Best For:</p> <ul> <li>Projects where you need a lightweight solution for loading environment variables from <code>.env</code> files.</li> <li>Projects that don\u2019t need advanced configuration features but just need to set environment variables.</li> </ul> </li> <li> <p>Usage Scenario:</p> <ul> <li>You need a simple, direct way to load environment variables from <code>.env</code> files into your environment, regardless of the framework or application type.</li> </ul> </li> </ul>","tags":["django","env"]},{"location":"blog/2024/07/06/comparing-django-environ-python-decouple-and-python-dotenv/#choosing-the-best-option","title":"Choosing the Best Option","text":"<ul> <li> <p>For Django Projects: Use <code>django-environ</code>. It\u2019s tailored for Django and integrates well with Django\u2019s settings system.</p> </li> <li> <p>For General Python Projects:</p> <ul> <li>python-decouple is versatile and offers more features and flexibility if you need to manage different configuration sources or prefer a clean separation of configuration.</li> <li>python-dotenv is a good choice if you just need a straightforward way to load environment variables from <code>.env</code> files without additional configuration management features.</li> </ul> </li> </ul> <p>Each library has its strengths, and the choice depends on your specific needs and project requirements.</p>","tags":["django","env"]},{"location":"blog/2024/07/22/what-are-the-comparisons-between-python-lists-dictionaries-and-javascript-arrays-and-objects/","title":"What are the Comparisons Between Python Lists, Dictionaries, and JavaScript Arrays, and Objects?","text":"","tags":["Python","Javascript"]},{"location":"blog/2024/07/22/what-are-the-comparisons-between-python-lists-dictionaries-and-javascript-arrays-and-objects/#what-are-the-comparisons-between-python-lists-dictionaries-and-javascript-arrays-and-objects","title":"What are the Comparisons Between Python Lists, Dictionaries, and JavaScript Arrays, and Objects?","text":"<p>How do Python lists and dictionaries compare to JavaScript arrays and objects?</p>","tags":["Python","Javascript"]},{"location":"blog/2024/07/22/what-are-the-comparisons-between-python-lists-dictionaries-and-javascript-arrays-and-objects/#1-python-list-vs-javascript-array","title":"1. Python List vs. JavaScript Array:","text":"<ul> <li>Python List: An ordered, mutable collection that can store items of different types. Lists are defined using square brackets.</li> <li>JavaScript Array: An ordered, mutable collection that can also store items of various types. Arrays are defined using square brackets as well.</li> </ul> Example: <ul> <li> <p>Python List:</p> <pre><code>my_list = [1, 2, 3, \"hello\"]\n</code></pre> </li> <li> <p>JavaScript Array:</p> <pre><code>const myArray = [1, 2, 3, \"hello\"];\n</code></pre> </li> </ul>","tags":["Python","Javascript"]},{"location":"blog/2024/07/22/what-are-the-comparisons-between-python-lists-dictionaries-and-javascript-arrays-and-objects/#python-dictionary-vs-javascript-object","title":"Python Dictionary vs. JavaScript Object:","text":"<ul> <li>Python Dictionary: A mutable collection of key-value pairs where keys must be unique and immutable. Dictionaries are defined using curly braces.</li> <li>JavaScript Object: A collection of key-value pairs (properties) where keys are strings (or Symbols) and can be dynamically added or modified. Objects are also defined using curly braces.</li> </ul> Example: <ul> <li> <p>Python Dictionary:</p> <pre><code>my_dict = {\n    \"name\": \"Alice\",\n    \"age\": 30\n}\n</code></pre> </li> <li> <p>JavaScript Object:</p> <pre><code>const myObject = {\n    name: \"Alice\",\n    age: 30\n};\n</code></pre> </li> </ul>","tags":["Python","Javascript"]},{"location":"blog/2024/07/22/what-are-the-comparisons-between-python-lists-dictionaries-and-javascript-arrays-and-objects/#summary","title":"Summary","text":"<ul> <li>List (Python) is similar to Array (JavaScript): Both are ordered and mutable collections.</li> <li>Dictionary (Python) is similar to Object (JavaScript): Both store key-value pairs and are mutable.</li> </ul>","tags":["Python","Javascript"]},{"location":"blog/2024/07/09/configuring-django-for-local-and-production-environments-with-dynamic-env-files/","title":"Configuring Django for Local and Production Environments with Dynamic .env Files","text":"","tags":["Python","Django"]},{"location":"blog/2024/07/09/configuring-django-for-local-and-production-environments-with-dynamic-env-files/#configuring-django-for-local-and-production-environments-with-dynamic-env-files","title":"Configuring Django for Local and Production Environments with Dynamic <code>.env</code> Files","text":"<p>When working with Django, it's crucial to manage environment-specific settings securely and efficiently. Using <code>.env</code> files allows you to store configuration variables separately from your codebase, making it easier to handle different environments like local development and production.</p>","tags":["Python","Django"]},{"location":"blog/2024/07/09/configuring-django-for-local-and-production-environments-with-dynamic-env-files/#different-approach","title":"Different Approach","text":"<p>Using the <code>DEBUG</code> boolean value to switch between <code>settings.local</code> and <code>settings.prod</code> is a common and practical approach for managing different environments in Django. However, there are other strategies you can consider, each with its own benefits. Here\u2019s a comparison of various approaches and some additional suggestions:</p>","tags":["Python","Django"]},{"location":"blog/2024/07/09/configuring-django-for-local-and-production-environments-with-dynamic-env-files/#common-approaches","title":"Common Approaches","text":"<ol> <li> <p>Using DEBUG Boolean Value:</p> Pros: <ul> <li>Simple and straightforward.</li> <li>Directly tied to Django's built-in DEBUG setting.</li> </ul> Cons: <ul> <li>Primarily useful for development vs. production environments.</li> <li>Less flexibility for other deployment scenarios (e.g., staging, testing).</li> </ul> </li> <li> <p>Environment-Specific Environment Variables:</p> <ul> <li> <p>Setup: Use a dedicated environment variable to specify which settings module to use, such as <code>DJANGO_ENVIRONMENT</code>.</p> wsgi.py<pre><code>import os\nimport environ\nfrom django.core.wsgi import get_wsgi_application\n\nenv = environ.Env()\nenviron.Env.read_env()\n\nenvironment = env('DJANGO_ENVIRONMENT', default='development')\nsettings_module = 'dating_app.settings.local' if environment == 'development' else 'dating_app.settings.prod'\n\nos.environ.setdefault('DJANGO_SETTINGS_MODULE', settings_module)\napplication = get_wsgi_application()\n</code></pre> </li> </ul> Pros <ul> <li>More flexible, allowing for additional environments (e.g., staging, testing).</li> <li>Avoids coupling environment-specific settings with <code>DEBUG</code>.</li> </ul> Cons <ul> <li>Requires setting up and managing additional environment variables.</li> </ul> </li> <li> <p>Using Different <code>.env</code> Files:</p> <ul> <li> <p>Setup: Maintain different <code>.env</code> files for different environments and load the appropriate one based on a primary environment variable.</p> wsgi.py<pre><code>import os\nimport environ\nfrom django.core.wsgi import get_wsgi_application\n\nenv = environ.Env()\nenvironment = env('DJANGO_ENVIRONMENT', default='development')\n\nif environment == 'production':\n    env_file = '.env.prod'\nelse:\n    env_file = '.env.local'\n\nenviron.Env.read_env(env_file)\n\nos.environ.setdefault('DJANGO_SETTINGS_MODULE', f'dating_app.settings.{environment}')\napplication = get_wsgi_application()\n</code></pre> </li> </ul> Pros <ul> <li>Provides a clear separation between different configurations.</li> <li>Easy to manage and switch between environments.</li> </ul> Cons <ul> <li>Requires careful management of multiple <code>.env</code> files.</li> </ul> </li> <li> <p>Deployment-Specific Configuration:</p> <ul> <li>Setup: Configure the settings module directly within your deployment environment (e.g., using Docker, Kubernetes, or a cloud service's environment variable configuration).</li> <li>Example: Set <code>DJANGO_SETTINGS_MODULE</code> in your Dockerfile or deployment configuration.</li> </ul> Pros <ul> <li>Seamless integration with deployment tools and platforms.</li> <li>Maintains clear separation of configuration and code.</li> </ul> Cons <ul> <li>Less control in local development environments if not configured properly.</li> </ul> </li> </ol>","tags":["Python","Django"]},{"location":"blog/2024/07/09/configuring-django-for-local-and-production-environments-with-dynamic-env-files/#recommendations","title":"Recommendations","text":"<ol> <li> <p>For Development and Production: Using the <code>DEBUG</code> boolean value is suitable and easy for projects with only development and production environments. It aligns well with Django\u2019s built-in <code>DEBUG</code> setting and is easy to implement.</p> </li> <li> <p>For More Complex Scenarios: If you have multiple environments (e.g., staging, testing), consider using an environment-specific environment variable (<code>DJANGO_ENVIRONMENT</code>) or separate <code>.env</code> files. This approach provides more flexibility and avoids tying environment configurations directly to <code>DEBUG</code>.</p> </li> <li> <p>Deployment Tools Integration: For modern deployment practices using containers or cloud platforms, configure <code>DJANGO_SETTINGS_MODULE</code> directly within the deployment environment. This method aligns well with containerized deployments and cloud services.</p> </li> </ol>","tags":["Python","Django"]},{"location":"blog/2024/07/09/configuring-django-for-local-and-production-environments-with-dynamic-env-files/#conclusion","title":"Conclusion","text":"<p>Each approach has its strengths, and the best choice depends on your specific needs and deployment scenarios. For many projects, starting with the <code>DEBUG</code> boolean value is sufficient and straightforward. As your project grows and your deployment needs become more complex, consider adopting more flexible strategies for managing environment-specific configurations.</p>","tags":["Python","Django"]},{"location":"blog/2024/07/09/configuring-django-for-local-and-production-environments-with-dynamic-env-files/#method-1","title":"Method 1","text":"manage.pywsgi.pyasgi.py <pre><code>#!/usr/bin/env python\n\"\"\"Django's command-line utility for administrative tasks.\"\"\"\nimport os\nimport sys\nimport environ\n\ndef main():\n    \"\"\"Run administrative tasks.\"\"\"\n    env = environ.Env()\n    # Read environment variables from the .env file\n    environ.Env.read_env()  \n\n    # Get the DEBUG flag from the environment, default to False if not set\n    DEBUG = env.bool('DEBUG', default=False)\n\n    # Set the appropriate settings module based on DEBUG\n    if DEBUG:\n        os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'dating_app.settings.local')\n    else:\n        os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'dating_app.settings.prod')\n\n    try:\n        from django.core.management import execute_from_command_line\n    except ImportError as exc:\n        raise ImportError(\n            \"Couldn't import Django. Are you sure it's installed and \"\n            \"available on your PYTHONPATH environment variable? Did you \"\n            \"forget to activate a virtual environment?\"\n        ) from exc\n    execute_from_command_line(sys.argv)\n\nif __name__ == '__main__':\n    main()\n</code></pre> <pre><code>import os\nimport environ\nfrom django.core.wsgi import get_wsgi_application\n\n# Initialize environment variables\nenv = environ.Env()\nenviron.Env.read_env()  # Reads environment variables from .env file\n\n# Determine the settings module based on DEBUG\nDEBUG = env.bool('DEBUG', default=False)\nsettings_module = 'dating_app.settings.local' if DEBUG else 'dating_app.settings.prod'\n\n# Set the Django settings module environment variable\nos.environ.setdefault('DJANGO_SETTINGS_MODULE', settings_module)\n\napplication = get_wsgi_application()\n</code></pre> <pre><code>import os\nimport environ\nfrom django.core.asgi import get_asgi_application\n\n# Initialize environment variables\nenv = environ.Env()\nenviron.Env.read_env()  # Reads environment variables from .env file\n\n# Determine the settings module based on DEBUG\nDEBUG = env.bool('DEBUG', default=False)\nsettings_module = 'dating_app.settings.local' if DEBUG else 'dating_app.settings.prod'\n\n# Set the Django settings module environment variable\nos.environ.setdefault('DJANGO_SETTINGS_MODULE', settings_module)\n\napplication = get_asgi_application()\n</code></pre>","tags":["Python","Django"]},{"location":"blog/2024/07/09/configuring-django-for-local-and-production-environments-with-dynamic-env-files/#method-2","title":"Method 2","text":"","tags":["Python","Django"]},{"location":"blog/2024/07/09/configuring-django-for-local-and-production-environments-with-dynamic-env-files/#osgetenv","title":"os.getenv()","text":"<p>The <code>os.getenv('DJANGO_ENVIRONMENT', 'local')</code> line in your code is designed to get the value of the <code>DJANGO_ENVIRONMENT</code> environment variable. If <code>DJANGO_ENVIRONMENT</code> is not set, it defaults to <code>'local'</code>. This allows your application to decide which settings to use based on the environment it's running in. Here's how it works in different scenarios:</p> How It Works <ol> <li> <p>Local Development:</p> <ul> <li>When you run your application locally, you typically set the <code>DJANGO_ENVIRONMENT</code> variable in your local <code>.env</code> file.</li> <li> <p>For instance, your local <code>.env</code> file might contain:</p> <pre><code>DJANGO_ENVIRONMENT=local\n</code></pre> </li> <li> <p>This ensures that the application reads the correct environment-specific <code>.env</code> file (e.g., <code>.env.local</code>).</p> </li> </ul> </li> <li> <p>Deployment:</p> <ul> <li>On your deployment platform (like Heroku, Docker, AWS, etc.), you set the <code>DJANGO_ENVIRONMENT</code> environment variable to the appropriate value for the environment.</li> <li> <p>For example, in a production environment, you would set <code>DJANGO_ENVIRONMENT</code> to <code>prod</code>:</p> <pre><code>export DJANGO_ENVIRONMENT=prod\n</code></pre> </li> <li> <p>The deployment environment should be configured to use the <code>prod</code> setting and read the <code>.env.prod</code> file.</p> </li> </ul> </li> </ol>","tags":["Python","Django"]},{"location":"blog/2024/07/09/configuring-django-for-local-and-production-environments-with-dynamic-env-files/#example-code-breakdown","title":"Example Code Breakdown","text":"<p>Here's a more detailed example to clarify:</p> manage.py<pre><code>import os\nimport sys\nimport environ\n\ndef main():\n    \"\"\"Run administrative tasks.\"\"\"\n    env = environ.Env()\n\n    # Determine the environment and load the corresponding .env file\n    environment = os.getenv('DJANGO_ENVIRONMENT', 'local')\n    env_file = f'.env.{environment}'\n    env.read_env(env_file)\n\n    settings_module = f'your_project.settings.{environment}'\n    os.environ.setdefault('DJANGO_SETTINGS_MODULE', settings_module)\n\n    try:\n        from django.core.management import execute_from_command_line\n    except ImportError as exc:\n        raise ImportError(\n            \"Couldn't import Django. Are you sure it's installed and \"\n            \"available on your PYTHONPATH environment variable? Did you \"\n            \"forget to activate a virtual environment?\"\n        ) from exc\n    execute_from_command_line(sys.argv)\n\nif __name__ == '__main__':\n    main()\n</code></pre> Explanation: <ul> <li><code>os.getenv('DJANGO_ENVIRONMENT', 'local')</code> retrieves the value of <code>DJANGO_ENVIRONMENT</code> from the environment.<ul> <li>If <code>DJANGO_ENVIRONMENT</code> is set (e.g., to <code>prod</code> in production), it will use that value.</li> <li>If <code>DJANGO_ENVIRONMENT</code> is not set, it defaults to <code>'local'</code>.</li> </ul> </li> <li>Based on the value of <code>DJANGO_ENVIRONMENT</code>, the appropriate <code>.env</code> file is loaded (<code>.env.prod</code>, <code>.env.local</code>, etc.).</li> <li>The settings module is then set according to the environment (e.g., <code>your_project.settings.prod</code>).</li> </ul> Deployment Configuration <ol> <li> <p>On Local Development:</p> <ul> <li>Ensure your <code>.env</code> file contains <code>DJANGO_ENVIRONMENT=local</code>.</li> </ul> </li> <li> <p>On Production:</p> <ul> <li>Set the <code>DJANGO_ENVIRONMENT</code> variable in your deployment configuration or environment settings.</li> <li> <p>For example, in Heroku, you can set environment variables through the Heroku CLI:</p> <pre><code>heroku config:set DJANGO_ENVIRONMENT=prod\n</code></pre> </li> <li> <p>In Docker, you might configure it in your Dockerfile or <code>docker-compose.yml</code>:</p> <pre><code>ENV DJANGO_ENVIRONMENT=prod\n</code></pre> </li> </ul> </li> </ol>","tags":["Python","Django"]},{"location":"blog/2024/07/09/configuring-django-for-local-and-production-environments-with-dynamic-env-files/#summary","title":"Summary","text":"<p>The <code>os.getenv('DJANGO_ENVIRONMENT', 'local')</code> approach allows you to dynamically load configuration based on the environment. The default value <code>'local'</code> ensures that if <code>DJANGO_ENVIRONMENT</code> is not set (e.g., during local development), it will use the local settings. When deploying, you should configure the environment variable to reflect the correct environment (e.g., <code>prod</code>), so your application reads the appropriate settings and <code>.env</code> file.</p>","tags":["Python","Django"]},{"location":"blog/2024/07/09/configuring-django-for-local-and-production-environments-with-dynamic-env-files/#method-3","title":"Method 3","text":"<p>Certainly! Here\u2019s a more detailed example of how to manage multiple environments (e.g., <code>development</code>, <code>staging</code>, <code>production</code>) using an environment-specific environment variable (<code>DJANGO_ENVIRONMENT</code>) and separate <code>.env</code> files for each environment.</p>","tags":["Python","Django"]},{"location":"blog/2024/07/09/configuring-django-for-local-and-production-environments-with-dynamic-env-files/#directory-structure","title":"Directory Structure","text":"<p>Assume the following directory structure for your Django project:</p> <pre><code>your_project/\n    settings/\n        __init__.py\n        base.py\n        local.py\n        staging.py\n        prod.py\n    .env.local\n    .env.staging\n    .env.prod\n    manage.py\n    wsgi.py\n    asgi.py\n</code></pre>","tags":["Python","Django"]},{"location":"blog/2024/07/09/configuring-django-for-local-and-production-environments-with-dynamic-env-files/#1-define-your-settings-files","title":"1. Define Your Settings Files","text":"base.pylocal.pystaging.pyprod.py <ul> <li> <p><code>settings/base.py</code>: Common settings for all environments</p> <pre><code># settings/base.py\n\nimport os\n\nBASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))\n\nSECRET_KEY = os.getenv('SECRET_KEY', 'default-secret-key')\nINSTALLED_APPS = [\n    # common apps\n]\nMIDDLEWARE = [\n    # common middleware\n]\nDATABASES = {\n    'default': {\n        'ENGINE': 'django.db.backends.sqlite3',\n        'NAME': os.path.join(BASE_DIR, 'db.sqlite3'),\n    }\n}\n# Other common settings\n</code></pre> </li> </ul> <ul> <li> <p><code>settings/local.py</code>: Development-specific settings</p> <pre><code># settings/local.py\n\nfrom .base import *\n\nDEBUG = True\nALLOWED_HOSTS = []\n\nDATABASES['default'] = {\n    'ENGINE': 'django.db.backends.postgresql',\n    'NAME': os.getenv('DEV_DB_NAME'),\n    'USER': os.getenv('DEV_DB_USER'),\n    'PASSWORD': os.getenv('DEV_DB_PASSWORD'),\n    'HOST': os.getenv('DEV_DB_HOST'),\n    'PORT': os.getenv('DEV_DB_PORT'),\n}\n</code></pre> </li> </ul> <ul> <li> <p><code>settings/staging.py</code>: Staging-specific settings</p> <pre><code># settings/staging.py\n\nfrom .base import *\n\nDEBUG = False\nALLOWED_HOSTS = ['staging.example.com']\n\nDATABASES['default'] = {\n    'ENGINE': 'django.db.backends.postgresql',\n    'NAME': os.getenv('STAGING_DB_NAME'),\n    'USER': os.getenv('STAGING_DB_USER'),\n    'PASSWORD': os.getenv('STAGING_DB_PASSWORD'),\n    'HOST': os.getenv('STAGING_DB_HOST'),\n    'PORT': os.getenv('STAGING_DB_PORT'),\n}\n</code></pre> </li> </ul> <ul> <li> <p><code>settings/prod.py</code>: Production-specific settings</p> <pre><code># settings/prod.py\n\nfrom .base import *\n\nDEBUG = False\nALLOWED_HOSTS = ['example.com']\n\nDATABASES['default'] = {\n    'ENGINE': 'django.db.backends.postgresql',\n    'NAME': os.getenv('PROD_DB_NAME'),\n    'USER': os.getenv('PROD_DB_USER'),\n    'PASSWORD': os.getenv('PROD_DB_PASSWORD'),\n    'HOST': os.getenv('PROD_DB_HOST'),\n    'PORT': os.getenv('PROD_DB_PORT'),\n}\n</code></pre> </li> </ul>","tags":["Python","Django"]},{"location":"blog/2024/07/09/configuring-django-for-local-and-production-environments-with-dynamic-env-files/#2-create-environment-specific-env-files","title":"2. Create Environment-Specific <code>.env</code> Files","text":".env.local.env.staging.env.prod <ul> <li> <p><code>.env.local</code>: Development environment variables</p> <pre><code>DJANGO_ENVIRONMENT=local\nSECRET_KEY=your-local-secret-key\nDEV_DB_NAME=dev_db\nDEV_DB_USER=dev_user\nDEV_DB_PASSWORD=dev_password\nDEV_DB_HOST=localhost\nDEV_DB_PORT=5432\n</code></pre> </li> </ul> <ul> <li> <p><code>.env.staging</code>: Staging environment variables</p> <pre><code>DJANGO_ENVIRONMENT=staging\nSECRET_KEY=your-staging-secret-key\nSTAGING_DB_NAME=staging_db\nSTAGING_DB_USER=staging_user\nSTAGING_DB_PASSWORD=staging_password\nSTAGING_DB_HOST=localhost\nSTAGING_DB_PORT=5432\n</code></pre> </li> </ul> <ul> <li> <p><code>.env.prod</code>: Production environment variables</p> <pre><code>DJANGO_ENVIRONMENT=prod\nSECRET_KEY=your-prod-secret-key\nPROD_DB_NAME=prod_db\nPROD_DB_USER=prod_user\nPROD_DB_PASSWORD=prod_password\nPROD_DB_HOST=localhost\nPROD_DB_PORT=5432\n</code></pre> </li> </ul>","tags":["Python","Django"]},{"location":"blog/2024/07/09/configuring-django-for-local-and-production-environments-with-dynamic-env-files/#update-managepy-wsgipy-asgipy","title":"Update <code>manage.py</code>, <code>wsgi.py</code>, <code>asgi.py</code>","text":"<p>Modify <code>manage.py</code>, <code>wsgi.py</code> and <code>asgi.py</code> to use the <code>DJANGO_ENVIRONMENT</code> variable and load the appropriate <code>.env</code> file:</p> manage.pywsgi.pyasgi.py <pre><code>#!/usr/bin/env python\n\"\"\"Django's command-line utility for administrative tasks.\"\"\"\nimport os\nimport sys\nimport environ\n\ndef main():\n    \"\"\"Run administrative tasks.\"\"\"\n    env = environ.Env()\n\n    # Determine the environment and load the corresponding .env file\n    environment = os.getenv('DJANGO_ENVIRONMENT', 'local')\n    env_file = f'.env.{environment}'\n\n    env.read_env(env_file)\n\n    settings_module = f'dating_app.settings.{environment}'\n    os.environ.setdefault('DJANGO_SETTINGS_MODULE', settings_module)\n\n    try:\n        from django.core.management import execute_from_command_line\n    except ImportError as exc:\n        raise ImportError(\n            \"Couldn't import Django. Are you sure it's installed and \"\n            \"available on your PYTHONPATH environment variable? Did you \"\n            \"forget to activate a virtual environment?\"\n        ) from exc\n    execute_from_command_line(sys.argv)\n\nif __name__ == '__main__':\n    main()\n</code></pre> <pre><code>import os\nimport environ\nfrom django.core.wsgi import get_wsgi_application\n\nenv = environ.Env()\nenvironment = os.getenv('DJANGO_ENVIRONMENT', 'local')\nenv_file = f'.env.{environment}'\nenv.read_env(env_file)\n\nsettings_module = f'dating_app.settings.{environment}'\nos.environ.setdefault('DJANGO_SETTINGS_MODULE', settings_module)\n\napplication = get_wsgi_application()\n</code></pre> <pre><code>import os\nimport environ\nfrom django.core.asgi import get_asgi_application\n\nenv = environ.Env()\nenvironment = os.getenv('DJANGO_ENVIRONMENT', 'local')\nenv_file = f'.env.{environment}'\nenv.read_env(env_file)\n\nsettings_module = f'dating_app.settings.{environment}'\nos.environ.setdefault('DJANGO_SETTINGS_MODULE', settings_module)\n\napplication = get_asgi_application()\n</code></pre>","tags":["Python","Django"]},{"location":"blog/2024/07/09/configuring-django-for-local-and-production-environments-with-dynamic-env-files/#summary_1","title":"Summary","text":"<p>By using environment-specific environment variables and <code>.env</code> files, you gain the flexibility to manage different environments (development, staging, production) more efficiently. Each environment can have its own configuration without relying solely on the <code>DEBUG</code> flag, which improves clarity and maintainability.</p>","tags":["Python","Django"]},{"location":"blog/2024/07/09/configuring-django-for-local-and-production-environments-with-dynamic-env-files/#env-example","title":"Env Example","text":"<pre><code># .env\n\nDEBUG=True\nSECRET_KEY='your-secret-key'\nDEV_DB_NAME='dev_db'\nDEV_DB_USER='dev_user'\nDEV_DB_PASSWORD='dev_password'\nDEV_DB_HOST='localhost'\nDEV_DB_PORT='5432'\nPROD_DB_NAME='prod_db'\nPROD_DB_USER='prod_user'\nPROD_DB_PASSWORD='prod_password'\nPROD_DB_HOST='localhost'\nPROD_DB_PORT='5432'\n</code></pre>","tags":["Python","Django"]},{"location":"blog/2024/07/09/configuring-django-for-local-and-production-environments-with-dynamic-env-files/#set-environment-variable-in-ubuntu","title":"Set Environment Variable in Ubuntu","text":"<p>On your Ubuntu system, you need to set the <code>DJANGO_ENVIRONMENT</code> environment variable to indicate which environment you are in. You can set this variable temporarily in the terminal or permanently by adding it to your profile.</p>","tags":["Python","Django"]},{"location":"blog/2024/07/09/configuring-django-for-local-and-production-environments-with-dynamic-env-files/#to-list-or-view-the-value-of-the-django_environment","title":"To list or view the value of the <code>DJANGO_ENVIRONMENT</code>","text":"<ul> <li> <p>To list or view the value of the DJANGO_ENVIRONMENT environment variable on your system,</p> <pre><code>echo $DJANGO_ENVIRONMENT\n</code></pre> </li> <li> <p>List All Environment Variables:</p> <pre><code>printenv\n\n# or\n\nenv\n</code></pre> </li> </ul>","tags":["Python","Django"]},{"location":"blog/2024/07/09/configuring-django-for-local-and-production-environments-with-dynamic-env-files/#temporarily-setting-environment-variable","title":"Temporarily Setting Environment Variable","text":"<ul> <li> <p>To set an environment variable for the duration of the terminal session:</p> <pre><code>export VARIABLE_NAME=value\n</code></pre> </li> <li> <p>In your terminal, you can set the environment variable before running your Django commands:</p> <pre><code>export DJANGO_ENVIRONMENT=prod  # or local, staging\npython manage.py runserver\n</code></pre> </li> <li> <p>You can then verify it using:</p> <pre><code>echo $DJANGO_ENVIRONMENT\n</code></pre> </li> </ul>","tags":["Python","Django"]},{"location":"blog/2024/07/09/configuring-django-for-local-and-production-environments-with-dynamic-env-files/#permanently-setting-environment-variable","title":"Permanently Setting Environment Variable","text":"<ul> <li> <p>To make the environment variable permanent for your user, add it to your <code>.bashrc</code> or <code>.bash_profile</code> file:</p> <ol> <li> <p>Open your <code>.bashrc</code> file in a text editor:</p> <pre><code>nano ~/.bashrc\n</code></pre> </li> <li> <p>Add the environment variable at the end of the file:</p> <pre><code>export DJANGO_ENVIRONMENT=prod  # or local, staging\n</code></pre> </li> <li> <p>Save the file and reload the shell configuration:</p> <pre><code>source ~/.bashrc\n</code></pre> </li> </ol> </li> <li> <p>Alternatively, you can use <code>.profile</code> or <code>.zshrc</code> if you use a different shell.</p> </li> </ul>","tags":["Python","Django"]},{"location":"blog/2024/07/09/configuring-django-for-local-and-production-environments-with-dynamic-env-files/#summary_2","title":"Summary","text":"<p>By using environment-specific <code>.env</code> files and setting the <code>DJANGO_ENVIRONMENT</code> variable, you can dynamically configure Django to use different settings based on the environment. In Ubuntu, you set the environment variable in your shell or profile to ensure Django loads the correct <code>.env</code> file. This approach helps manage different configurations for development, staging, and production environments efficiently.</p>","tags":["Python","Django"]},{"location":"blog/2024/07/12/content-type-or-mime-type-in-post/","title":"Content-Type or MIME type in Post","text":"","tags":["postman","http"]},{"location":"blog/2024/07/12/content-type-or-mime-type-in-post/#content-type-or-mime-type-in-post","title":"Content-Type or MIME type in Post","text":"<p>The Content-Type representation header is used to indicate the original media type of the resource (prior to any content encoding applied for sending).</p>","tags":["postman","http"]},{"location":"blog/2024/07/12/content-type-or-mime-type-in-post/#syntax","title":"Syntax","text":"HTTP<pre><code>Content-Type: text/html; charset=utf-8\nContent-Type: multipart/form-data; boundary=something\n</code></pre>","tags":["postman","http"]},{"location":"blog/2024/07/12/content-type-or-mime-type-in-post/#most-used","title":"Most used","text":"<p>The most commonly used <code>Content-Type</code> (or MIME type) for POST HTTP requests depends on the type of data being sent. Here are a few of the most frequently used Content-Type headers:</p> <ol> <li>application/json: Used for sending JSON data.</li> </ol>","tags":["postman","http"]},{"location":"blog/2024/07/12/content-type-or-mime-type-in-post/#examples","title":"Examples","text":"Content-Type in HTML forms <p>In a POST request, resulting from an HTML form submission, the Content-Type of the request is specified by the enctype attribute on the <code>&lt;form&gt;</code> element.</p> <pre><code>&lt;form action=\"/foo\" method=\"post\" enctype=\"multipart/form-data\"&gt;\n&lt;input type=\"text\" name=\"description\" value=\"some text\" /&gt;\n&lt;input type=\"file\" name=\"myFile\" /&gt;\n&lt;button type=\"submit\"&gt;Submit&lt;/button&gt;\n&lt;/form&gt;\n</code></pre> <p>The request looks something like this (less interesting headers are omitted here):</p> HTTP<pre><code>POST /foo HTTP/1.1\nContent-Length: 68137\nContent-Type: multipart/form-data; boundary=---------------------------974767299852498929531610575\n\n-----------------------------974767299852498929531610575\nContent-Disposition: form-data; name=\"description\"\n\nsome text\n-----------------------------974767299852498929531610575\nContent-Disposition: form-data; name=\"myFile\"; filename=\"foo.txt\"\nContent-Type: text/plain\n\n(content of the uploaded file foo.txt)\n-----------------------------974767299852498929531610575--\n</code></pre>","tags":["postman","http"]},{"location":"blog/2024/07/12/content-type-or-mime-type-in-post/#mime-types","title":"MIME types","text":"<p>A MIME type (now properly called \"media type\", but also sometimes \"content type\") is a string sent along with a file indicating the type of the file (describing the content format, for example, a sound file might be labeled <code>audio/ogg</code>, or an image file <code>image/png</code>).</p>","tags":["postman","http"]},{"location":"blog/2024/07/12/content-type-or-mime-type-in-post/#multipart-types","title":"Multipart types","text":"<p>There are two multipart types:</p> <ol> <li>message</li> <li>multipart</li> </ol>","tags":["postman","http"]},{"location":"blog/2024/07/12/content-type-or-mime-type-in-post/#important-mime-types-for-web-developers","title":"Important MIME types for Web developers","text":"<ol> <li> <p>application/octet-stream</p> <p>This is the default for <code>binary files</code>. As it means unknown binary file, browsers usually don't execute it, or even ask if it should be executed. They treat it as if the Content-Disposition header was set to <code>attachment</code>, and propose a \"Save As\" dialog.</p> </li> <li> <p>text/plain</p> <p>This is the default for textual files. Even if it really means \"unknown textual file,\" browsers assume they can display it.</p> </li> </ol> Example TextApplicationImagesAudio/VideoFonts <pre><code>Text\n\ntext/html: HTML documents.\nContent-Type: text/html\n\ntext/css: Cascading Style Sheets.\nContent-Type: text/css\n\ntext/javascript or application/javascript: JavaScript files.\nContent-Type: text/javascript\n</code></pre> <pre><code>Application\n\napplication/json: JSON data.\nContent-Type: application/json\n\napplication/xml: XML data.\nContent-Type: application/xml\n\napplication/octet-stream: Arbitrary binary data. Often used for file downloads.\nContent-Type: application/octet-stream\n\napplication/pdf: PDF documents.\nContent-Type: application/pdf\n\napplication/x-www-form-urlencoded: Form data in URL-encoded format.\nContent-Type: application/x-www-form-urlencoded\n\nmultipart/form-data: Form data that includes files or binary data.\nContent-Type: multipart/form-data; boundary=---boundary\n</code></pre> <pre><code>Images\n\nimage/jpeg: JPEG images.\nContent-Type: image/jpeg\n\nimage/png: PNG images.\nContent-Type: image/png\n\nimage/gif: GIF images.\nContent-Type: image/gif\n\nimage/svg+xml: SVG vector images.\nContent-Type: image/svg+xml\n</code></pre> <pre><code>Audio/Video\n\naudio/mpeg: MP3 audio files.\nContent-Type: audio/mpeg\n\naudio/ogg: OGG audio files.\nContent-Type: audio/ogg\n\naudio/wav: WAV audio files.\nContent-Type: audio/wav\n\nvideo/mp4: MP4 video files.\nContent-Type: video/mp4\n\nvideo/ogg: OGG video files.\nContent-Type: video/ogg\n</code></pre> <pre><code>Fonts\n\nfont/woff: Web Open Font Format (WOFF).\nContent-Type: font/woff\n\nfont/woff2: Web Open Font Format (WOFF2).\nContent-Type: font/woff2\n</code></pre> <p>Understanding these MIME types is crucial for web development as they help ensure that the server and browser correctly interpret and handle various types of content. Using the correct MIME type ensures proper rendering and functionality of web pages and applications.</p>","tags":["postman","http"]},{"location":"blog/2024/07/12/content-type-or-mime-type-in-post/#mime-type-content-type-realtionship","title":"MIME-Type &amp; Content-Type Realtionship","text":"","tags":["postman","http"]},{"location":"blog/2024/07/12/content-type-or-mime-type-in-post/#mime-type","title":"MIME Type","text":"<ul> <li>What it is: A way to describe the type of content.</li> <li>Format: <code>type/subtype</code> (e.g., <code>application/json</code>, <code>text/html</code>).</li> <li>Example: <code>application/json</code> means the content is JSON.</li> </ul>","tags":["postman","http"]},{"location":"blog/2024/07/12/content-type-or-mime-type-in-post/#content-type","title":"Content-Type","text":"<ul> <li>What it is: An HTTP header that tells the server what type of content is being sent.</li> <li>What it contains: A MIME type.</li> <li>Example: <code>Content-Type: application/json</code> means the content being sent is JSON.</li> </ul>","tags":["postman","http"]},{"location":"blog/2024/07/12/content-type-or-mime-type-in-post/#relationship","title":"Relationship","text":"<ul> <li>The <code>Content-Type</code> header uses MIME types to specify the format of the data.</li> <li>In other words: MIME type is the value, and <code>Content-Type</code> is the header that holds that value.</li> </ul>","tags":["postman","http"]},{"location":"blog/2024/07/12/content-type-or-mime-type-in-post/#example-in-a-post-request","title":"Example in a POST Request","text":"<p>When sending JSON data in a POST request:</p> <pre><code>POST /api/resource HTTP/1.1\nHost: example.com\nContent-Type: application/json\nContent-Length: 27\n\n{\n  \"name\": \"John\",\n  \"age\": 30\n}\n</code></pre> <ul> <li>Content-Type header: <code>Content-Type: application/json</code></li> <li>MIME type used: <code>application/json</code></li> </ul>","tags":["postman","http"]},{"location":"blog/2024/07/12/content-type-or-mime-type-in-post/#summary","title":"Summary","text":"<ul> <li>MIME Type: Describes the type of content (e.g., <code>application/json</code>).</li> <li>Content-Type: The HTTP header that includes the MIME type to tell the server what kind of data you're sending.</li> </ul> <p>So, MIME type and Content-Type are closely related, with MIME type being the description of the content and Content-Type being the header that communicates this description in HTTP requests.</p>","tags":["postman","http"]},{"location":"blog/2024/07/12/content-type-or-mime-type-in-post/#reference","title":"Reference","text":"<ul> <li>Content-Type: Http Headers</li> <li>what the heck is multipart/form-data???: medium</li> <li>MIME_types</li> </ul>","tags":["postman","http"]},{"location":"blog/2024/06/30/customizing-the-reqest-and-response-in-drf/","title":"Customizing the Reqest and Response in DRF","text":"","tags":["django","management"]},{"location":"blog/2024/06/30/customizing-the-reqest-and-response-in-drf/#customizing-the-reqest-and-response-in-drf","title":"Customizing the Reqest and Response in DRF","text":"<p>Customizing the request and response JSON payload in Django Rest Framework (DRF) involves utilizing serializers, views, and potentially middleware to tailor how data is structured and presented in your API. Here's a comprehensive guide on how to achieve this customization:</p>","tags":["django","management"]},{"location":"blog/2024/06/30/customizing-the-reqest-and-response-in-drf/#customizing-request-payload","title":"Customizing Request Payload","text":"<ol> <li> <p>Serializer Definition</p> <p>To customize how incoming data is processed and validated, you define serializers for your models:</p> <pre><code>from rest_framework import serializers\nfrom .models import MyModel\n\nclass MyModelSerializer(serializers.ModelSerializer):\n    class Meta:\n        model = MyModel\n        fields = ['id', 'field1', 'field2']  # Define fields to include in request and response\n\n    def validate_field1(self, value):\n        # Custom validation logic for field1\n        if value &lt; 0:\n            raise serializers.ValidationError(\"field1 must be non-negative.\")\n        return value\n\n    def create(self, validated_data):\n        # Custom creation logic\n        instance = MyModel.objects.create(**validated_data)\n        return instance\n\n    def update(self, instance, validated_data):\n        # Custom update logic\n        instance.field1 = validated_data.get('field1', instance.field1)\n        instance.field2 = validated_data.get('field2', instance.field2)\n        instance.save()\n        return instance\n</code></pre> </li> <li> <p>View Definition</p> <p>In your view, specify the serializer class and customize further as needed:</p> <pre><code>from rest_framework import viewsets\nfrom .models import MyModel\nfrom .serializers import MyModelSerializer\n\nclass MyModelViewSet(viewsets.ModelViewSet):\n    queryset = MyModel.objects.all()\n    serializer_class = MyModelSerializer\n\n    # Customize queryset, permissions, authentication, etc.\n</code></pre> </li> </ol>","tags":["django","management"]},{"location":"blog/2024/06/30/customizing-the-reqest-and-response-in-drf/#customizing-response-payload","title":"Customizing Response Payload","text":"<ol> <li> <p>Serializer Customization</p> <p>To tailor the structure and content of the response JSON:</p> <pre><code>class MyModelSerializer(serializers.ModelSerializer):\nfield1_times_two = serializers.SerializerMethodField()\n\nclass Meta:\n    model = MyModel\n    fields = ['id', 'field1', 'field2', 'field1_times_two']\n\ndef get_field1_times_two(self, obj):\n    return obj.field1 * 2\n</code></pre> </li> <li> <p>Custom Response Formatting</p> <p>Use <code>Response</code> objects or customize <code>list</code> and <code>retrieve</code> methods in views:</p> <pre><code>from rest_framework.response import Response\nfrom rest_framework.views import APIView\n\nclass MyModelList(APIView):\n    def get(self, request):\n        queryset = MyModel.objects.all()\n        serializer = MyModelSerializer(queryset, many=True)\n        return Response({\n            'custom_key': serializer.data  # Custom key in response JSON\n        })\n\n    def post(self, request):\n        serializer = MyModelSerializer(data=request.data)\n        if serializer.is_valid():\n            serializer.save()\n            return Response(serializer.data, status=status.HTTP_201_CREATED)\n        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)\n</code></pre> </li> </ol>","tags":["django","management"]},{"location":"blog/2024/06/30/customizing-the-reqest-and-response-in-drf/#middleware-for-advanced-customization","title":"Middleware for Advanced Customization","text":"<ol> <li> <p>Middleware Definition</p> <p>For <code>low-level</code> customization, <code>use</code> middleware:</p> <pre><code>class MyCustomMiddleware:\n    def __init__(self, get_response):\n        self.get_response = get_response\n\n    def __call__(self, request):\n        # Modify request data here\n        response = self.get_response(request)\n        # Modify response data here\n        return response\n</code></pre> </li> <li> <p>Integration with Django Middleware</p> <p>Include middleware in <code>settings.py</code>:</p> <pre><code>MIDDLEWARE = [\n    # Other middleware\n    'myapp.middleware.MyCustomMiddleware',\n]\n</code></pre> </li> </ol>","tags":["django","management"]},{"location":"blog/2024/06/30/customizing-the-reqest-and-response-in-drf/#conclusion","title":"Conclusion","text":"<p>Customizing the request and response JSON payload in Django Rest Framework involves utilizing serializers for data validation and customization, defining views to handle CRUD operations and format responses, and optionally using middleware for lower-level adjustments. This approach allows developers to tailor API behavior and structure data to meet specific application requirements effectively. By understanding and leveraging these customization techniques, developers can build robust and flexible APIs tailored to their project's needs.</p> Usage in <code>create</code> and <code>update</code> Methods? <p>In Django Rest Framework (DRF), validated_data is a dictionary containing the deserialized and validated data after the serializer has processed the incoming request data. This dictionary typically represents the cleaned and validated data that is ready to be used for creating or updating an object.</p> <p>Usage in create and update Methods</p> <p>In DRF serializers, such as <code>ModelSerializer</code>, you often define create and update methods to customize how objects are created or updated in the database. Here's how <code>validated_data</code> is used in these methods:</p> <p>Note</p> create Methodupdate Method  <pre><code>class MyModelSerializer(serializers.ModelSerializer):\n    class Meta:\n        model = MyModel\n        fields = ['field1', 'field2']\n\n    def create(self, validated_data):\n        instance = MyModel.objects.create(**validated_data)\n        return instance\n</code></pre> <p>In the create method:</p> <ul> <li><code>validated_data</code> is a dictionary containing the cleaned and validated data extracted from the incoming request payload.</li> <li>It includes only the fields that are defined in the serializer's <code>Meta</code> class (<code>fields</code> attribute).</li> <li>You use <code>validated_data</code> to create a new instance of the <code>MyModel</code> model using <code>MyModel.objects.create(**validated_data)</code>.</li> </ul> <pre><code>class MyModelSerializer(serializers.ModelSerializer):\n    class Meta:\n        model = MyModel\n        fields = ['field1', 'field2']\n\n    def update(self, instance, validated_data):\n        instance.field1 = validated_data.get('field1', instance.field1)\n        instance.field2 = validated_data.get('field2', instance.field2)\n        instance.save()\n        return instance\n</code></pre> <p>In the update method:</p> <ul> <li><code>instance</code> refers to the existing instance of <code>MyModel</code> that is being updated.</li> <li><code>validated_data</code> contains the cleaned and validated data extracted from the incoming request payload.</li> <li>You update the fields of <code>instance</code> with values from validated_data.</li> <li>Finally, you save the instance (<code>instance.save()</code>) and return the updated instance.</li> </ul> <p>Purpose of validated_data</p> <ul> <li> <p>Data Validation: Before reaching the <code>create</code> or <code>update</code> method, DRF serializers perform validation on incoming data based on serializer field definitions (e.g., required fields, field types, validation rules).</p> </li> <li> <p>Serialization: After validation passes, <code>validated_data</code> contains the sanitized and processed data ready for database operations.</p> </li> <li> <p>Simplifies Business Logic: By using <code>validated_data</code>, you ensure that only valid and cleaned data is used for database operations, thus maintaining data integrity and consistency.</p> </li> </ul> <p>Conclusion</p> <p><code>validated_data</code> in DRF serializers encapsulates the cleaned, validated, and ready-to-use data extracted from incoming requests. It plays a crucial role in ensuring that your application handles data securely and accurately, adhering to defined validation rules and business logic. Understanding how to utilize <code>validated_data</code> effectively allows developers to build robust and reliable APIs using Django Rest Framework.</p> Methods <p>Django Rest Framework (DRF) serializers offer several other methods that are commonly used to customize behavior and handle various aspects of data serialization and validation. </p> Serializers Methods <ul> <li>to_representation()</li> <li>to_internal_value()</li> </ul>","tags":["django","management"]},{"location":"blog/2024/06/30/customizing-the-reqest-and-response-in-drf/#reference","title":"Reference","text":"<ul> <li>drf-serializers</li> <li>serializers in django</li> </ul>","tags":["django","management"]},{"location":"blog/2024/07/04/customizing-swagger-ui-removing-the-django-login-button/","title":"Customizing Swagger UI: Removing the Django Login Button","text":"","tags":["django","management"]},{"location":"blog/2024/07/04/customizing-swagger-ui-removing-the-django-login-button/#customizing-swagger-ui-removing-the-django-login-button","title":"Customizing Swagger UI: Removing the Django Login Button","text":"<pre><code>pip install drf-yasg\n</code></pre> settings.py<pre><code>SWAGGER_SETTINGS = {\n    'DEFAULT_GENERATOR_CLASS': 'drf_yasg.generators.OpenAPISchemaGenerator',\n    'USE_SESSION_AUTH': False,  # Disable session authentication if desired\n}\n</code></pre>","tags":["django","management"]},{"location":"blog/2024/07/04/customizing-swagger-ui-removing-the-django-login-button/#to-customize-the-swagger-ui-to-use-jwt-tokens-instead-of-basic-auth","title":"To customize the Swagger UI to use JWT tokens instead of Basic Auth,","text":"<p>you need to modify the Swagger configuration to include JWT authentication</p> settings.py<pre><code>SWAGGER_SETTINGS = {\n    'DEFAULT_INFO': 'path.to.your_project.urls.api_info',\n    'SECURITY_DEFINITIONS': {\n        'Bearer': {\n            'type': 'apiKey',\n            'name': 'Authorization',\n            'in': 'header'\n        }\n    },\n    'USE_SESSION_AUTH': False,\n}\n</code></pre>","tags":["django","management"]},{"location":"blog/2024/07/04/customizing-swagger-ui-removing-the-django-login-button/#example-configuration","title":"Example Configuration","text":"Example <pre><code>SWAGGER_SETTINGS = {\n    'DEFAULT_GENERATOR_CLASS': 'drf_yasg.generators.OpenAPISchemaGenerator',\n    'DEFAULT_AUTO_SCHEMA_CLASS': 'drf_yasg.inspectors.SwaggerAutoSchema',\n    'USE_SESSION_AUTH': False,\n    'SECURITY_DEFINITIONS': {\n        'Bearer': {\n            'type': 'apiKey',\n            'name': 'Authorization',\n            'in': 'header'\n        }\n    },\n    'DOC_EXPANSION': 'none',\n    'OPERATIONS_SORTER': 'alpha',\n    'SHOW_REQUEST_HEADERS': True,\n    'SHOW_EXTENSIONS': True,\n    'VALIDATOR_URL': None,\n    'PERSIST_AUTH': True,\n    'APIS_SORTER': 'alpha',\n    'TAGS_SORTER': 'alpha',\n    'JSON_EDITOR': True,\n    'SUPPORTED_SUBMIT_METHODS': [\n        'get', 'post', 'put', 'delete', 'patch'\n    ],\n    'DEFAULT_FIELD_INSPECTORS': [\n        'drf_yasg.inspectors.CamelCaseJSONFilter',\n        'drf_yasg.inspectors.DjangoRestResponsePagination',\n        'drf_yasg.inspectors.DjangoRestResponseFilter',\n        'drf_yasg.inspectors.RestFrameworkDefaultSchema'\n    ],\n    'DEFAULT_PAGINATOR_INSPECTORS': [\n        'drf_yasg.inspectors.DjangoRestResponsePagination',\n        'drf_yasg.inspectors.RestFrameworkDefaultPaginator'\n    ],\n    'DEFAULT_FILTER_INSPECTORS': [\n        'drf_yasg.inspectors.DjangoRestResponseFilter',\n        'drf_yasg.inspectors.RestFrameworkDefaultFilter'\n    ]\n}\n</code></pre>","tags":["django","management"]},{"location":"blog/2024/07/04/customizing-swagger-ui-removing-the-django-login-button/#most-used-swagger-settings","title":"Most used swagger settings","text":"settings.py<pre><code>SWAGGER_SETTINGS = {\n    'DEFAULT_INFO': 'path.to.your_project.urls.api_info',\n    'SECURITY_DEFINITIONS': {\n        'Bearer': {\n            'type': 'apiKey',\n            'name': 'Authorization',\n            'in': 'header'\n        }\n    },\n    'USE_SESSION_AUTH': False,\n    'DOC_EXPANSION': 'none',\n    'OPERATIONS_SORTER': 'alpha',\n    'SHOW_REQUEST_HEADERS': True,\n    'PERSIST_AUTH': True,\n    'APIS_SORTER': 'alpha',\n    'VALIDATOR_URL': None,\n    'JSON_EDITOR': True,\n    'SUPPORTED_SUBMIT_METHODS': [\n        'get', 'post', 'put', 'delete', 'patch'\n    ],\n}\n</code></pre>","tags":["django","management"]},{"location":"blog/2024/07/04/customizing-swagger-ui-removing-the-django-login-button/#rest-framework-settings","title":"REST Framework Settings","text":"<p>Additionally, it's important to configure the Django REST framework settings to ensure proper authentication and permissions for your API:</p> <pre><code>REST_FRAMEWORK = {\n    'DEFAULT_AUTHENTICATION_CLASSES': (\n        'rest_framework_simplejwt.authentication.JWTAuthentication',\n    ),\n    'DEFAULT_PERMISSION_CLASSES': (\n        'rest_framework.permissions.IsAuthenticated',\n    ),\n}\n</code></pre> <p>The <code>DEFAULT_PERMISSION_CLASSES</code> setting with <code>IsAuthenticated</code> ensures that all API endpoints require user authentication by default, enhancing the security of your application by restricting access to authorized users only. This setting is essential for protecting sensitive data and functionality in your API.</p> Other Common Permission Classes <ul> <li>AllowAny: No restrictions, accessible to all users.</li> <li>IsAdminUser: Only accessible to users with admin status.</li> <li>IsAuthenticatedOrReadOnly: Allows authenticated users to perform any request, but anonymous users can only perform read-only requests (e.g., GET).</li> </ul> <p>By configuring these settings, you can ensure that your Swagger UI is both user-friendly and secure, providing a clear and interactive documentation experience for developers.</p>","tags":["django","management"]},{"location":"blog/2024/06/23/decorators-in-python/","title":"Decorators in python","text":"","tags":["django"]},{"location":"blog/2024/06/23/decorators-in-python/#decorators-in-python","title":"Decorators in python","text":"<p>A decorator is a function that takes a function and returns the decorated function.</p> <p>Before <code>class-based views</code>, decorators were the only way to change the behavior of <code>function-based views</code>. Being wrappers around a function, they cannot change the inner working of the view, and thus effectively treat them as black boxes.</p> <p>Confused?</p> <p>There is some syntactic sugar to help you. Use the annotation notation @, as shown in the following <code>login_required</code> decorator example:</p> <p>Tip</p> <pre><code>@login_required\ndef simple_view(request):\n    return HttpResponse()\n</code></pre> <p>The following code is exactly the same as the preceding:</p> <pre><code>def simple_view(request):\n    return HttpResponse()\n\nsimple_view = login_required(simple_view)\n</code></pre> <p>Since <code>login_required</code> wraps around the view, a wrapper function gets the control first. If the user was not logged-in, then it redirects to settings.LOGIN_URL. Otherwise, it executes <code>simple_view</code> as if it did not exist.</p> <p>Decorators are less flexible than mixins. However, they are simpler. You can use both decorators and mixins in Django. In fact, many mixins are implemented with decorators.</p> Built-in Decorators <p>Python library contains many built-in decorators as a shortcut of defining properties, class method, static methods, etc.</p> Decorator Description <code>@property</code> Declares a method as a property's setter or getter methods. <code>@classmethod</code> Declares a method as a class's method that can be called using the class name. <code>@staticmethod</code> Declares a method as a static method.","tags":["django"]},{"location":"blog/2024/06/23/decorators-in-python/#reference","title":"Reference","text":"<ul> <li>Django design patterns and best practices - second edition</li> <li>Decorators in Python</li> </ul>","tags":["django"]},{"location":"blog/2024/07/08/the-importance-of-defaults-in-environment-variables/","title":"The Importance of Defaults in Environment Variables","text":"","tags":["Python","Django"]},{"location":"blog/2024/07/08/the-importance-of-defaults-in-environment-variables/#the-importance-of-defaults-in-environment-variables","title":"The Importance of Defaults in Environment Variables","text":"<p>In Django settings or any configuration setup using environment variables, the <code>default</code> parameter provides a fallback value in case the environment variable is not set or is missing.</p> Managing Django Configurations: The Importance of Defaults in Environment Variables <p>Here\u2019s why using <code>default</code> is important:</p> <ol> <li> <p>Avoid Runtime Errors: If an environment variable is missing and you don\u2019t provide a default, it could cause your application to fail or raise an error when it tries to access a required setting. By providing a default value, you ensure that the application can still run even if the environment variable is not set.</p> </li> <li> <p>Graceful Degradation: Defaults allow your application to operate with sensible fallback values, which can be useful during development, testing, or in production environments where certain configurations might not be immediately available.</p> </li> <li> <p>Ease of Development: During development, you might not always have all environment variables set up. Defaults help in testing and development by allowing you to use a standard configuration without manually setting every environment variable.</p> </li> <li> <p>Simplicity and Maintainability: Defaults simplify the code and configuration management by reducing the need for extensive conditional checks to handle missing environment variables.</p> </li> </ol>","tags":["Python","Django"]},{"location":"blog/2024/07/08/the-importance-of-defaults-in-environment-variables/#example-usage","title":"Example Usage","text":"<p>Suppose you are configuring a database connection and the port number is not provided in the <code>.env</code> file:</p> <pre><code>DATABASES = {\n    'default': {\n        'ENGINE': 'django.db.backends.postgresql',\n        'NAME': env('DEV_DB_NAME', default='mydatabase'),\n        'USER': env('DEV_DB_USER', default='myuser'),\n        'PASSWORD': env('DEV_DB_PASSWORD', default='mypassword'),\n        'HOST': env('DEV_DB_HOST', default='127.0.0.1'),\n        'PORT': env.int('DEV_DB_PORT', default=5432),  # Default port for PostgreSQL\n    }\n}\n</code></pre> <p>In this example:</p> <ul> <li>If <code>DEV_DB_PORT</code> is not defined in the <code>.env</code> file, <code>env.int('DEV_DB_PORT', default=5432)</code> will use <code>5432</code> as the port number, which is the default port for PostgreSQL.</li> </ul>","tags":["Python","Django"]},{"location":"blog/2024/07/08/the-importance-of-defaults-in-environment-variables/#when-not-to-use-defaults","title":"When Not to Use Defaults","text":"<p>There are scenarios where you might not want to use defaults:</p> <ul> <li>Critical Configuration: For critical settings where missing or incorrect values can cause significant issues or security risks (e.g., API keys, database credentials), you might want to ensure they are explicitly set and not fall back to defaults.</li> <li>Strict Environments: In highly controlled environments (e.g., production), you might require all configurations to be explicitly defined to prevent accidental misconfigurations.</li> </ul> <p>In general, using defaults is a good practice for non-critical configurations to ensure robustness and flexibility in your application setup.</p>","tags":["Python","Django"]},{"location":"blog/2024/04/23/strengthening-your-django-applications-with-defensive-programming/","title":"Strengthening Your Django Applications with Defensive Programming","text":"","tags":["Python","Django"]},{"location":"blog/2024/04/23/strengthening-your-django-applications-with-defensive-programming/#strengthening-your-django-applications-with-defensive-programming","title":"Strengthening Your Django Applications with Defensive Programming","text":"<p>Defensive programming is a programming paradigm or approach aimed at writing code that anticipates and guards against potential errors or unexpected behaviors. </p> <p>The goal of defensive programming is to make software more robust, resilient, and less prone to failure by incorporating mechanisms to handle unforeseen circumstances.</p> <p>In simple terms, Defensive programming in Django is like wearing a helmet while biking. It's about preparing your code for unexpected bumps and ensuring it stays safe. </p> <p>Here are three simple examples of defensive programming in Django:</p> <ol> <li> <p>Input Validation:</p> <pre><code>from django import forms\nfrom django.core.validators import RegexValidator\n\nclass RegistrationForm(forms.Form):\n    username = forms.CharField(max_length=30, validators=[\n        RegexValidator(\n            regex='^[a-zA-Z0-9]*$',\n            message='Username must contain only letters and numbers.',\n            code='invalid_username'\n        )\n    ])\n</code></pre> </li> <li> <p>Error Handling:</p> <pre><code>from django.shortcuts import get_object_or_404\nfrom myapp.models import MyModel\n\ndef my_view(request, object_id):\n    obj = get_object_or_404(MyModel, id=object_id)\n    # If obj doesn't exist, get_object_or_404 raises Http404\n    return render(request, 'my_template.html', {'obj': obj})\n</code></pre> <p>By using <code>get_object_or_404</code>, Django will automatically raise a 404 error if the object with the specified ID doesn't exist, ensuring that your application gracefully handles this scenario.</p> </li> <li> <p>Preventing Security Issues:</p> <pre><code>&lt;!-- Template --&gt;\n&lt;div&gt;{{ user_input|safe }}&lt;/div&gt;\n</code></pre> <p>By using the <code>|safe</code> filter, Django knows that you've already sanitized <code>user_input</code>, and it won't escape any HTML tags within it, thus preventing Cross-Site Scripting (XSS) attacks.</p> </li> </ol>","tags":["Python","Django"]},{"location":"blog/2024/04/27/difference-between-templateview-listview-and-view/","title":"Difference between TemplateView, ListView, and View","text":"","tags":["Django"]},{"location":"blog/2024/04/27/difference-between-templateview-listview-and-view/#difference-between-templateview-listview-and-view","title":"Difference between TemplateView, ListView, and View","text":"<p>In Django, <code>TemplateView</code>, <code>ListView</code>, and <code>View</code> are all class-based views used to handle HTTP requests. Here's a brief overview of when to use each:</p> <ol> <li> <p>TemplateView:</p> <ul> <li>Use <code>TemplateView</code> when you simply want to display a template without dealing with database queries or lists of objects.</li> <li>It's useful for static pages or pages that require minimal dynamic content.</li> <li>For example, displaying an \"About Us\" page or a contact form.</li> </ul> <p>Tip</p> Example<pre><code>from django.views.generic import TemplateView\n\nclass IndexView(TemplateView):\n    template_name = 'index.html'\n</code></pre> <p>In this example, <code>IndexView</code> renders the <code>index.html</code> template without any specific queryset or database interaction.</p> </li> <li> <p>ListView:</p> <ul> <li>Use <code>ListView</code> when you want to display a list of objects from the database.</li> <li>It automatically generates a queryset for you and passes it to the template.</li> <li>It's useful for displaying lists of items, such as blog posts, products, or user profiles.</li> <li>You need to specify the <code>model</code> attribute to tell Django which model to use for the queryset.</li> </ul> <p>Tip</p> Example<pre><code>from django.views.generic import ListView\nfrom .models import YourModel\n\nclass YourModelListView(ListView):\n    model = YourModel\n    template_name = 'yourmodel_list.html'\n    context_object_name = 'yourmodel_list'\n</code></pre> <p>In this example, <code>YourModelListView</code> displays a list of objects from the <code>YourModel</code> model. It automatically generates a queryset for <code>YourModel</code> and passes it to the template named <code>yourmodel_list.html</code>. The context_object_name attribute specifies the name of the context variable to use in the template.</p> </li> <li> <p>View:</p> <ul> <li><code>View</code> is the most basic class-based view in Django.</li> <li>You should use it when you need to handle more complex logic or customize the behavior of your view.</li> <li>Unlike <code>TemplateView</code> and <code>ListView</code>, <code>View</code> doesn't provide any built-in methods for rendering templates or working with querysets.</li> <li>You need to implement methods like <code>get()</code>, <code>post()</code>, <code>put()</code>, etc., to handle different types of HTTP requests.</li> </ul> <p>Tip</p> ExampleTheory <pre><code>from django.views.generic import View\nfrom django.http import HttpResponse\n\nclass MyView(View):\n    def get(self, request, *args, **kwargs):\n        # Your logic here\n        return HttpResponse(\"This is a GET response\")\n\n    def post(self, request, *args, **kwargs):\n        # Your logic here\n        return HttpResponse(\"This is a POST response\")\n</code></pre> <p>Now, regarding what this variable represents, it's always a queryset of objects. Whether it fetches <code>.objects.all()</code> or <code>.objects.first()</code> depends on the behavior of the ListView.</p> <p>By default, ListView fetches all objects in the database table associated with the model specified in the model attribute. So, <code>context_object_name</code> represents all the objects returned by <code>.objects.all()</code> for that model.</p> <p>If you want to fetch only the first object, you would need to customize the <code>get_queryset()</code> method in your ListView subclass like this:</p> <pre><code>from django.views.generic import ListView\nfrom .models import YourModel\n\nclass YourModelListView(ListView):\n    model = YourModel\n    template_name = 'yourmodel_list.html'\n    context_object_name = 'yourmodel_list'\n\n    def get_queryset(self):\n        return YourModel.objects.first()\n</code></pre> <p>This way, <code>context_object_name</code> would represent the first object returned by <code>.objects.first()</code> instead of all objects.</p> <p>In this example, <code>MyView</code> is a basic view that handles both GET and POST requests. You implement the <code>get()</code> and <code>post()</code> methods to define the logic for each type of request. Here, it simply returns a basic HTTP response for demonstration purposes. You can replace the response with whatever logic you need for your application.</p> </li> </ol> <p>In your case, if you're simply rendering the <code>index.html</code> template without any specific queryset or database interaction, <code>TemplateView</code> is appropriate. However, if you need to display a list of objects, you should consider using <code>ListView</code> and specifying the appropriate model. If you need more complex logic or customization, you might use a <code>View</code> subclass instead.</p>","tags":["Django"]},{"location":"blog/2024/05/09/django-model-fields-with-textchoices/","title":"Django Model Fields with TextChoices","text":"","tags":["Python","Django"]},{"location":"blog/2024/05/09/django-model-fields-with-textchoices/#django-model-fields-with-textchoices","title":"Django Model Fields with TextChoices","text":"<p>Before Django <code>3.0</code>, defining choices for model fields typically involved using tuples of tuples, which could be cumbersome and error-prone. With the introduction of TextChoices, Django provides a more elegant and Pythonic way to define choices using class-based syntax.</p> <pre><code>from django.db import models\nfrom django.utils.translation import gettext_lazy as _\n\nclass MyModel(models.Model):\n    class Status(models.TextChoices):\n        DRAFT = 'draft', _('Draft')\n        PUBLISHED = 'published', _('Published')\n        ARCHIVED = 'archived', _('Archived')\n\n    status = models.CharField(\n        max_length=20,\n        choices=Status.choices,\n        default=Status.DRAFT\n    )\n</code></pre> <p>In this example:</p> <ul> <li>We define a Status class as a subclass of TextChoices.</li> <li>Each choice is defined as a class attribute, with the first value representing the database representation and the second value providing a human-readable name.</li> <li>The status field of the MyModel model uses Status.choices for its choices.</li> </ul>","tags":["Python","Django"]},{"location":"blog/2024/05/09/django-model-fields-with-textchoices/#benefits-of-textchoices","title":"Benefits of TextChoices:","text":"<ol> <li>Improved Readability: Using TextChoices enhances the readability of your code by providing a clear and concise way to define choices within your model definitions.</li> <li>Enhanced Maintenance: With TextChoices, managing and updating the list of choices becomes more straightforward, reducing the chances of errors and inconsistencies.</li> <li>Autocomplete Support: Modern code editors often provide autocomplete support for class-based definitions, making it easier to work with TextChoices compared to tuples of tuples.</li> <li>Integration with Localization: TextChoices seamlessly integrates with Django's internationalization (i18n) and localization (l10n) features, allowing for easy translation of choice labels.</li> </ol>","tags":["Python","Django"]},{"location":"blog/2024/05/09/django-model-fields-with-textchoices/#conclusion","title":"Conclusion:","text":"<p>In conclusion, TextChoices is a valuable addition to Django's feature set, offering a more elegant and Pythonic way to define choices for model fields. By leveraging class-based syntax, TextChoices improves the readability, maintainability, and usability of Django models, making them easier to understand and maintain.</p> <p>Whether you're working on a small project or a large-scale application, consider incorporating TextChoices into your Django models to streamline your development workflow and enhance the quality of your code.</p>","tags":["Python","Django"]},{"location":"blog/2024/05/09/django-model-fields-with-textchoices/#life-before-textchoices","title":"Life Before <code>TextChoices</code>","text":"","tags":["Python","Django"]},{"location":"blog/2024/05/09/django-model-fields-with-textchoices/#1-tuples-of-tuples-old-style","title":"1. Tuples of Tuples (Old Style):","text":"<ul> <li>This is the traditional way of defining choices in Django.</li> <li>Choices are defined as tuples of tuples, where each inner tuple contains the value stored in the database and its human-readable representation.</li> </ul> <pre><code>STATUS_CHOICES = (\n    ('draft', 'Draft'),\n    ('published', 'Published'),\n    ('archived', 'Archived'),\n)\n</code></pre> <p>Use Case:</p> <p>This approach is suitable for simple cases where the list of choices is small and does not change frequently.</p>","tags":["Python","Django"]},{"location":"blog/2024/05/09/django-model-fields-with-textchoices/#2-namedtuples","title":"2. NamedTuples:","text":"<ul> <li>NamedTuples provide a more structured approach compared to tuples of tuples.</li> <li>Choices are defined using NamedTuples, which allows for better readability and maintainability.</li> </ul> <pre><code>from collections import namedtuple\n\nStatus = namedtuple('Status', ['value', 'display_name'])\nSTATUS_CHOICES = [\n    Status('draft', 'Draft'),\n    Status('published', 'Published'),\n    Status('archived', 'Archived'),\n]\n</code></pre> <p>Use Case:</p> <p>NamedTuples are useful when you want a more organized and maintainable way to define choices compared to tuples of tuples.</p>","tags":["Python","Django"]},{"location":"blog/2024/05/09/django-model-fields-with-textchoices/#3-class-based-choices-textchoices","title":"3. Class-Based Choices (TextChoices):","text":"<ul> <li>Introduced in Django 3.0, TextChoices provides a modern and Pythonic way to define choices using class-based syntax.</li> <li>Choices are defined as class attributes within a subclass of TextChoices.</li> </ul> <pre><code>from django.db import models\nfrom django.utils.translation import gettext_lazy as _\n\nclass Status(models.TextChoices):\n    DRAFT = 'draft', _('Draft')\n    PUBLISHED = 'published', _('Published')\n    ARCHIVED = 'archived', _('Archived')\n</code></pre> <p>Use Case:</p> <p>TextChoices is recommended for new projects or when you want to refactor existing code to improve readability and maintainability. It offers benefits such as autocomplete support and integration with localization.</p>","tags":["Python","Django"]},{"location":"blog/2024/05/09/django-model-fields-with-textchoices/#4-dynamic-choices","title":"4. Dynamic Choices:","text":"<ul> <li>Sometimes, you may need to dynamically generate choices based on certain conditions.</li> <li>Choices can be generated dynamically using a function or by querying a database.</li> </ul> <pre><code>def get_status_choices():\n    # Logic to generate choices dynamically\n    return [('draft', 'Draft'), ('published', 'Published')]\n\nclass MyModel(models.Model):\n    status = models.CharField(max_length=20, choices=get_status_choices)\n</code></pre> <p>Use Case:</p> <p>Dynamic choices are suitable when the list of choices depends on runtime conditions or needs to be fetched from external sources like a database.</p> <p>When choosing the appropriate method for defining choices, consider factors such as readability, maintainability, flexibility, and the specific requirements of your project. For new projects, TextChoices is recommended for its modern syntax and additional features, but the other methods still have their place depending on the complexity and context of your application.</p>","tags":["Python","Django"]},{"location":"blog/2024/07/02/django-allauth-for-web-apps---dj-rest-auth-for-api/","title":"django-allauth for web apps &amp; dj-rest-auth for API","text":"","tags":["django","drf"]},{"location":"blog/2024/07/02/django-allauth-for-web-apps---dj-rest-auth-for-api/#django-allauth-for-web-apps-dj-rest-auth-for-api","title":"<code>django-allauth</code> for web apps &amp;  <code>dj-rest-auth</code> for API","text":"<p><code>dj-rest-auth</code> and <code>django-allauth</code> are related but serve different purposes in a Django project, particularly when it comes to user authentication and account management:</p> Installation Overviewdjango-allauthdj-rest-auth <ol> <li> <p>django-allauth:</p> <ul> <li>Purpose: django-allauth is a comprehensive authentication solution for Django projects. It provides a set of views, forms, and templates to handle user authentication, registration, password management, social account authentication (OAuth), and email confirmation.</li> <li>Features: Supports various authentication methods (username, email, social accounts), email verification, password management, and more.</li> <li>Integration: It integrates seamlessly with Django's authentication system and provides a customizable set of templates and views.</li> </ul> </li> <li> <p>dj-rest-auth:</p> <ul> <li>Purpose: dj-rest-auth is an extension of Django REST Framework (DRF) that provides RESTful endpoints for authentication. It includes views and serializers to handle login, logout, registration, password reset, and user details.</li> <li>Features: Specifically designed for RESTful APIs, it supports token-based authentication (JWT, Token), social authentication using Django-allauth's social accounts, and integrates well with DRF serializers and views.</li> <li>Integration: It can work alongside django-allauth to provide API endpoints for user authentication and registration.</li> </ul> </li> <li> <p>djoser</p> <ul> <li>Purpose: djoser is a REST implementation of Django authentication system. It provides API endpoints for authentication and user management, aiming to be flexible and customizable.</li> <li>Features: Offers endpoints like <code>/token/</code> (for token-based authentication), <code>/token/refresh/</code>, <code>/user/</code> (for user details), <code>/user/create/</code>, <code>/user/delete/</code>, and more.</li> <li>Integration: Designed to integrate easily with existing Django projects and allows for extensive customization.</li> </ul> </li> </ol> <p>Choosing Between dj-rest-auth and djoser</p> <p>Use dj-rest-auth if:</p> <ul> <li>You need a quick setup of authentication endpoints with token-based authentication.</li> <li>Integration with django-allauth for social authentication is desired.</li> </ul> <p>Use djoser if:</p> <ul> <li>You prefer a more flexible and customizable solution for authentication and user management endpoints.</li> <li>You want more control over the implementation details of authentication views and serializers.</li> </ul> <p>First, install the python package. If you do not need any of the social account related functionality, install using:</p> <pre><code>pip install django-allauth\n</code></pre> <p>Otherwise, install using:</p> <pre><code>pip install \"django-allauth[socialaccount]\"\n</code></pre> <p>Then, assuming you have a Django project up and running, add the following to the <code>settings.py</code> of your project:</p> <pre><code># Specify the context processors as follows:\nTEMPLATES = [\n  {\n    'BACKEND': 'django.template.backends.django.DjangoTemplates',\n    'DIRS': [],\n    'APP_DIRS': True,\n    'OPTIONS': {\n      'context_processors': [\n        # Already defined Django-related contexts here\n\n        # `allauth` needs this from django\n        'django.template.context_processors.request',\n      ],\n    },\n  },\n]\n\nAUTHENTICATION_BACKENDS = [\n  ...\n  # Needed to login by username in Django admin, regardless of `allauth`\n  'django.contrib.auth.backends.ModelBackend',\n\n  # `allauth` specific authentication methods, such as login by email\n  'allauth.account.auth_backends.AuthenticationBackend',\n  ...\n]\n\nINSTALLED_APPS = [\n  ...\n  # The following apps are required:\n  'django.contrib.auth',\n  'django.contrib.messages',\n\n  'allauth',\n  'allauth.account',\n]\n\nMIDDLEWARE = (\n  ...\n  # Add the account middleware:\n  \"allauth.account.middleware.AccountMiddleware\",\n)\n\n# Provider specific settings\nSOCIALACCOUNT_PROVIDERS = {\n  'google': {\n    # For each OAuth based provider, either add a ``SocialApp``\n    # (``socialaccount`` app) containing the required client\n    # credentials, or list them here:\n    'APP': {\n      'client_id': '123',\n      'secret': '456',\n      'key': ''\n    }\n  }\n}\n</code></pre> <p>Additionally, add this to your project <code>urls.py</code>:</p> <pre><code>urlpatterns = [\n  ...\n  path('accounts/', include('allauth.urls')),\n  ...\n]\n</code></pre> <p>Note that you do not necessarily need the URLs provided by <code>django.contrib.auth.urls</code>. Instead of the URLs <code>login</code>, <code>logout</code>, and <code>password_change</code> (among others), you can use the URLs provided by allauth: <code>account_login</code>, <code>account_logout</code>, <code>account_set_password</code>\u2026</p> <p>Post-Installation</p> <pre><code>python manage.py migrate\n</code></pre> <ul> <li>for more info</li> </ul> <ol> <li> <p>Install package:</p> <pre><code>pip install dj-rest-auth\n</code></pre> </li> <li> <p>Add <code>dj_rest_auth</code> app to <code>INSTALLED_APPS</code> in your django <code>settings.py</code>:</p> <pre><code>INSTALLED_APPS = (\n  ...,\n  'rest_framework',\n  'rest_framework.authtoken',\n  ...,\n  'dj_rest_auth'\n)\n</code></pre> </li> </ol> <p>This project depends on <code>django-rest-framework</code> library, so install it if you haven\u2019t done yet. Make sure also you have installed <code>rest_framework</code> and <code>rest_framework.authtoken</code> apps</p> <ol> <li> <p>Add dj_rest_auth urls:</p> <pre><code>urlpatterns = [\n  ...,\n  path('dj-rest-auth/', include('dj_rest_auth.urls'))\n]\n</code></pre> </li> <li> <p>Migrate your database</p> <pre><code>python manage.py migrate\n</code></pre> </li> </ol> Registration (optional) <ol> <li>If you want to enable standard registration process you will need to install django-allauth by using <code>pip install 'dj-rest-auth[with_social]'</code>.</li> <li>Add <code>django.contrib.sites</code>, <code>allauth</code>, <code>allauth.account</code>, <code>allauth.socialaccount</code> and <code>dj_rest_auth.registration</code> apps to INSTALLED_APPS in your django settings.py:</li> <li>Add <code>SITE_ID = 1</code> to your django <code>settings.py</code></li> </ol> <pre><code>INSTALLED_APPS = (\n  ...,\n  'django.contrib.sites',\n  'allauth',\n  'allauth.account',\n  'allauth.socialaccount',\n  'dj_rest_auth.registration',\n)\n\nSITE_ID = 1\n</code></pre> <ol> <li>Add <code>dj_rest_auth.registration</code> urls:</li> </ol> <pre><code>urlpatterns = [\n  ...,\n  path('dj-rest-auth/', include('dj_rest_auth.urls')),\n  path('dj-rest-auth/registration/', include('dj_rest_auth.registration.urls'))\n]\n</code></pre> Social Authentication (optional) <p>Using <code>django-allauth</code>, <code>dj-rest-auth</code> provides helpful class for creating social media authentication view.</p> <p>Points 1 and 2 are related to <code>django-allauth</code> configuration, so if you have already configured social authentication, then please go to step 3. See <code>django-allauth</code> documentation for more details.</p> <ol> <li>Add <code>allauth.socialaccount</code> and <code>allauth.socialaccount.providers.facebook</code> or <code>allauth.socialaccount.providers.twitter</code> apps to INSTALLED_APPS in your django <code>settings.py</code>:</li> </ol> <pre><code>INSTALLED_APPS = (\n  ...,\n  'rest_framework',\n  'rest_framework.authtoken',\n  'dj_rest_auth'\n  ...,\n  'django.contrib.sites',\n  'allauth',\n  'allauth.account',\n  'dj_rest_auth.registration',\n  ...,\n  'allauth.socialaccount',\n  'allauth.socialaccount.providers.facebook',\n  'allauth.socialaccount.providers.twitter',\n\n)\n</code></pre> <ul> <li>social authentication</li> </ul>","tags":["django","drf"]},{"location":"blog/2024/07/02/django-allauth-for-web-apps---dj-rest-auth-for-api/#using-both-vs-using-one","title":"Using Both vs. Using One","text":"","tags":["django","drf"]},{"location":"blog/2024/07/02/django-allauth-for-web-apps---dj-rest-auth-for-api/#using-both-django-allauth-and-dj-rest-auth","title":"Using Both (django-allauth and dj-rest-auth):","text":"<p>You can use both <code>django-allauth</code> and <code>dj-rest-auth</code> together in a project:</p> <ul> <li>User Registration: Use <code>django-allauth</code> for web-based user registration and email confirmation.</li> <li>API Authentication: Use <code>dj-rest-auth</code> for REST API endpoints to handle token-based authentication, login, and user details retrieval.</li> </ul>","tags":["django","drf"]},{"location":"blog/2024/07/02/django-allauth-for-web-apps---dj-rest-auth-for-api/#using-only-one","title":"Using Only One:","text":"<p>Depending on your project requirements, you can choose to use only one of them:</p> <ul> <li>If you're building a web application: You might primarily use django-allauth for its comprehensive user authentication and social authentication features.</li> <li>If you're building a RESTful API: You might choose to use dj-rest-auth for its tailored API endpoints and token-based authentication support.</li> </ul>","tags":["django","drf"]},{"location":"blog/2024/07/02/django-allauth-for-web-apps---dj-rest-auth-for-api/#considerations","title":"Considerations","text":"<ul> <li>Integration: <code>dj-rest-auth</code> can leverage django-allauth's social authentication providers (django-allauth's social accounts) for OAuth-based authentication.</li> <li>Customization: Both packages are highly customizable. You can override views, serializers, and templates to fit your project's specific requirements.</li> <li>Dependency: <code>dj-rest-auth</code> does not require <code>django-allauth</code> to function, but they complement each other well when used together, especially in projects that require both web-based authentication and API-based authentication.</li> </ul>","tags":["django","drf"]},{"location":"blog/2024/07/02/django-allauth-for-web-apps---dj-rest-auth-for-api/#conclusion","title":"Conclusion","text":"<p>In summary, <code>dj-rest-auth</code> and <code>django-allauth</code> can be used together or separately depending on your project's needs. If you're building a complex application that requires both web-based authentication and REST API endpoints, using both can provide a comprehensive solution. However, if your focus is primarily on APIs, dj-rest-auth alone may suffice for handling token-based authentication and user management. Choose the approach that best fits your project's architecture and requirements.</p>","tags":["django","drf"]},{"location":"blog/2024/07/02/django-allauth-for-web-apps---dj-rest-auth-for-api/#reference","title":"Reference","text":"<ul> <li>django-allauth :official</li> <li>dj-rest-auth :official</li> <li>dj-rest-auth :official github</li> <li>djoser</li> <li> <p>djoser: github</p> </li> <li> <p>Django REST Framework Authentication</p> </li> <li>Django Rest Framework Authentication with Dj-Rest-Auth </li> <li>Django Part 3 - User authentication with dj-rest-auth and allauth </li> </ul>","tags":["django","drf"]},{"location":"blog/2024/07/01/django-and-djangorestframework-views/","title":"Django and djangorestframework views","text":"","tags":["django","drf"]},{"location":"blog/2024/07/01/django-and-djangorestframework-views/#django-and-djangorestframework-views","title":"Django and djangorestframework <code>views</code>","text":"<p>Django views are versatile for rendering web pages, while DRF generic views streamline API development with standardized CRUD operations and serialization support.</p> <p>Example</p> Class-Based API ViewsGeneric API ViewsCombining <p>These are Python classes that provide more structure and reusability.</p> <p>from rest_framework.views import APIView</p> <pre><code>from rest_framework.views import APIView\nfrom rest_framework.response import Response\nfrom rest_framework import status\nfrom .models import Book\nfrom .serializers import BookSerializer\n\nclass BookList(APIView):\n    def get(self, request):\n        books = Book.objects.all()\n        serializer = BookSerializer(books, many=True)\n        return Response(serializer.data)\n\n    def post(self, request):\n        serializer = BookSerializer(data=request.data)\n        if serializer.is_valid():\n            serializer.save()\n            return Response(serializer.data, status=status.HTTP_201_CREATED)\n        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)\n</code></pre> <p>Generic API views abstract common patterns to make view development easier and faster. DRF provides a set of built-in generic views for common tasks, such as listing, creating, retrieving, updating, and deleting objects.</p> <p>from rest_framework.generics import ListAPIView</p> ListAPIViewCreateAPIViewRetrieveAPIViewUpdateAPIViewDestroyAPIView <ul> <li> <p>Used to retrieve a list of objects.</p> <pre><code>from rest_framework.generics import ListAPIView\nfrom .models import Book\nfrom .serializers import BookSerializer\n\nclass BookListView(ListAPIView):\n    queryset = Book.objects.all()\n    serializer_class = BookSerializer\n</code></pre> </li> </ul> <ul> <li> <p>Used to create a new object.</p> <pre><code>from rest_framework.generics import CreateAPIView\nfrom .models import Book\nfrom .serializers import BookSerializer\n\nclass BookCreateView(CreateAPIView):\n    queryset = Book.objects.all()\n    serializer_class = BookSerializer\n</code></pre> </li> </ul> <ul> <li> <p>Used to retrieve a single object.</p> <pre><code>from rest_framework.generics import RetrieveAPIView\nfrom .models import Book\nfrom .serializers import BookSerializer\n\nclass BookDetailView(RetrieveAPIView):\n    queryset = Book.objects.all()\n    serializer_class = BookSerializer\n</code></pre> </li> </ul> <ul> <li> <p>Used to update an existing object.</p> <pre><code>from rest_framework.generics import UpdateAPIView\nfrom .models import Book\nfrom .serializers import BookSerializer\n\nclass BookUpdateView(UpdateAPIView):\n    queryset = Book.objects.all()\n    serializer_class = BookSerializer\n</code></pre> </li> </ul> <ul> <li> <p>Used to delete an existing object.</p> <pre><code>from rest_framework.generics import DestroyAPIView\nfrom .models import Book\nfrom .serializers import BookSerializer\n\nclass BookDeleteView(DestroyAPIView):\n    queryset = Book.objects.all()\n    serializer_class = BookSerializer\n</code></pre> </li> </ul> <p>Combining Multiple Generic API Views</p> <p>For more complex workflows, you can combine multiple generic views to handle different actions.</p> Combining List and Create Views<pre><code>from django.urls import path\nfrom .views import BookListView, BookCreateView\n\nurlpatterns = [\n    path('books/', BookListView.as_view(), name='book-list'),\n    path('books/new/', BookCreateView.as_view(), name='book-create'),\n]\n</code></pre>","tags":["django","drf"]},{"location":"blog/2024/07/01/django-and-djangorestframework-views/#using-viewsets","title":"Using ViewSets","text":"<p>Viewsets combine the logic for multiple views into a single class. They are a more concise way to handle standard create, retrieve, update, and delete actions.</p> <pre><code>from rest_framework import viewsets\nfrom .models import Book\nfrom .serializers import BookSerializer\n\nclass BookViewSet(viewsets.ModelViewSet):\n    queryset = Book.objects.all()\n    serializer_class = BookSerializer\n</code></pre> Router Configuration<pre><code>from django.urls import path, include\nfrom rest_framework.routers import DefaultRouter\nfrom .views import BookViewSet\n\nrouter = DefaultRouter()\nrouter.register(r'books', BookViewSet)\n\nurlpatterns = [\n    path('', include(router.urls)),\n]\n</code></pre>","tags":["django","drf"]},{"location":"blog/2024/07/01/django-and-djangorestframework-views/#django-generic-views-and-generic-api-views","title":"Django Generic Views and Generic API Views","text":"<p>Django Generic Views</p> View Name Description Example Usage Import ListView Displays a list of objects. <code>class BookListView(ListView)</code> <code>from django.views.generic import ListView</code> DetailView Displays a single object. <code>class BookDetailView(DetailView)</code> <code>from django.views.generic import DetailView</code> CreateView Displays a form for creating a new object and handles form submission. <code>class BookCreateView(CreateView)</code> <code>from django.views.generic import CreateView</code> UpdateView Displays a form for updating an existing object and handles form submission. <code>class BookUpdateView(UpdateView)</code> <code>from django.views.generic import UpdateView</code> DeleteView Displays a confirmation page and deletes an existing object. <code>class BookDeleteView(DeleteView)</code> <code>from django.views.generic import DeleteView</code> TemplateView Renders a template. <code>class MyTemplateView(TemplateView)</code> <code>from django.views.generic import TemplateView</code> RedirectView Redirects to a given URL. <code>class MyRedirectView(RedirectView)</code> <code>from django.views.generic import RedirectView</code> FormView Displays a form and handles form submission. <code>class MyFormView(FormView)</code> <code>from django.views.generic import FormView</code> ArchiveIndexView Displays an archive index of date-based items. <code>class MyArchiveIndexView(ArchiveIndexView)</code> <code>from django.views.generic.dates import ArchiveIndexView</code> YearArchiveView Displays an archive of items for a specific year. <code>class MyYearArchiveView(YearArchiveView)</code> <code>from django.views.generic.dates import YearArchiveView</code> MonthArchiveView Displays an archive of items for a specific month. <code>class MyMonthArchiveView(MonthArchiveView)</code> <code>from django.views.generic.dates import MonthArchiveView</code> WeekArchiveView Displays an archive of items for a specific week. <code>class MyWeekArchiveView(WeekArchiveView)</code> <code>from django.views.generic.dates import WeekArchiveView</code> DayArchiveView Displays an archive of items for a specific day. <code>class MyDayArchiveView(DayArchiveView)</code> <code>from django.views.generic.dates import DayArchiveView</code> TodayArchiveView Displays an archive of items for today. <code>class MyTodayArchiveView(TodayArchiveView)</code> <code>from django.views.generic.dates import TodayArchiveView</code> DateDetailView Displays a single object for a specific date. <code>class MyDateDetailView(DateDetailView)</code> <code>from django.views.generic.dates import DateDetailView</code> <p>DRF Generic API Views</p> View Name Description Example Usage Import ListAPIView Used for read-only endpoints to represent a collection of model instances. <code>class BookListView(ListAPIView)</code> <code>from rest_framework.generics import ListAPIView</code> CreateAPIView Used for create-only endpoints. <code>class BookCreateView(CreateAPIView)</code> <code>from rest_framework.generics import CreateAPIView</code> RetrieveAPIView Used for read-only endpoints to represent a single model instance. <code>class BookDetailView(RetrieveAPIView)</code> <code>from rest_framework.generics import RetrieveAPIView</code> UpdateAPIView Used for update-only endpoints for a single model instance. <code>class BookUpdateView(UpdateAPIView)</code> <code>from rest_framework.generics import UpdateAPIView</code> DestroyAPIView Used for delete-only endpoints for a single model instance. <code>class BookDeleteView(DestroyAPIView)</code> <code>from rest_framework.generics import DestroyAPIView</code> ListCreateAPIView Used for read-write endpoints to represent a collection of model instances. <code>class BookListCreateView(ListCreateAPIView)</code> <code>from rest_framework.generics import ListCreateAPIView</code> RetrieveUpdateAPIView Used for read or update endpoints to represent a single model instance. <code>class BookRetrieveUpdateView(RetrieveUpdateAPIView)</code> <code>from rest_framework.generics import RetrieveUpdateAPIView</code> RetrieveDestroyAPIView Used for read or delete endpoints to represent a single model instance. <code>class BookRetrieveDestroyView(RetrieveDestroyAPIView)</code> <code>from rest_framework.generics import RetrieveDestroyAPIView</code> RetrieveUpdateDestroyAPIView Used for read, update or delete endpoints to represent a single model instance. <code>class BookRetrieveUpdateDestroyView(RetrieveUpdateDestroyAPIView)</code> <code>from rest_framework.generics import RetrieveUpdateDestroyAPIView</code>","tags":["django","drf"]},{"location":"blog/2024/07/01/django-and-djangorestframework-views/#reference","title":"Reference","text":"","tags":["django","drf"]},{"location":"blog/2024/01/05/viewset-vs-apiview/","title":"Viewset vs APIView","text":"","tags":["Drf"]},{"location":"blog/2024/01/05/viewset-vs-apiview/#viewset-vs-apiview","title":"Viewset vs APIView","text":"<p>The differences between APIView and Viewset vary depending on the particular needs and requirements. Therefore, we can provide a code-based example to decide which method should be used:</p> <p></p> <p>Now let\u2019s do the same operations using Viewset:</p> <pre><code>class BlogPostViewSet(viewsets.ModelViewSet):\n    queryset = BlogPost.objects.all()\n    serializer_class = BlogPostSerializer\n</code></pre> <p>At this point, we wrote less code using Viewset compared to the previous example created with APIView. Viewset contains several predefined methods that can be used for multiple operations, making model operations easier. Also, for customized operations, Viewset can be easily extended with extra methods provided by the Django Rest Framework.</p> <p>In addition, routers combined with Viewset can automatically match URLs and associate them with the view class, allowing us to easily perform URL routing. This is especially useful in large-scale projects or projects that work with many models.</p> <pre><code>router = routers.DefaultRouter()\nrouter.register(r'blog-posts', BlogPostViewSet)\n\nurlpatterns = [\n    path('', include(router.urls)),\n]\n</code></pre> <p>In this example, the router element registers our Viewset class and automatically generates the URLs required for the predefined CRUD operations. Thus, you can perform basic CRUD operations by sending GET, POST, PUT, PATCH and DELETE requests to the URL \u201c/blog-posts/\u201d.</p> <p>Conclusion</p> <ul> <li><code>APIView</code> is derived from Django\u2019s base View class, while <code>Viewset</code> is derived from a special <code>ViewSet class</code> of the Django Rest Framework.</li> </ul>","tags":["Drf"]},{"location":"blog/2024/01/05/viewset-vs-apiview/#reference","title":"Reference","text":"<ul> <li>Django APIView vs Viewsets Which one to Choose?</li> <li>APIView vs Viewsets</li> <li>Views vs Generic Views vs ViewSets</li> <li>GenericAPIView and Mixins</li> <li>More views and viewsets: offical docs</li> <li>Generic, Functional Based and Class Based Views in Django REST Framework</li> <li> <p>Difference between views and viewsets</p> </li> <li> <p>Customizing token claims</p> </li> <li> <p>JWT Decoder</p> </li> <li> <p>Viewsets vs Generic Views vs APIView vs Function Based Views: reddit</p> </li> <li>Comprehensive guide to GenericAPIViews in Django REST Framework</li> <li>Django REST Framework: Generics or ModelViewSets?: stackoverflow</li> </ul>","tags":["Drf"]},{"location":"blog/2024/05/07/creating-a-blog-model-in-django/","title":"Creating a blog model in django","text":""},{"location":"blog/2024/05/07/creating-a-blog-model-in-django/#creating-a-blog-model-in-django","title":"Creating a blog model in django","text":"<p>A Django model is a source of information and behaviors of your data. It consists of a Python class that subclasses django.db.models.Model. Each model maps to a single database table, where each attribute of the class represents a database field.</p>"},{"location":"blog/2024/05/07/creating-a-blog-model-in-django/#creating-the-post-model","title":"Creating the Post model","text":"models<pre><code>from django.db import models\nfrom django.utils import timezone\n\nclass Post(models.Model):\n    title = models.CharField(max_length=250)\n    slug = models.SlugField(max_length=250)\n    body = models.TextField()\n    publish = models.DateTimeField(default=timezone.now)\n    created = models.DateTimeField(auto_now_add=True)\n    updated = models.DateTimeField(auto_now=True)\n\ndef__str__(self):\n    return self.title\n</code></pre>"},{"location":"blog/2024/05/07/creating-a-blog-model-in-django/#defining-a-default-sort-order","title":"Defining a default sort order","text":"<p>Blog posts are usually displayed in reverse chronological order (from newest to oldest). We will define a default ordering for our model. The default order will apply when obtaining objects from the database when no order is specified in the query.</p> models.py<pre><code>from django.db import models\nfrom django.utils import timezone\n\nclass Post(models.Model):\n    title = models.CharField(max_length=250)\n    slug = models.SlugField(max_length=250)\n    body = models.TextField()\n    publish = models.DateTimeField(default=timezone.now)\n    created = models.DateTimeField(auto_now_add=True)\n    updated = models.DateTimeField(auto_now=True)\n\nclass Meta:\n    ordering = ['-publish']\n\ndef__str__(self):\n    return self.title\n</code></pre> <p>We have added a Meta class inside the model. This class defines metadata for the model. We use the ordering attribute to tell Django that it should sort results by the publish field. This ordering will apply by default for database queries when no specific order is provided in the query. We indicate descending order by using a hyphen before the field name, -publish. Posts will be returned in reverse chronological order by default.</p>"},{"location":"blog/2024/05/07/creating-a-blog-model-in-django/#adding-a-database-index","title":"Adding a database index","text":"models.py<pre><code>from django.db import models\nfrom django.utils import timezone\n\nclass Post(models.Model):\n    title = models.CharField(max_length=250)\n    slug = models.SlugField(max_length=250)\n    body = models.TextField()\n    publish = models.DateTimeField(default=timezone.now)\n    created = models.DateTimeField(auto_now_add=True)\n    updated = models.DateTimeField(auto_now=True)\n\nclass Meta:\n    ordering = ['-publish']\n    indexes = [\n        models.Index(fields=['-publish']),\n    ]\n\ndef__str__(self):\n    return self.title\n</code></pre> <p>Danger</p> <p>Index ordering is not supported on MySQL. If you use MySQL for the database, a descending index will be created as a normal index.</p>"},{"location":"blog/2024/05/07/creating-a-blog-model-in-django/#activating-the-application","title":"Activating the application","text":"<pre><code>INSTALLED_APPS = [\n    'django.contrib.admin',\n    'django.contrib.auth',\n    'django.contrib.contenttypes',\n    'django.contrib.sessions',\n    'django.contrib.messages',\n    'django.contrib.staticfiles',\n    'blog.apps.BlogConfig',\n]\n</code></pre> <p>The BlogConfig class is the application configuration. Now Django knows that the application is active for this project and will be able to load the application models.</p>"},{"location":"blog/2024/05/07/creating-a-blog-model-in-django/#adding-a-status-field","title":"Adding a status field","text":"<p>A common functionality for blogs is to save posts as a draft until ready for publication. We will add a status field to our model that will allow us to manage the status of blog posts. We will be using Draft and Published statuses for posts.</p> models.py<pre><code>from django.db import models\nfrom django.utils import timezone\n\nclass Post(models.Model):\n    class Status(models.TextChoices):\n        DRAFT = 'DF', 'Draft'\n        PUBLISHED = 'PB', 'Published'\n\n    title = models.CharField(max_length=250)\n    slug = models.SlugField(max_length=250)\n    body = models.TextField()\n    publish = models.DateTimeField(default=timezone.now)\n    created = models.DateTimeField(auto_now_add=True)\n    updated = models.DateTimeField(auto_now=True)\n    status = models.CharField(\n                            max_length=2,\n                            choices=Status.choices,\n                            default=Status.DRAFT\n                            )\n    class Meta:\n        ordering = ['-publish']\n        indexes = [\n        models.Index(fields=['-publish']),\n    ]\n\n    def__str__(self):\n        return self.title\n</code></pre> <p>We have defined the enumeration class Status by subclassing models.TextChoices . The available choices for the post status are DRAFT and PUBLISHED. Their respective values are DF and PB, and their labels or readable names are Draft and Published.</p> <p>Django provides enumeration types that you can subclass to define choices simply. These are based on the enum object of Python\u2019s standard library. You can read more about enum at https://docs.python.org/3/library/enum.html.</p>"},{"location":"blog/2024/05/07/creating-a-blog-model-in-django/#shell","title":"Shell","text":"<pre><code>python manage.py shell\n\n&gt;&gt;&gt; from blog.models import Post\n\n&gt;&gt;&gt; Post.Status.choices\n[('DF', 'Draft'), ('PB', 'Published')]\n\n&gt;&gt;&gt; Post.Status.labels\n['Draft', 'Published']\n\n&gt;&gt;&gt; Post.Status.values\n['DF', 'PB']\n\n&gt;&gt;&gt; Post.Status.names\n['DRAFT', 'PUBLISHED']\n</code></pre> <p>You can access a specific lookup enumeration member with Post.Status.PUBLISHED and you can access its .name and .value properties as well.</p>"},{"location":"blog/2024/05/07/creating-a-blog-model-in-django/#adding-a-many-to-one-relationship","title":"Adding a many-to-one relationship","text":"<p>Posts are always written by an author. We will create a relationship between users and posts that will indicate which user wrote which posts. Django comes with an authentication framework that handles user accounts. The Django authentication framework comes in the django.contrib.auth package and contains a User model. </p> <p>We will use the User model from the Django authentication framework to create a relationship between users and posts.</p> models.py<pre><code>from django.db import models\nfrom django.utils import timezone\nfrom django.contrib.auth.models import User\n\nclass Post(models.Model):\n    class Status(models.TextChoices):\n        DRAFT = 'DF', 'Draft'\n        PUBLISHED = 'PB', 'Published'\n\n    title = models.CharField(max_length=250)\n    slug = models.SlugField(max_length=250)\n    author = models.ForeignKey(\n                                User,\n                                on_delete=models.CASCADE,\n                                related_name='blog_posts'\n                              )\n    body = models.TextField()\n    publish = models.DateTimeField(default=timezone.now)\n    created = models.DateTimeField(auto_now_add=True)\n    updated = models.DateTimeField(auto_now=True)\n    status = models.CharField(\n                            max_length=2,\n                            choices=Status.choices,\n                            default=Status.DRAFT\n                            )\n    class Meta:\n        ordering = ['-publish']\n        indexes = [\n        models.Index(fields=['-publish']),\n    ]\n\n    def__str__(self):\n        return self.title\n</code></pre>"},{"location":"blog/2024/05/07/creating-a-blog-model-in-django/#reference","title":"Reference","text":"<ul> <li>Django 4 By Example Fourth Edition by Antonio Mel\u00e9:pg-12</li> </ul>"},{"location":"blog/2024/01/05/django-cors/","title":"Django cors","text":"","tags":["Django"]},{"location":"blog/2024/01/05/django-cors/#django-cors","title":"Django cors","text":"<p>django-cors-headers is a Django application for handling the server headers required for Cross-Origin Resource Sharing (CORS). Adding CORS headers allows your resources to be accessed on other domains.</p> <p>CORS is a mechanism to allow interaction with resources hosted on different domains.</p> <pre><code>$ pip install django-cors-headers\n\n$ pip install django djangorestframework django-cors-headers\n</code></pre> <p>and then add it to your installed apps:</p> <pre><code>INSTALLED_APPS = [\n    ...,\n    \"corsheaders\",\n    ...,\n]\n</code></pre> <p>You will also need to add a middleware class to listen in on responses:</p> <pre><code>MIDDLEWARE = [\n    ...,\n    \"corsheaders.middleware.CorsMiddleware\",\n    \"django.middleware.common.CommonMiddleware\",\n    ...,\n]\n</code></pre> <p><code>CorsMiddleware</code> should be placed as high as possible, especially before any middleware that can generate responses such as Django\u2019s <code>CommonMiddleware</code> or Whitenoise\u2019s <code>WhiteNoiseMiddleware</code>. If it is not before, it will not be able to add the CORS headers to these responses.</p> <p>Configuration</p> <p>Configure the middleware\u2019s behaviour in your Django settings. You must set at least one of three following settings:</p> <ul> <li><code>CORS_ALLOWED_ORIGINS</code></li> <li><code>CORS_ALLOWED_ORIGIN_REGEXES</code></li> <li><code>CORS_ALLOW_ALL_ORIGINS</code></li> </ul> <p>Example:</p> <pre><code>CORS_ALLOWED_ORIGINS = [\n    \"https://example.com\",\n    \"https://sub.example.com\",\n    \"http://localhost:8080\",\n    \"http://127.0.0.1:9000\",\n]\n</code></pre> <p>CORS_ORIGIN_WHITELIST <code>Deprecated</code> VS CORS_ALLOWED_ORIGINS</p> <ul> <li>before version <code>3.0.0</code> he setting used to whitelist allowed origins was <code>CORS_ORIGIN_WHITELIST</code>.</li> <li>In version <code>3.0.0</code> and later, the naming convention was changed to <code>CORS_ALLOWED_ORIGINS</code> for consistency with other Django settings.</li> <li>You should use <code>CORS_ALLOWED_ORIGINS</code> in more recent versions of <code>django-cors-headers</code>:</li> </ul>","tags":["Django"]},{"location":"blog/2024/01/05/django-cors/#reference","title":"Reference","text":"<ul> <li>django-cors-headers</li> <li>Django CORS Guide</li> <li> <p>whitelist cors</p> </li> <li> <p>How to Integrate ReactJS with Django Framework</p> </li> <li>Using React with Django to create an app</li> <li>How to Integrate React and Django framework, in a simpler way</li> <li>what are the possible ways to integrate react: reddit</li> <li>How to build a React application in a Django project </li> <li>Integrating Django with Reactjs using Django REST Framework</li> </ul>","tags":["Django"]},{"location":"blog/2024/05/03/a-guide-to-csrf-cookie-settings/","title":"A Guide to CSRF Cookie Settings","text":"","tags":["Django"]},{"location":"blog/2024/05/03/a-guide-to-csrf-cookie-settings/#a-guide-to-csrf-cookie-settings","title":"A Guide to CSRF Cookie Settings","text":"<p>Django, a popular web framework for Python, comes equipped with robust measures to mitigate CSRF risks.</p>","tags":["Django"]},{"location":"blog/2024/05/03/a-guide-to-csrf-cookie-settings/#strengthening-django-security","title":"Strengthening Django Security:","text":"<p>In the dynamic landscape of web development, security is paramount. Django, a powerful Python web framework, provides robust measures to fortify applications against threats like Cross-Site Request Forgery (CSRF). Let's explore how two critical CSRF cookie settings, <code>CSRF_COOKIE_SECURE</code> and <code>CSRF_COOKIE_HTTPONLY</code>, enhance security.</p>","tags":["Django"]},{"location":"blog/2024/05/03/a-guide-to-csrf-cookie-settings/#1-csrf_cookie_secure-guarding-transmission","title":"1. <code>CSRF_COOKIE_SECURE</code>: Guarding Transmission","text":"<p>Consider a scenario where an attacker intercepts requests between a user and a Django application. Without encryption, sensitive data, including CSRF tokens, is vulnerable. Setting <code>CSRF_COOKIE_SECURE</code> to <code>True</code> ensures the CSRF cookie is transmitted solely over secure HTTPS connections.</p> <p>SECURE</p> python<pre><code># settings.py\nCSRF_COOKIE_SECURE = True\n</code></pre> <p>By enforcing HTTPS, Django shields the CSRF token from interception during transit. This simple setting bolsters the integrity of the CSRF protection mechanism, enhancing overall security.</p>","tags":["Django"]},{"location":"blog/2024/05/03/a-guide-to-csrf-cookie-settings/#2-csrf_cookie_httponly-limiting-script-access","title":"2. <code>CSRF_COOKIE_HTTPONLY</code>: Limiting Script Access","text":"<p>Now, imagine a malicious script injected into a page, aiming to hijack user sessions. Without proper safeguards, the script could access and manipulate the CSRF token, enabling unauthorized actions. By setting <code>CSRF_COOKIE_HTTPONLY</code> to <code>True</code>, Django restricts access to the CSRF cookie from client-side scripts.</p> <p>HTTPONLY</p> python<pre><code># settings.py\nCSRF_COOKIE_HTTPONLY = True\n</code></pre> <p>This precaution mitigates Cross-Site Scripting (XSS) attacks, preserving user session integrity and thwarting unauthorized requests.</p>","tags":["Django"]},{"location":"blog/2024/05/03/a-guide-to-csrf-cookie-settings/#conclusion","title":"Conclusion","text":"<p>In conclusion, configuring CSRF cookie settings in Django is essential for bolstering application security. By enabling CSRF_COOKIE_SECURE and CSRF_COOKIE_HTTPONLY, developers fortify their defenses against CSRF and XSS attacks, safeguarding user interactions and data confidentiality.</p> <p>```python title=\"python\"</p>","tags":["Django"]},{"location":"blog/2024/05/03/a-guide-to-csrf-cookie-settings/#settingspy","title":"settings.py","text":"<p>CSRF_COOKIE_SECURE = True CSRF_COOKIE_HTTPONLY = True ``</p> <p>As stewards of digital trust, let's prioritize security, ensuring Django applications provide users with a safe and resilient online experience.</p>","tags":["Django"]},{"location":"blog/2024/06/14/dumping-data-from-django-database/","title":"Dumping Data from Django Database","text":"","tags":["django","management"]},{"location":"blog/2024/06/14/dumping-data-from-django-database/#dumping-data-from-django-database","title":"Dumping Data from Django Database","text":"<p>Dumping data from a Django database and loading it into a local environment can be useful for various reasons, such as creating backups or setting up development environments. Here's how you can do it step-by-step:</p>","tags":["django","management"]},{"location":"blog/2024/06/14/dumping-data-from-django-database/#dumping-data-from-django-database_1","title":"Dumping Data from Django Database","text":"<ol> <li> <p>Navigate to your Django project directory: Open a terminal or command prompt and change directory to where your Django manage.py file is located.</p> </li> <li> <p>Use the <code>dumpdata</code> management command: Django provides a dumpdata management command that allows you to dump data from your database into a JSON or other serialized format.</p> <p>Tip</p> To dump all data from your database:To dump data from a specific app: python<pre><code>python manage.py dumpdata &gt; db_dump.json\n</code></pre> <p>This command will dump all data from all apps in your project into a file named <code>db_dump.json</code>. Replace <code>db_dump.json</code> with the desired filename.</p> python<pre><code>python manage.py dumpdata your_app_name &gt; app_data.json\n</code></pre> <p>Replace your_app_name with the name of the app whose data you want to dump.</p> </li> <li> <p>Customize the output format: By default, <code>dumpdata</code> outputs data in JSON format. You can specify other formats like YAML or XML by using the <code>--format</code> option:</p> <p>Tip</p> <pre><code>python manage.py dumpdata --format=yaml &gt; db_dump.yaml\n</code></pre> <p>This will dump the data in <code>YAML format</code>.</p> </li> </ol>","tags":["django","management"]},{"location":"blog/2024/06/14/dumping-data-from-django-database/#loading-data-into-local-database","title":"Loading Data into Local Database","text":"<ol> <li> <p>Copy the dump file to your local environment: Transfer the dumped file (<code>db_dump.json</code>, <code>app_data.json</code>, etc.) to your local development environment if it's not already there.</p> </li> <li> <p>Ensure your local database is set up: Make sure your local database (e.g., SQLite, PostgreSQL) is set up and configured correctly in your Django project's settings (<code>settings.py</code>).</p> </li> <li> <p>Use the <code>loaddata</code> management command: Django provides the loaddata management command to load data.</p> <p>Tip</p> bash<pre><code>python manage.py loaddata data.json\n</code></pre> </li> </ol>","tags":["django","management"]},{"location":"blog/2024/05/10/django-easy-thumbnails-package/","title":"Django easy-thumbnails package","text":"","tags":["Python","Django"]},{"location":"blog/2024/05/10/django-easy-thumbnails-package/#django-easy-thumbnails-package","title":"Django <code>easy-thumbnails</code> package","text":"","tags":["Python","Django"]},{"location":"blog/2024/05/10/django-easy-thumbnails-package/#reference","title":"Reference","text":"<ul> <li>easy-thumbnails : pypi</li> <li> <p>easy-thumbnails : github</p> </li> <li> <p>django-imagekit: readthedocs</p> </li> <li>django-imagekit: github</li> </ul> <p>Blog</p> <ul> <li>imagekit or easythumbnails for creating</li> <li>How to programmatically create django-imagekit based content instances?</li> <li>Django Easy Thumbnail not working</li> </ul>","tags":["Python","Django"]},{"location":"blog/2024/05/20/using-elasticsearch-with-django-and-drf/","title":"Using Elasticsearch with Django and DRF","text":"","tags":["Django","Drf","elasticsearch"]},{"location":"blog/2024/05/20/using-elasticsearch-with-django-and-drf/#using-elasticsearch-with-django-and-drf","title":"Using Elasticsearch with Django and DRF","text":"<p>Elasticsearch can be used both in REST APIs and directly within Django applications. It is not limited to just one type of usage. </p> <p>Here's a breakdown of how Elasticsearch can be integrated and used in different contexts:</p> <ol> <li> <p>Direct Integration in Django:</p> <ul> <li> <p>Model Indexing:</p> <p>Index Django models directly into Elasticsearch. This can be done using libraries like django-elasticsearch-dsl, which provides Django-friendly abstractions to define Elasticsearch indices and documents that map to Django models.</p> </li> <li> <p>Search Views:</p> <p>Create search views in Django to handle search queries and display results. This allows you to build powerful search features into your Django web application.</p> </li> <li> <p>Template Rendering:</p> <p>Use Django templates to render search results directly on web pages, enabling full-text search capabilities in your Django web application.</p> </li> </ul> </li> <li> <p>Using Elasticsearch in Django REST Framework (DRF):</p> <ul> <li> <p>API Endpoints:</p> <p>Create REST API endpoints that utilize Elasticsearch for searching and retrieving data. This is particularly useful for building search APIs that can be consumed by various clients, including web and mobile applications.</p> </li> <li> <p>Serializers:</p> <p>Serialize Elasticsearch search results into JSON format, which can be returned by API endpoints.</p> </li> <li> <p>DRF Integration:</p> <p>Integrate Elasticsearch with Django REST Framework views and viewsets, enabling advanced search capabilities within your REST API.</p> </li> </ul> </li> </ol>","tags":["Django","Drf","elasticsearch"]},{"location":"blog/2024/05/20/using-elasticsearch-with-django-and-drf/#example-direct-integration-in-django","title":"Example: Direct Integration in Django","text":"<p>Here\u2019s a simple example of how to integrate Elasticsearch directly within a Django application, as covered earlier:</p> <ol> <li> <p>Install Dependencies</p> <p>bash</p> <pre><code>pip install elasticsearch-dsl django-elasticsearch-dsl\n</code></pre> </li> <li> <p>Configure Elasticsearch in Django Settings</p> <p>settings.py</p> <pre><code>ELASTICSEARCH_DSL = {\n    'default': {\n        'hosts': 'localhost:9200'\n    },\n}\n</code></pre> </li> <li> <p>Define Django Model and Elasticsearch Document</p> <p>models.py</p> <pre><code>from django.db import models\n\nclass Book(models.Model):\n    title = models.CharField(max_length=255)\n    author = models.CharField(max_length=255)\n    published_date = models.DateField()\n    summary = models.TextField()\n\n    def __str__(self):\n        return self.title\n</code></pre> <p>documents.py</p> <pre><code>from django_elasticsearch_dsl import Document\nfrom django_elasticsearch_dsl.registries import registry\nfrom .models import Book\n\n@registry.register_document\nclass BookDocument(Document):\n    class Index:\n        name = 'books'\n\n    class Django:\n        model = Book\n        fields = [\n            'title',\n            'author',\n            'published_date',\n            'summary',\n        ]\n</code></pre> </li> <li> <p>Create Search View</p> <p>views.py</p> <pre><code>from django.shortcuts import render\nfrom .documents import BookDocument\n\ndef search(request):\n    query = request.GET.get('q')\n    if query:\n        books = BookDocument.search().query(\"multi_match\", query=query, fields=['title', 'author', 'summary'])\n    else:\n        books = BookDocument.search()\n\n    return render(request, 'search_results.html', {'books': books})\n</code></pre> </li> <li> <p>Define URL Pattern</p> <p>urls.py</p> <pre><code>from django.urls import path\nfrom .views import search\n\nurlpatterns = [\n    path('search/', search, name='search'),\n]\n</code></pre> </li> <li> <p>Create Template</p> <p>templates/search_results.html</p> <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;title&gt;Search Results&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;h1&gt;Search Results&lt;/h1&gt;\n    &lt;form method=\"GET\" action=\"{% url 'search' %}\"&gt;\n        &lt;input type=\"text\" name=\"q\" placeholder=\"Search for books...\" value=\"{{ request.GET.q }}\"&gt;\n        &lt;button type=\"submit\"&gt;Search&lt;/button&gt;\n    &lt;/form&gt;\n    &lt;ul&gt;\n        {% for book in books %}\n            &lt;li&gt;{{ book.title }} by {{ book.author }} ({{ book.published_date }})&lt;/li&gt;\n        {% empty %}\n            &lt;li&gt;No results found.&lt;/li&gt;\n        {% endfor %}\n    &lt;/ul&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre> </li> </ol>","tags":["Django","Drf","elasticsearch"]},{"location":"blog/2024/05/20/using-elasticsearch-with-django-and-drf/#example-using-elasticsearch-in-django-rest-framework","title":"Example: Using Elasticsearch in Django REST Framework","text":"<ol> <li> <p>Install Dependencies</p> <p>bash</p> <pre><code>pip install djangorestframework elasticsearch-dsl django-elasticsearch-dsl\n</code></pre> </li> <li> <p>Create API View</p> <p>api_views.py</p> <pre><code>from rest_framework.views import APIView\nfrom rest_framework.response import Response\nfrom .documents import BookDocument\n\nclass BookSearchAPIView(APIView):\n    def get(self, request):\n        query = request.GET.get('q')\n        if query:\n            books = BookDocument.search().query(\"multi_match\", query=query, fields=['title', 'author', 'summary'])\n        else:\n            books = BookDocument.search()\n\n        results = [{'title': book.title, 'author': book.author, 'published_date': book.published_date, 'summary': book.summary} for book in books]\n        return Response(results)\n</code></pre> </li> <li> <p>Define URL Pattern for API</p> <p>urls.py</p> <pre><code>from django.urls import path\nfrom .api_views import BookSearchAPIView\n\nurlpatterns = [\n    path('api/search/', BookSearchAPIView.as_view(), name='api_search'),\n]\n</code></pre> </li> </ol>","tags":["Django","Drf","elasticsearch"]},{"location":"blog/2024/05/20/using-elasticsearch-with-django-and-drf/#conclusion","title":"Conclusion","text":"<p>Elasticsearch can be used in both traditional Django views and in Django REST Framework to provide advanced search capabilities. The integration allows for powerful full-text search features that are not limited to just REST APIs but can also enhance the search functionality of a Django web application directly. This flexibility makes Elasticsearch a valuable tool for a wide range of use cases in Django projects.</p>","tags":["Django","Drf","elasticsearch"]},{"location":"blog/2024/05/20/intro-to-elasticsearch/","title":"Intro to Elasticsearch","text":"","tags":["Django","Drf","elasticsearch"]},{"location":"blog/2024/05/20/intro-to-elasticsearch/#intro-to-elasticsearch","title":"Intro to Elasticsearch","text":"<p>Elasticsearch is a powerful search and analytics engine that can be integrated with Django to enhance the search capabilities of a Django application. </p> <p>Here's a detailed look at what Elasticsearch is, why you might need it, when to use it, and when not to use it in the context of a Django project:</p>","tags":["Django","Drf","elasticsearch"]},{"location":"blog/2024/05/20/intro-to-elasticsearch/#what-is-elasticsearch","title":"What is Elasticsearch?","text":"<p>Elasticsearch is an open-source, distributed, RESTful search engine built on top of Apache Lucene. It is designed to handle large volumes of data and provides real-time search and analytics capabilities. It is often used for full-text search, log and event data analysis, and as a general-purpose data store.</p>","tags":["Django","Drf","elasticsearch"]},{"location":"blog/2024/05/20/intro-to-elasticsearch/#why-do-we-need-elasticsearch-in-django","title":"Why Do We Need Elasticsearch in Django?","text":"<p>Django's default search capabilities are limited, especially when dealing with complex queries, large datasets, and requirements for real-time search results. Elasticsearch addresses these limitations by providing:</p> <ol> <li> <p>Full-Text Search:</p> <p>Efficiently handle large amounts of text data, enabling advanced search features like stemming, synonyms, and relevancy ranking.</p> </li> <li> <p>Performance:</p> <p>High-speed querying and indexing capabilities, making it suitable for applications with substantial data and high query volume.</p> </li> <li> <p>Scalability:</p> <p>Distributed architecture allows it to scale horizontally, managing large datasets across multiple nodes.</p> </li> <li> <p>Advanced Queries:</p> <p>Supports complex queries, aggregations, and analytics that go beyond the capabilities of Django\u2019s ORM and basic database searches.</p> </li> <li> <p>Real-Time Data:</p> <p>Provides near real-time search capabilities, ensuring that data is quickly searchable after being indexed.</p> </li> </ol>","tags":["Django","Drf","elasticsearch"]},{"location":"blog/2024/05/20/intro-to-elasticsearch/#when-to-use-elasticsearch-in-django","title":"When to Use Elasticsearch in Django?","text":"<ol> <li> <p>Complex Search Requirements:</p> <p>When you need advanced search features like full-text search, autocomplete, fuzzy search, or custom scoring.</p> </li> <li> <p>Large Datasets:</p> <p>If your application involves a significant amount of data that needs to be searched quickly.</p> </li> <li> <p>Real-Time Searching:</p> <p>When you need search results to be updated in real-time or near real-time.</p> </li> <li> <p>Analytics and Aggregations:</p> <p>When you require complex aggregations and analytics over your data.</p> </li> <li> <p>High Query Volume:</p> <p>Applications that need to handle a high volume of search queries efficiently.</p> </li> </ol>","tags":["Django","Drf","elasticsearch"]},{"location":"blog/2024/05/20/intro-to-elasticsearch/#when-not-to-use-elasticsearch-in-django","title":"When Not to Use Elasticsearch in Django?","text":"<ol> <li> <p>Simple Applications:</p> <p>If your search requirements are basic and can be handled by Django\u2019s ORM or a simple database index, Elasticsearch might be overkill.</p> </li> <li> <p>Small Datasets:</p> <p>For applications with minimal data, the overhead of setting up and maintaining Elasticsearch might not be justified.</p> </li> <li> <p>Resource Constraints:</p> <p>Elasticsearch requires additional resources and maintenance. If your project has limited infrastructure or operational capacity, it might be better to stick with simpler solutions.</p> </li> <li> <p>Learning Curve and Complexity:</p> <p>Elasticsearch introduces additional complexity and has a steeper learning curve. If your team lacks the expertise or the time to learn and manage it, it might not be a good fit.</p> </li> </ol>","tags":["Django","Drf","elasticsearch"]},{"location":"blog/2024/05/20/intro-to-elasticsearch/#integrating-elasticsearch-with-django","title":"Integrating Elasticsearch with Django","text":"<p>To integrate Elasticsearch with Django, you typically use libraries such as django-elasticsearch-dsl or elasticsearch-dsl. These libraries provide Django-friendly tools to define Elasticsearch indices, document types, and manage indexing operations. Here\u2019s a high-level overview of how to set it up:</p> <ol> <li> <p>Install Dependencies:</p> <p>Tip</p> bash<pre><code>pip install elasticsearch-dsl django-elasticsearch-dsl\n</code></pre> </li> <li> <p>Define Elasticsearch Settings: Configure your Elasticsearch connection in your Django settings.</p> <p>Tip</p> settings.py<pre><code># settings.py\nELASTICSEARCH_DSL = {\n    'default': {\n        'hosts': 'localhost:9200'\n    },\n}\n</code></pre> </li> <li> <p>Create Document Classes: Define your Elasticsearch document structure using Django models.</p> <p>Tip</p> documents.py<pre><code># documents.py\nfrom django_elasticsearch_dsl import Document\nfrom django_elasticsearch_dsl.registries import registry\nfrom myapp.models import MyModel\n\n@registry.register_document\nclass MyModelDocument(Document):\n    class Index:\n        name = 'mymodel_index'\n\n    class Django:\n        model = MyModel\n        fields = ['field1', 'field2']\n</code></pre> </li> <li> <p>Indexing Data: Ensure your data is indexed in Elasticsearch. You can create signals to automatically update the index when data changes.</p> </li> <li> <p>Search Queries: Use Elasticsearch DSL to perform search queries on your indexed data.</p> </li> </ol>","tags":["Django","Drf","elasticsearch"]},{"location":"blog/2024/05/20/intro-to-elasticsearch/#conclusion","title":"Conclusion","text":"<p>Elasticsearch can significantly enhance the search functionality of a Django application, especially for projects that require complex search capabilities, handle large datasets, or need real-time data indexing and retrieval. However, it is important to assess the specific needs of your project to determine if the added complexity and resource requirements are justified. For simpler applications or those with minimal search requirements, Django\u2019s built-in search capabilities or a simpler solution may suffice.</p>","tags":["Django","Drf","elasticsearch"]},{"location":"blog/2024/05/20/intro-to-elasticsearch/#practical-with-example","title":"Practical with Example","text":"","tags":["Django","Drf","elasticsearch"]},{"location":"blog/2024/05/20/intro-to-elasticsearch/#step-1-install-dependencies","title":"Step 1: Install Dependencies","text":"<p>First, install the necessary libraries using pip:</p> <p>Success</p> bash<pre><code>pip install elasticsearch-dsl django-elasticsearch-dsl\n</code></pre>","tags":["Django","Drf","elasticsearch"]},{"location":"blog/2024/05/20/intro-to-elasticsearch/#step-2-configure-elasticsearch-in-django-settings","title":"Step 2: Configure Elasticsearch in Django Settings","text":"<p>Add your Elasticsearch configuration to your Django settings file (<code>settings.py</code>):</p> <p>Success</p> settings.py<pre><code># settings.py\nELASTICSEARCH_DSL = {\n    'default': {\n        'hosts': 'localhost:9200'  # Update if your Elasticsearch is hosted elsewhere\n    },\n}\n</code></pre>","tags":["Django","Drf","elasticsearch"]},{"location":"blog/2024/05/20/intro-to-elasticsearch/#step-3-define-your-django-model","title":"Step 3: Define Your Django Model","text":"<p>Create a Django model that you want to index. For example, let\u2019s create a simple <code>Book</code> model:</p> <p>Success</p> <pre><code># models.py\nfrom django.db import models\n\nclass Book(models.Model):\n    title = models.CharField(max_length=255)\n    author = models.CharField(max_length=255)\n    published_date = models.DateField()\n    summary = models.TextField()\n\n    def __str__(self):\n        return self.title\n</code></pre>","tags":["Django","Drf","elasticsearch"]},{"location":"blog/2024/05/20/intro-to-elasticsearch/#step-4-create-an-elasticsearch-document","title":"Step 4: Create an Elasticsearch Document","text":"<p>Define a document that maps to the Book model using <code>django-elasticsearch-dsl</code>:</p> <p>Success</p> <pre><code># documents.py\nfrom django_elasticsearch_dsl import Document, fields\nfrom django_elasticsearch_dsl.registries import registry\nfrom .models import Book\n\n@registry.register_document\nclass BookDocument(Document):\n    class Index:\n        # Name of the Elasticsearch index\n        name = 'books'\n        # See Elasticsearch Indices API reference for available settings\n        settings = {\n            'number_of_shards': 1,\n            'number_of_replicas': 0\n        }\n\n    class Django:\n        model = Book  # The model associated with this Document\n\n        # The fields of the model you want to be indexed in Elasticsearch\n        fields = [\n            'title',\n            'author',\n            'published_date',\n            'summary',\n        ]\n</code></pre>","tags":["Django","Drf","elasticsearch"]},{"location":"blog/2024/05/20/intro-to-elasticsearch/#step-5-indexing-data","title":"Step 5: Indexing Data","text":"<p>To ensure your data is indexed, you can create signals to automatically update the index when a <code>Book</code> instance is created, updated, or deleted.</p> <p>Success</p> <pre><code># signals.py\nfrom django.db.models.signals import post_save, post_delete\nfrom django.dispatch import receiver\nfrom .models import Book\nfrom .documents import BookDocument\n\n@receiver(post_save, sender=Book)\ndef update_document(sender, instance, **kwargs):\n    BookDocument().update(instance)\n\n@receiver(post_delete, sender=Book)\ndef delete_document(sender, instance, **kwargs):\n    BookDocument().delete(instance)\n</code></pre> <p>Connect the signals in your app\u2019s <code>apps.py</code>:</p> <p>Success</p> <pre><code># apps.py\nfrom django.apps import AppConfig\n\nclass MyAppConfig(AppConfig):\n    name = 'myapp'\n\n    def ready(self):\n        import myapp.signals  # Import signals to ensure they are registered\n</code></pre>","tags":["Django","Drf","elasticsearch"]},{"location":"blog/2024/05/20/intro-to-elasticsearch/#step-6-perform-a-search-query","title":"Step 6: Perform a Search Query","text":"<p>Now you can perform a search query using the <code>BookDocument</code>. For example, you can create a simple search view in Django:</p> <p>Tip</p> <pre><code># views.py\nfrom django.shortcuts import render\nfrom .documents import BookDocument\n\ndef search(request):\n    query = request.GET.get('q')\n    if query:\n        books = BookDocument.search().query(\"multi_match\", query=query, fields=['title', 'author', 'summary'])\n    else:\n        books = BookDocument.search()\n\n    return render(request, 'search_results.html', {'books': books})\n</code></pre>","tags":["Django","Drf","elasticsearch"]},{"location":"blog/2024/05/20/intro-to-elasticsearch/#step-7-create-a-template","title":"Step 7: Create a Template","text":"<p>Create a template to display the search results (<code>search_results.html</code>):</p> <p>Success</p> <pre><code>&lt;!-- templates/search_results.html --&gt;\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;title&gt;Search Results&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;h1&gt;Search Results&lt;/h1&gt;\n    &lt;form method=\"GET\" action=\"{% url 'search' %}\"&gt;\n        &lt;input type=\"text\" name=\"q\" placeholder=\"Search for books...\" value=\"{{ request.GET.q }}\"&gt;\n        &lt;button type=\"submit\"&gt;Search&lt;/button&gt;\n    &lt;/form&gt;\n    &lt;ul&gt;\n        {% for book in books %}\n            &lt;li&gt;{{ book.title }} by {{ book.author }} ({{ book.published_date }})&lt;/li&gt;\n        {% empty %}\n            &lt;li&gt;No results found.&lt;/li&gt;\n        {% endfor %}\n    &lt;/ul&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>","tags":["Django","Drf","elasticsearch"]},{"location":"blog/2024/05/20/intro-to-elasticsearch/#step-8-add-url-pattern","title":"Step 8: Add URL Pattern","text":"<p>Finally, add a URL pattern to route to the search view (<code>urls.py</code>):</p> <p>Tip</p> <pre><code># urls.py\nfrom django.urls import path\nfrom .views import search\n\nurlpatterns = [\n    path('search/', search, name='search'),\n]\n</code></pre>","tags":["Django","Drf","elasticsearch"]},{"location":"blog/2024/05/20/intro-to-elasticsearch/#conclusion_1","title":"Conclusion","text":"<p>With these steps, you have integrated Elasticsearch with your Django application. You have defined a Book model, created an Elasticsearch document for it, set up signals to index the data, and implemented a basic search view and template. This setup will allow you to perform efficient full-text searches on your book data.</p>","tags":["Django","Drf","elasticsearch"]},{"location":"blog/2024/01/01/managing-development-env-in-django/","title":"Managing development .env in Django","text":"","tags":["Django"]},{"location":"blog/2024/01/01/managing-development-env-in-django/#managing-development-env-in-django","title":"Managing development <code>.env</code> in Django","text":"<p>Python-dotenv reads key-value pairs from a <code>.env</code> file and can set them as environment variables. It helps in the development of applications following the 12-factor principles.</p> <pre><code>$ pip install python-dotenv\n</code></pre> <p>Create a <code>.env.example</code> file in the root file.</p> <p>.env.example</p> <pre><code>SECRET_KEY=\nDB_NAME=\nDB_USER=root\nDB_PASS=\nDB_HOST=localhost\nDB_PORT=3306\n</code></pre> <p>while in development, copy and paste <code>.env.example</code>, new file called <code>.env</code></p> <p>.env</p> <pre><code>SECRET_KEY=\"your secret key inside quotes\"\nDB_NAME=db-name\nDB_USER=root\nDB_PASS=\nDB_HOST=localhost\nDB_PORT=3306\n</code></pre> <p>Update the <code>settings.py</code> file in project</p> <p>settings.py</p> <pre><code>from dotenv import load_dotenv\nfrom datetime import timedelta\nimport os\n\n# load environment variables from a file named .env into the environment of your application.\nload_dotenv()\n\n# added\nSECRET_KEY = os.environ.get('SECRET_KEY')\n\n\n# updated the databse\nDATABASES = {\n    'default': {\n        'ENGINE': 'django.db.backends.mysql',\n        'NAME': os.environ.get('DB_NAME'),\n        'USER': os.environ.get('DB_USER'),\n        'PASSWORD': os.environ.get('DB_PASS'),\n        'HOST': os.environ.get('DB_HOST'),\n        'PORT': os.environ.get('DB_PORT'),\n        'OPTIONS': {\n            'init_command': \"SET sql_mode='STRICT_TRANS_TABLES'\",\n        },\n    }\n}\n</code></pre> <p>That's it now you're good to go ;)</p>","tags":["Django"]},{"location":"blog/2024/01/01/managing-development-env-in-django/#reference","title":"Reference","text":"<ul> <li>python-dotenv</li> <li>django key generator online</li> </ul>","tags":["Django"]},{"location":"blog/2024/06/28/django-environ-package/","title":"django-environ package","text":"","tags":["django","environ"]},{"location":"blog/2024/06/28/django-environ-package/#django-environ-package","title":"<code>django-environ</code> package","text":"<p><code>django-environ</code> is a library that helps manage environment variables in Django projects. It allows you to configure your Django settings via environment variables, which is useful for separating configuration from code, enhancing security, and making your application more flexible for different environments (<code>development</code>, <code>testing</code>, <code>production</code>).</p>","tags":["django","environ"]},{"location":"blog/2024/06/28/django-environ-package/#why-use-django-environ","title":"Why Use django-environ?","text":"<ol> <li>Security: Keep sensitive data like secret keys and database passwords out of your source code.</li> <li>Flexibility: Easily change settings for different environments without modifying the code.</li> <li>Convenience: Manage configuration in a central place, usually through a <code>.env</code>  file.</li> </ol>","tags":["django","environ"]},{"location":"blog/2024/06/28/django-environ-package/#basic-usage","title":"Basic Usage","text":"<ol> <li> <p>Install <code>django-environ</code>:</p> <pre><code>pip install django-environ\n</code></pre> </li> <li> <p>Create a <code>.env</code> File:</p> <pre><code>DEBUG=True\nSECRET_KEY=your-secret-key\nDATABASE_URL=psql://user:password@localhost:5432/dbname\n</code></pre> </li> <li> <p>Configure Django Settings:</p> <pre><code># settings.py\nimport environ\n\n# Initialize environment variables\nenv = environ.Env(\n    # set casting, default value\n    DEBUG=(bool, False)\n)\n\n# reading .env file\nenviron.Env.read_env()\n\n# Take environment variables from .env file\nDEBUG = env('DEBUG')\nSECRET_KEY = env('SECRET_KEY')\nDATABASES = {\n    'default': env.db(),\n}\n</code></pre> </li> </ol>","tags":["django","environ"]},{"location":"blog/2024/06/28/django-environ-package/#advanced-usage","title":"Advanced Usage","text":"<ol> <li> <p>Handling Different Data Types:</p> <pre><code>ALLOWED_HOSTS=localhost, .yourdomain.com\nCACHE_URL=redis://127.0.0.1:6379/1\n</code></pre> <pre><code># settings.py\nALLOWED_HOSTS = env.list('ALLOWED_HOSTS', default=['localhost'])\nCACHES = {\n    'default': env.cache('CACHE_URL')\n}\n</code></pre> </li> <li> <p>Default Values and Casting:</p> <pre><code>EMAIL_PORT=587\nEMAIL_USE_TLS=True\n</code></pre> <pre><code># settings.py\nEMAIL_PORT = env.int('EMAIL_PORT', default=25)\nEMAIL_USE_TLS = env.bool('EMAIL_USE_TLS', default=False)\n</code></pre> </li> <li> <p>Complex Nested Settings:</p> <pre><code>LOGGING_LEVEL=DEBUG\n</code></pre> <pre><code># settings.py\nLOGGING = {\n    'version': 1,\n    'disable_existing_loggers': False,\n    'handlers': {\n        'console': {\n            'class': 'logging.StreamHandler',\n        },\n    },\n    'root': {\n        'handlers': ['console'],\n        'level': env('LOGGING_LEVEL', default='WARNING'),\n    },\n}\n</code></pre> </li> </ol>","tags":["django","environ"]},{"location":"blog/2024/06/28/django-environ-package/#example-project-structure","title":"Example Project Structure","text":"<pre><code>myproject/\n\u251c\u2500\u2500 .env\n\u251c\u2500\u2500 manage.py\n\u251c\u2500\u2500 myproject/\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 settings.py\n\u2502   \u251c\u2500\u2500 urls.py\n\u2502   \u2514\u2500\u2500 wsgi.py\n</code></pre>","tags":["django","environ"]},{"location":"blog/2024/06/28/django-environ-package/#sample-env-file","title":"Sample <code>.env</code> File","text":"<pre><code>DEBUG=True\nSECRET_KEY=your-secret-key\nDATABASE_URL=psql://user:password@localhost:5432/dbname\nALLOWED_HOSTS=localhost, .yourdomain.com\nCACHE_URL=redis://127.0.0.1:6379/1\nEMAIL_PORT=587\nEMAIL_USE_TLS=True\nLOGGING_LEVEL=DEBUG\n</code></pre> <p>By using <code>django-environ</code>, you can maintain clean and secure configurations, making your project easier to manage and deploy across different environments.</p>","tags":["django","environ"]},{"location":"blog/2024/06/28/django-environ-package/#reference","title":"Reference","text":"<ul> <li>How to set up environment variables in Django</li> <li>github</li> <li>Django Environment Variables </li> <li>django-environ with Lists Environment Varibles in .env Files</li> </ul>","tags":["django","environ"]},{"location":"blog/2024/07/05/using-ajax-in-the-django-forms/","title":"Using Ajax in the django forms","text":"","tags":["Python","Drf"]},{"location":"blog/2024/07/05/using-ajax-in-the-django-forms/#using-ajax-in-the-django-forms","title":"Using Ajax in the django forms","text":"","tags":["Python","Drf"]},{"location":"blog/2024/07/05/using-ajax-in-the-django-forms/#old-traditional-methods","title":"Old Traditional Methods","text":"Tip ContactViewShared Contact Template <pre><code># View\nfrom django.views.generic import FormView, TemplateView\nfrom django.urls import reverse_lazy\nfrom django.core.exceptions import ObjectDoesNotExist\nfrom django.utils.decorators import method_decorator\nfrom django.views.decorators.csrf import csrf_protect\nfrom django.core.mail import send_mail\nfrom .forms import ContactForm\nfrom .models import ContactServiceCategory\n\nclass ContactView(FormView):\n    form_class = ContactForm\n    success_url = reverse_lazy('contact:success_url')\n\n    def get_form_kwargs(self):\n        kwargs = super().get_form_kwargs()\n        try:\n            initial_service = ContactServiceCategory.objects.get(id=1)\n        except ObjectDoesNotExist:\n            initial_service = None\n        kwargs['initial'] = {'service': initial_service}\n        return kwargs\n\n    @method_decorator(csrf_protect)\n    def post(self, request, *args, **kwargs):\n        form = self.get_form()\n        if form.is_valid():\n            try:\n                form.save()\n                self.send_mail(form)\n                request.session['success_message'] = 'Your form was submitted successfully!'\n                return self.form_valid(form)\n            except Exception as e:\n                return self.handle_form_error(e)\n        else:\n            print(\"Invalid Form\")\n            return self.form_invalid(form)\n\n    def handle_form_error(self, e):\n        print(\"Error saving form:\", e)\n        return self.form_invalid(self.get_form())\n\n    def send_mail(self, form):\n        subject = 'New Contact Form Submission'\n        recipients = ['bishowthapa33@gmail.com']\n        message = f'Name: {form.cleaned_data[\"name\"]}\\nEmail: {form.cleaned_data[\"email\"]}\\nMessage: {form.cleaned_data[\"message\"]}'\n        sender = form.cleaned_data[\"email\"]\n        send_mail(subject, message, sender, recipients, fail_silently=True)\n\nclass ContactInnerView(TemplateView):\n    template_name = 'contact_us/contact.html'\n\nclass SuccessView(TemplateView):\n    template_name = 'contact_us/success.html'\n\n    def get_context_data(self, **kwargs):\n        context = super().get_context_data(**kwargs)\n        context['success_message'] = self.request.session.get('success_message')\n        return context\n</code></pre> <pre><code>&lt;div class=\"row\"&gt;\n    &lt;h5 class=\"col-md-12 mb-4\" style=\"font-weight: bold; color: #f57d20;\"&gt;Schedule your Meetings&lt;/h5&gt;\n&lt;/div&gt;\n&lt;form action=\"{% url 'contact:contact' %}\" method=\"post\"&gt;\n    {% csrf_token %}\n\n    &lt;div class=\"mb-3\"&gt;\n        {{ form.name.label_tag }}\n        {{ form.name }}\n        {% if form.name.errors %}\n            &lt;div class=\"text-danger\"&gt;\n                {% for error in form.name.errors %}\n                    {{ error }}\n                {% endfor %}\n            &lt;/div&gt;\n        {% endif %}\n    &lt;/div&gt;\n    &lt;div class=\"mb-3\"&gt;\n        {{ form.email.label_tag }}\n        {{ form.email }}\n        {% if form.email.errors %}\n            &lt;div class=\"text-danger\"&gt;\n                {% for error in form.email.errors %}\n                    {{ error }}\n                {% endfor %}\n            &lt;/div&gt;\n        {% endif %}\n    &lt;/div&gt;\n    &lt;div class=\"mb-3\"&gt;\n        {{ form.message.label_tag }}\n        {{ form.message }}\n        {% if form.message.errors %}\n            &lt;div class=\"text-danger\"&gt;\n                {% for error in form.message.errors %}\n                    {{ error }}\n                {% endfor %}\n            &lt;/div&gt;\n        {% endif %}\n    &lt;/div&gt;\n\n    &lt;div class=\"mb-3\"&gt;\n        {{ form.service.label_tag }}\n        {{ form.service }}\n        {% if form.service.errors %}\n        &lt;div class=\"text-danger\"&gt;\n            {% for error in form.service.errors %}\n                {{ error }}\n            {% endfor %}\n        &lt;/div&gt;\n        {% endif %}\n    &lt;/div&gt; \n\n    &lt;script src=\"https://www.google.com/recaptcha/api.js\" async defer&gt;&lt;/script&gt;\n\n    &lt;div class=\"g-recaptcha\" data-sitekey=\"6LezcbspAAAAAL6-lkWnexayFjQ3kK4R4wRixxpY\"&gt;&lt;/div&gt;\n\n    &lt;button type=\"submit\" class=\"btn btn-primary w-100 mt-4\"&gt;Submit&lt;/button&gt;\n&lt;/form&gt;\n\n&lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/select2/4.0.13/js/select2.full.min.js\" integrity=\"sha512-RtZU3AyMVArmHLiW0suEZ9McadTdegwbgtiQl5Qqo9kunkVg1ofwueXD8/8wv3Af8jkME3DDe3yLfR8HSJfT2g==\" crossorigin=\"anonymous\" referrerpolicy=\"no-referrer\"&gt;&lt;/script&gt;\n\n&lt;script&gt;\n    $(document).ready(function() {\n        $('.ispl-form').select2({\n            placeholder: \"Choose a service\",\n            allowClear: true\n        });\n    });\n&lt;/script&gt;\n</code></pre>","tags":["Python","Drf"]},{"location":"blog/2024/07/05/using-ajax-in-the-django-forms/#using-ajax","title":"Using Ajax","text":"<p>If you want to submit the contact form without redirecting to another page and avoid reloading the browser, you can use AJAX to handle the form submission asynchronously. This way, you can stay on the same page and display a success message or update the form accordingly.</p> <p>Here's how you can achieve this using jQuery for the AJAX request:</p>","tags":["Python","Drf"]},{"location":"blog/2024/07/05/using-ajax-in-the-django-forms/#1-update-the-contact-form-template","title":"1. Update the Contact Form Template:","text":"<p>Add an <code>id</code> to your form to easily target it with jQuery. Also, include a div to display the success message.</p> <pre><code>&lt;div class=\"row\"&gt;\n    &lt;h5 class=\"col-md-12 mb-4\" style=\"font-weight: bold; color: #f57d20;\"&gt;Schedule your Meetings&lt;/h5&gt;\n&lt;/div&gt;\n&lt;form id=\"contactForm\" method=\"post\"&gt;\n    {% csrf_token %}\n\n    &lt;div class=\"mb-3\"&gt;\n        {{ form.name.label_tag }}\n        {{ form.name }}\n        {% if form.name.errors %}\n            &lt;div class=\"text-danger\"&gt;\n                {% for error in form.name.errors %}\n                    {{ error }}\n                {% endfor %}\n            &lt;/div&gt;\n        {% endif %}\n    &lt;/div&gt;\n    &lt;div class=\"mb-3\"&gt;\n        {{ form.email.label_tag }}\n        {{ form.email }}\n        {% if form.email.errors %}\n            &lt;div class=\"text-danger\"&gt;\n                {% for error in form.email.errors %}\n                    {{ error }}\n                {% endfor %}\n            &lt;/div&gt;\n        {% endif %}\n    &lt;/div&gt;\n    &lt;div class=\"mb-3\"&gt;\n        {{ form.message.label_tag }}\n        {{ form.message }}\n        {% if form.message.errors %}\n            &lt;div class=\"text-danger\"&gt;\n                {% for error in form.message.errors %}\n                    {{ error }}\n                {% endfor %}\n            &lt;/div&gt;\n        {% endif %}\n    &lt;/div&gt;\n\n    &lt;div class=\"mb-3\"&gt;\n        {{ form.service.label_tag }}\n        {{ form.service }}\n        {% if form.service.errors %}\n        &lt;div class=\"text-danger\"&gt;\n            {% for error in form.service.errors %}\n                {{ error }}\n            {% endfor %}\n        &lt;/div&gt;\n        {% endif %}\n    &lt;/div&gt; \n\n    &lt;script src=\"https://www.google.com/recaptcha/api.js\" async defer&gt;&lt;/script&gt;\n\n    &lt;div class=\"g-recaptcha\" data-sitekey=\"6LezcbspAAAAAL6-lkWnexayFjQ3kK4R4wRixxpY\"&gt;&lt;/div&gt;\n\n    &lt;button type=\"submit\" class=\"btn btn-primary w-100 mt-4\"&gt;Submit&lt;/button&gt;\n&lt;/form&gt;\n\n&lt;div id=\"successMessage\" class=\"alert alert-success mt-3\" style=\"display:none;\"&gt;\n    Your form was submitted successfully!\n&lt;/div&gt;\n\n&lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js\" integrity=\"sha512-894yeEpZTw1gyf9DZ9FZeiG0ct0tNEeR1Aq/wY1VoL5/6n6E0UVx7S9KK1T1WsvS8AwGiJw4nFBE1P4N3ggMBQ==\" crossorigin=\"anonymous\" referrerpolicy=\"no-referrer\"&gt;&lt;/script&gt;\n&lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/select2/4.0.13/js/select2.full.min.js\" integrity=\"sha512-RtZU3AyMVArmHLiW0suEZ9McadTdegwbgtiQl5Qqo9kunkVg1ofwueXD8/8wv3Af8jkME3DDe3yLfR8HSJfT2g==\" crossorigin=\"anonymous\" referrerpolicy=\"no-referrer\"&gt;&lt;/script&gt;\n\n&lt;script&gt;\n    $(document).ready(function() {\n        $('.ispl-form').select2({\n            placeholder: \"Choose a service\",\n            allowClear: true\n        });\n\n        $('#contactForm').on('submit', function(event) {\n            event.preventDefault();\n\n            $.ajax({\n                type: 'POST',\n                url: \"{% url 'contact:contact' %}\",\n                data: $(this).serialize(),\n                success: function(response) {\n                    $('#successMessage').show();\n                    $('#contactForm')[0].reset();\n                },\n                error: function(xhr, status, error) {\n                    console.log(\"Error:\", error);\n                }\n            });\n        });\n    });\n&lt;/script&gt;\n</code></pre>","tags":["Python","Drf"]},{"location":"blog/2024/07/05/using-ajax-in-the-django-forms/#2-update-the-contact-view","title":"2. Update the Contact View:","text":"<p>Ensure the view returns a JSON response for success and error scenarios.</p> <pre><code>from django.http import JsonResponse\n\nclass ContactView(FormView):\n    form_class = ContactForm\n    success_url = reverse_lazy('contact:success_url')\n\n    def get_form_kwargs(self):\n        kwargs = super().get_form_kwargs()\n        try:\n            initial_service = ContactServiceCategory.objects.get(id=1)\n        except ObjectDoesNotExist:\n            initial_service = None\n        kwargs['initial'] = {'service': initial_service}\n        return kwargs\n\n    @method_decorator(csrf_protect)\n    def post(self, request, *args, **kwargs):\n        form = self.get_form()\n        if form.is_valid():\n            try:\n                form.save()\n                self.send_mail(form)\n                request.session['success_message'] = 'Your form was submitted successfully!'\n                return JsonResponse({'message': 'Your form was submitted successfully!'}, status=200)\n            except Exception as e:\n                return self.handle_form_error(e)\n        else:\n            return JsonResponse({'errors': form.errors}, status=400)\n\n    def handle_form_error(self, e):\n        return JsonResponse({'error': str(e)}, status=400)\n\n    def send_mail(self, form):\n        subject = 'New Contact Form Submission'\n        recipients = ['bishowthapa33@gmail.com']\n        message = f'Name: {form.cleaned_data[\"name\"]}\\nEmail: {form.cleaned_data[\"email\"]}\\nMessage: {form.cleaned_data[\"message\"]}'\n        sender = form.cleaned_data[\"email\"]\n        send_mail(subject, message, sender, recipients, fail_silently=True)\n</code></pre>","tags":["Python","Drf"]},{"location":"blog/2024/07/05/using-ajax-in-the-django-forms/#summary-of-adjustments","title":"Summary of Adjustments:","text":"<ul> <li>Added AJAX to handle the form submission asynchronously.</li> <li>Updated the <code>ContactView</code> to return JSON responses.</li> <li>Display a success message on the same page after a successful form submission.</li> </ul> <p>With these adjustments, the form will be submitted without redirecting or reloading the page, and a success message will be displayed on the same page.</p>","tags":["Python","Drf"]},{"location":"blog/2024/07/05/using-ajax-in-the-django-forms/#mail","title":"Mail","text":"","tags":["Python","Drf"]},{"location":"blog/2024/07/05/using-ajax-in-the-django-forms/#sending-the-email","title":"Sending the email:","text":"<pre><code>send_mail(subject, message, sender, recipients, fail_silently=True)\n</code></pre> <ol> <li> <p>This line uses Django\u2019s built-in <code>send_mail</code> function from <code>django.core.mail</code> to send the email.</p> </li> <li> <p>Parameters:</p> <ul> <li>subject: The subject of the email.</li> <li>message: The body of the email.</li> <li>sender: The email address that appears as the sender.</li> <li>recipients: The list of recipient email addresses.</li> <li>fail_silently=True: If set to True, errors will not raise exceptions and will fail silently.</li> </ul> </li> </ol>","tags":["Python","Drf"]},{"location":"blog/2024/07/05/using-ajax-in-the-django-forms/#how-does-it-send-mail","title":"How Does It Send Mail?","text":"<p>The <code>send_mail</code> function from Django\u2019s django.core.mail module is used to send the email. Here\u2019s how it works:</p> <ol> <li> <p>Setup:</p> <p>Django must be configured to send emails. This typically involves setting up email backend settings in your <code>settings.py</code> file. For example:</p> <pre><code>EMAIL_BACKEND = 'django.core.mail.backends.smtp.EmailBackend'\nEMAIL_HOST = 'smtp.gmail.com'\nEMAIL_PORT = 587\nEMAIL_USE_TLS = True\nEMAIL_HOST_USER = 'your-email@gmail.com'\nEMAIL_HOST_PASSWORD = 'your-email-password'\n</code></pre> </li> <li> <p>Sending:</p> <ul> <li> <p>When the <code>send_mail</code> function is called:</p> </li> <li> <p>Django constructs an email message with the provided subject, message body, sender, and recipient list. It then sends the email using the configured email backend (e.g., SMTP server).</p> </li> </ul> </li> <li> <p>Handling Failures:</p> <ul> <li>By setting <code>fail_silently=True</code>, any issues during the sending process (e.g., network issues, incorrect email settings) will not raise an exception. This means the application will not crash due to email sending failures, though it\u2019s often useful to handle such cases more gracefully in production environments.</li> </ul> </li> </ol>","tags":["Python","Drf"]},{"location":"blog/2024/07/05/using-ajax-in-the-django-forms/#reference","title":"Reference","text":"","tags":["Python","Drf"]},{"location":"blog/2024/05/12/simplifying-django-views-with-get_object_or_404/","title":"Simplifying Django Views with get_object_or_404","text":""},{"location":"blog/2024/05/12/simplifying-django-views-with-get_object_or_404/#simplifying-django-views-with-get_object_or_404","title":"Simplifying Django Views with get_object_or_404","text":"<p>In the realm of Django development, building views that retrieve and display specific objects from the database is a common task. However, ensuring that these views gracefully handle scenarios where the requested object does not exist can be a bit cumbersome. This is where Django's <code>get_object_or_404</code> comes to the rescue, offering a simple yet powerful solution.</p>"},{"location":"blog/2024/05/12/simplifying-django-views-with-get_object_or_404/#what-is-get_object_or_404","title":"What is get_object_or_404?","text":"<p><code>get_object_or_404</code> is a shortcut function provided by Django that simplifies the process of retrieving objects from the database and handling the case where the object is not found. It takes a Django model class and any number of keyword arguments representing lookup parameters. If an object matching the provided criteria is found, <code>get_object_or_404</code> returns the object. If not, it raises a 404 error, indicating that the requested resource could not be found.</p>"},{"location":"blog/2024/05/12/simplifying-django-views-with-get_object_or_404/#how-to-use-get_object_or_404","title":"How to Use get_object_or_404","text":"<p>Using <code>get_object_or_404</code> is straightforward. Let's say we have a Django model called Article, and we want to build a view to display the details of a specific article. Here's how we can use <code>get_object_or_404</code> in our view function:</p> Python<pre><code>from django.shortcuts import render, get_object_or_404\nfrom .models import Article\n\ndef article_detail(request, article_id):\n    article = get_object_or_404(Article, pk=article_id)\n    return render(request, 'article_detail.html', {'article': article})\n</code></pre> <p>In this example, <code>get_object_or_404</code> retrieves an Article object based on its primary key (pk) from the database. If the article with the specified primary key does not exist, Django automatically raises a 404 error, and the user is presented with an appropriate error page.</p>"},{"location":"blog/2024/05/12/simplifying-django-views-with-get_object_or_404/#benefits-of-using-get_object_or_404","title":"Benefits of Using <code>get_object_or_404</code>","text":"<ul> <li> <p>Simplicity:</p> <p><code>get_object_or_404</code> simplifies the process of retrieving objects and handling the case of non-existent objects in Django views. It condenses multiple lines of code into a single function call.</p> </li> <li> <p>Readability:</p> <p>By using <code>get_object_or_404</code>, your code becomes more concise and easier to understand. It clearly communicates the intent of retrieving a specific object and handling potential errors.</p> </li> <li> <p>Robustness:</p> <p><code>get_object_or_404</code> ensures that your views gracefully handle scenarios where the requested object is not found, providing a seamless user experience and maintaining the integrity of your web application.</p> </li> </ul> <p>when not to use it?</p> <p>While get_object_or_404 is a convenient shortcut in Django for handling the case where an object is not found in the database, there are scenarios where it might not be the best choice:</p> <ul> <li> <p>API Development:</p> <p>In API development, you might prefer to return a JSON response with an appropriate error message instead of raising a 404 error directly. This gives you more control over the response format and allows you to provide additional information about the error.</p> </li> <li> <p>Custom Error Handling:</p> <p>In some cases, you might want to customize the error handling behavior beyond simply returning a 404 page. For example, you might want to log the error, send an email notification, or redirect the user to a different page based on the context.</p> </li> <li> <p>Soft Deletion:</p> <p>If your application supports soft deletion (marking objects as deleted instead of physically removing them from the database), <code>get_object_or_404</code> might not be suitable. It will raise a 404 error even for soft-deleted objects, which might not be the desired behavior. In such cases, you would need to implement custom logic to handle soft-deleted objects.</p> </li> <li> <p>Performance Considerations:</p> <p>While <code>get_object_or_404</code> is convenient, it always performs a database query, even if the object doesn't exist. In situations where performance is critical, such as high-traffic pages, it might be more efficient to check for the existence of the object explicitly and handle the case accordingly.</p> </li> <li> <p>Complex Querying:</p> <p>When querying objects based on complex criteria or relationships, get_object_or_404 might not be flexible enough. In such cases, you might need to use Django's queryset methods to retrieve the object and handle the case where it doesn't exist separately.</p> </li> </ul>"},{"location":"blog/2024/05/12/simplifying-django-views-with-get_object_or_404/#conclusion","title":"Conclusion","text":"<p>In conclusion, <code>get_object_or_404</code> is a valuable tool in the Django developer's arsenal, offering a convenient way to retrieve objects from the database and handle the case of non-existent objects in views. By leveraging this simple yet powerful function, you can streamline your Django development workflow and build more robust and user-friendly web applications.</p>"},{"location":"blog/2024/05/14/difference-between-django-httprequest-vs-requests-package/","title":"Difference between Django HttpRequest vs requests package","text":""},{"location":"blog/2024/05/14/difference-between-django-httprequest-vs-requests-package/#difference-between-django-httprequest-vs-requests-package","title":"Difference between Django HttpRequest vs requests package","text":"<p>The HttpRequest object in Django and the requests package serve different purposes and operate at different levels within a web application:</p>"},{"location":"blog/2024/05/14/difference-between-django-httprequest-vs-requests-package/#djangos-httprequest","title":"Django's HttpRequest:","text":"<p>Tip</p> <ul> <li> <p>Context:     The HttpRequest object represents an incoming HTTP request within a Django application.</p> </li> <li> <p>Usage:      It is used within Django views to access information about the incoming request, such as headers, method (GET, POST, etc.), GET and  POST - parameters, cookies, session data, and more.</p> </li> <li> <p>Scope:     It operates within the context of a single Django application and is primarily used for handling requests and generating responses - within that application.</p> </li> <li> <p>Server-Side:     HttpRequest is part of Django's server-side functionality for processing incoming requests and generating responses. It is used to build web applications using the Django framework.</p> </li> </ul>"},{"location":"blog/2024/05/14/difference-between-django-httprequest-vs-requests-package/#requests-package","title":"requests package:","text":"bash<pre><code># Python HTTP for Humans.\npip install requests\n\n# django-request is a statistics module for django\npip install django-request\n</code></pre> <p>Tip</p> <ul> <li> <p>Context:     The requests package is a third-party Python library used for making HTTP requests from Python scripts or applications.</p> </li> <li> <p>Usage:     It is used to send HTTP requests to external web services or APIs and handle the corresponding responses. It provides a simple and elegant API for making various types of HTTP requests (GET, POST, PUT, DELETE, etc.), setting request headers, passing parameters, handling response content, and more.</p> </li> <li> <p>Scope:     It can be used in any Python environment, not just within Django applications. You can use the requests package in standalone scripts, command-line utilities, web scrapers, and other Python applications to interact with web services and fetch data.</p> </li> <li> <p>Client-Side:     The requests package is typically used for client-side functionality, allowing Python applications to interact with web services and consume data from external sources.</p> </li> </ul>"},{"location":"blog/2024/05/19/django-in-production/","title":"Django in production","text":"","tags":["Django","Production"]},{"location":"blog/2024/05/19/django-in-production/#django-in-production","title":"Django in production","text":"<p>Deploying a Django project with multiple settings files, such as <code>base.py</code>, <code>local.py</code>, and <code>prod.py</code>, to a shared cPanel environment involves several steps. Below is a step-by-step guide to help you with this process:</p> <ol> <li> <p>Prepare Your Django Project for Deployment:</p> <ul> <li>Ensure your <code>prod.py</code> settings file is properly configured for a production environment. This includes setting <code>DEBUG</code> to <code>False</code>,configuring the allowed hosts, and setting up the database, static files, and other production-specific settings.</li> </ul> <p>Tip</p> prod.py<pre><code>from .base import *\n\nDEBUG = False\nALLOWED_HOSTS = ['yourdomain.com']\n\n# Database\nDATABASES = {\n    'default': {\n        'ENGINE': 'django.db.backends.postgresql',\n        'NAME': 'your_db_name',\n        'USER': 'your_db_user',\n        'PASSWORD': 'your_db_password',\n        'HOST': 'localhost',\n        'PORT': '',\n    }\n}\n\n# Static files (CSS, JavaScript, Images)\nSTATIC_URL = '/static/'\nSTATIC_ROOT = os.path.join(BASE_DIR, 'static')\n\n# Media files\nMEDIA_URL = '/media/'\nMEDIA_ROOT = os.path.join(BASE_DIR, 'media')\n</code></pre> </li> <li> <p>Prepare Your Environment:</p> <ul> <li>Ensure you have Python installed on your cPanel. You might need to use the Python Selector or Setup Python App feature if available.</li> </ul> </li> <li> <p>Upload Your Django Project:</p> <ul> <li>Use the cPanel File Manager or an FTP client to upload your Django project files to your hosting account. Typically, you'll place these in the <code>public_html</code> directory or a subdirectory.</li> </ul> </li> <li> <p>Install Dependencies:</p> <ul> <li>Use SSH to access your cPanel account or use the cPanel terminal.</li> <li>Navigate to your project directory and create a virtual environment:</li> </ul> <p>Tip</p> bash<pre><code>python3 -m venv myenv\nsource myenv/bin/activate\n</code></pre> <ul> <li>Install your project dependencies:</li> </ul> <p>Tip</p> bash<pre><code>pip install -r requirements.txt\n</code></pre> </li> <li> <p>Configure WSGI:</p> <ul> <li>Ensure your project has a wsgi.py file configured correctly. It should look something like this:</li> </ul> <p>Tip</p> Python<pre><code>import os\nfrom django.core.wsgi import get_wsgi_application\n\nos.environ.setdefault('DJANGO_SETTINGS_MODULE', 'myproject.settings.prod')\n\napplication = get_wsgi_application()\n</code></pre> </li> <li> <p>Setup the cPanel Application:</p> <ul> <li>In cPanel, go to the <code>Setup Python App</code> section.</li> <li>Create a new application and point it to your project\u2019s directory and virtual environment.</li> <li>Set the <code>Application startup file</code> to the location of your <code>wsgi.py</code> file and the <code>Application entry point</code> to <code>application</code>.</li> <li>Set the <code>Environment variables</code> to include DJANGO_SETTINGS_MODULE=myproject.settings.prod.</li> </ul> </li> <li> <p>Configure Static and Media Files:</p> <ul> <li>Ensure your <code>prod.py</code> settings handle static and media files correctly.</li> <li>In cPanel, use the <code>File Manager</code> to create the <code>static</code> and <code>media</code> directories if they don't exist.</li> <li>Collect static files by running:</li> </ul> <p>Tip</p> bash<pre><code>python manage.py collectstatic\n</code></pre> </li> <li> <p>Configure Database:</p> <ul> <li>If you are using a PostgreSQL or MySQL database, ensure that it is created in cPanel.</li> <li>Update your <code>prod.py</code> settings with the correct database credentials.</li> </ul> </li> <li> <p>Run Migrations:</p> <ul> <li>Apply the database migrations by running:</li> </ul> <p>Tip</p> bash<pre><code>python manage.py migrate\n</code></pre> </li> <li> <p>Security and Permissions:</p> <ul> <li>Ensure that your media and static files have the correct permissions.</li> <li>Secure your database credentials and secret key.</li> </ul> </li> <li> <p>Testing:</p> <ul> <li>Access your domain to verify the deployment. Debug any issues that arise by checking the cPanel error logs and your application logs.</li> </ul> </li> </ol> <p>By following these steps, you should be able to successfully deploy your Django project on a shared cPanel hosting environment with the production settings from <code>prod.py</code>.</p>","tags":["Django","Production"]},{"location":"blog/2024/05/19/django-in-production/#reference","title":"Reference","text":"<ul> <li>How To Deploy Django Application In CPANEL 2022 | SIMPLE :youtube vid</li> </ul>","tags":["Django","Production"]},{"location":"blog/2024/05/17/internationalization-and-localization-in-django-a-quick-guide/","title":"Internationalization and Localization in Django: A Quick Guide","text":"","tags":["Django"]},{"location":"blog/2024/05/17/internationalization-and-localization-in-django-a-quick-guide/#internationalization-and-localization-in-django-a-quick-guide","title":"Internationalization and Localization in Django: A Quick Guide","text":"<p>In today\u2019s globalized world, reaching a diverse audience means making your web application accessible in multiple languages. Django, a popular web framework, provides robust support for internationalization (i18n) and localization (l10n). In this blog, we\u2019ll explore how to set up your Django project to support multiple languages and adapt it to different cultural contexts.</p>","tags":["Django"]},{"location":"blog/2024/05/17/internationalization-and-localization-in-django-a-quick-guide/#what-is-internationalization-i18n-and-localization-l10n","title":"What is Internationalization (<code>i18n</code>) and Localization (l10n)?","text":"<p>Internationalization (i18n) refers to designing your application in a way that makes it easy to adapt to various languages and regions. This involves preparing your codebase to handle different languages without requiring major changes.</p> <p>Localization (l10n) is the process of adapting your application to a specific locale. This includes translating text and adjusting formats (dates, currency, etc.) to meet regional requirements.</p> <p>Danger</p> <p>To resolve this issue, you need to install the GNU <code>gettext</code> package. Here are the instructions for installing it on different operating systems:</p> UbuntuFor Windows <pre><code>sudo apt-get update\nsudo apt-get install gettext\n</code></pre> <pre><code>choco install gettext\n</code></pre> <p>After Installation:</p> <p>After installing <code>gettext</code>, you should be able to run the <code>makemessages</code> command without encountering the msguniq error.</p> <pre><code>django-admin makemessages -l es\n</code></pre>","tags":["Django"]},{"location":"blog/2024/05/17/internationalization-and-localization-in-django-a-quick-guide/#steps-to-implement-i18n-and-l10n-in-django","title":"Steps to Implement i18n and l10n in Django","text":"","tags":["Django"]},{"location":"blog/2024/05/17/internationalization-and-localization-in-django-a-quick-guide/#step-1-enable-internationalization","title":"Step 1: Enable Internationalization","text":"<p>First, enable internationalization in your Django project\u2019s <code>settings.py</code>:</p> <p>settings.py</p> <pre><code>LANGUAGE_CODE = 'en-us'  # Default language\nUSE_I18N = True  # Enable translation system\nUSE_L10N = True  # Enable localized formatting\nUSE_TZ = True  # Enable timezone support\n\n# Supported languages\nLANGUAGES = [\n    ('en', 'English'),\n    ('es', 'Spanish'),\n    ('fr', 'French'),\n    # Add more languages as needed\n]\n\n# Path to locale directory\nLOCALE_PATHS = [\n    os.path.join(BASE_DIR, 'locale'),\n]\n</code></pre>","tags":["Django"]},{"location":"blog/2024/05/17/internationalization-and-localization-in-django-a-quick-guide/#step-2-mark-text-for-translation","title":"Step 2: Mark Text for Translation","text":"<p>Mark the text you want to translate in your templates and Python code.</p> <p>In templates:</p> bash<pre><code>{% load i18n %}\n&lt;p&gt;{% trans \"Hello, world!\" %}&lt;/p&gt;\n</code></pre> <p>In Python code:</p> python<pre><code>from django.utils.translation import gettext as _\n\ndef my_view(request):\n    output = _(\"Welcome to my site.\")\n    return HttpResponse(output)\n</code></pre>","tags":["Django"]},{"location":"blog/2024/05/17/internationalization-and-localization-in-django-a-quick-guide/#step-3-create-and-edit-message-files","title":"Step 3: Create and Edit Message Files","text":"<p>Generate message files using the makemessages command:</p> bash<pre><code>django-admin makemessages -l es  # For Spanish\ndjango-admin makemessages -l fr  # For French\n</code></pre> <p>Edit the generated <code>.po</code> files in the <code>locale</code> directory to provide translations:</p> bash<pre><code>#: path/to/your/file.py:line_number\nmsgid \"Welcome to my site.\"\nmsgstr \"Bienvenido a mi sitio.\"\n</code></pre> <p>Compile the message files with:</p> bash<pre><code>django-admin compilemessages\n</code></pre>","tags":["Django"]},{"location":"blog/2024/05/17/internationalization-and-localization-in-django-a-quick-guide/#step-4-switching-languages","title":"Step 4: Switching Languages","text":"<p>Ensure LocaleMiddleware is enabled in your MIDDLEWARE setting:</p> python<pre><code>MIDDLEWARE = [\n    'django.middleware.security.SecurityMiddleware',\n    'django.contrib.sessions.middleware.SessionMiddleware',\n    'django.middleware.common.CommonMiddleware',\n    'django.middleware.locale.LocaleMiddleware',  # Enable LocaleMiddleware\n    'django.middleware.csrf.CsrfViewMiddleware',\n    'django.contrib.auth.middleware.AuthenticationMiddleware',\n    'django.contrib.messages.middleware.MessageMiddleware',\n    'django.middleware.clickjacking.XFrameOptionsMiddleware',\n]\n</code></pre> <p>Manage language preferences in views or templates. Here\u2019s an example of setting the language via a URL parameter in a view:</p> Python<pre><code>from django.utils import translation\n\ndef set_language(request):\n    user_language = 'fr'\n    translation.activate(user_language)\n    request.session[translation.LANGUAGE_SESSION_KEY] = user_language\n    return redirect('/')\n</code></pre> <p>And in your template, provide a language selection form:</p> html<pre><code>&lt;form action=\"{% url 'set_language' %}\" method=\"post\"&gt;\n  {% csrf_token %}\n  &lt;input name=\"next\" type=\"hidden\" value=\"{{ redirect_to }}\"&gt;\n  &lt;select name=\"language\"&gt;\n    {% for lang in LANGUAGES %}\n      &lt;option value=\"{{ lang.0 }}\"&gt;{{ lang.1 }}&lt;/option&gt;\n    {% endfor %}\n  &lt;/select&gt;\n  &lt;input type=\"submit\" value=\"Go\"&gt;\n&lt;/form&gt;\n</code></pre>","tags":["Django"]},{"location":"blog/2024/05/17/internationalization-and-localization-in-django-a-quick-guide/#conclusion","title":"Conclusion","text":"<p>Internationalizing and localizing your Django application opens it up to a global audience, making it more accessible and user-friendly. By following these steps, you can efficiently manage multiple languages and ensure that your application meets the cultural and linguistic needs of its users. Embrace the world of i18n and l10n in Django and take your web applications to the next level!</p>","tags":["Django"]},{"location":"blog/2024/05/17/internationalization-and-localization-in-django-a-quick-guide/#reference","title":"Reference","text":"<ul> <li>a quick guide to django i18n</li> </ul>","tags":["Django"]},{"location":"blog/2024/04/18/django-images-not-showing-in-the-cpanel-or-shared-hosting/","title":"Django Images not showing in the Cpanel or Shared Hosting","text":"","tags":["Django"]},{"location":"blog/2024/04/18/django-images-not-showing-in-the-cpanel-or-shared-hosting/#django-images-not-showing-in-the-cpanel-or-shared-hosting","title":"Django Images not showing in the Cpanel or Shared Hosting","text":"<p>Using the re_path and serve combination in a URL pattern to serve media files (<code>MEDIA_ROOT</code>) directly in a production environment is a common approach, especially in scenarios where you might not have direct access to configure a web server like Nginx or Apache. </p> <p>While it's not the most optimal solution for high-traffic production environments, it can work effectively in smaller-scale deployments or situations where simplicity is preferred.</p> <p>However, it's important to be aware of the limitations and potential drawbacks:</p> <ul> <li>Performance</li> <li>Security</li> <li>Scalability</li> <li>Maintenance</li> </ul> <p>Success</p> settings.py<pre><code>from django.urls import path, include, re_path\n\nurlpatterns = [\n    ...\n    re_path(r'^media/(?P&lt;path&gt;.*)$', serve, {'document_root': settings.MEDIA_ROOT}),\n    ...\n]\n</code></pre> <p>In summary, while serving media files directly from Django using re_path and serve can be a convenient solution in certain scenarios, it's essential to consider the trade-offs in terms of performance, security, scalability, and maintenance. </p> <p>Evaluate your specific requirements and constraints to determine whether this approach is suitable for your production environment. If scalability and performance are critical factors, consider using a dedicated web server or alternative solutions for serving media files.</p>","tags":["Django"]},{"location":"blog/2024/04/18/django-images-not-showing-in-the-cpanel-or-shared-hosting/#reference","title":"Reference","text":"<ul> <li>Django Staticfiles and Media not showing when DEBUG = False [Fixed]</li> <li>Django Staticfiles and Media not showing when DEBUG = False - Fixed 100%: youtube</li> <li>Why you shouldn't \u274c\u274c deploy your django application on shared hosting or cpanel ??</li> </ul>","tags":["Django"]},{"location":"blog/2024/05/14/django-model-inheritance/","title":"Django Model Inheritance","text":""},{"location":"blog/2024/05/14/django-model-inheritance/#django-model-inheritance","title":"Django Model Inheritance","text":"<p>Polymorphism is the provision of a single interface to entities of different types. You need a versatile data model that allows you to store diverse content that is accessible through a single interface.</p>"},{"location":"blog/2024/05/14/django-model-inheritance/#using-model-inheritance","title":"Using model inheritance","text":"<p>Django supports model inheritance. It works in a similar way to standard class inheritance in Python. Django offers the following three options to use model inheritance:</p> <ol> <li> <p>Abstract models:</p> <p>Useful when you want to put some common information into several models.</p> </li> <li> <p>Multi-table model inheritance:</p> <p>Applicable when each model in the hierarchy is considered a complete model by itself.</p> </li> <li> <p>Proxy models:</p> <p>Useful when you need to change the behavior of a model, for example, by including additional methods, changing the default manager, or using different meta options.</p> </li> </ol> <p>Let\u2019s take a closer look at each of them.</p> <p>Example</p> Abstract modelsMulti-table model inheritanceProxy models <p>An abstract model is a base class in which you define the fields you want to include in all child models. Django doesn\u2019t create any database tables for abstract models. A database table is created for each child model, including the fields inherited from the abstract class and the ones defined in the child model.</p> <p>To mark a model as abstract, you need to include <code>abstract=True</code> in its Meta class. Django will recognize that it is an abstract model and will not create a database table for it. To create child models, you just need to subclass the abstract model.</p> Python<pre><code>from django.db import models\n\nclass BaseContent(models.Model):\n    title = models.CharField(max_length=100)\n    created = models.DateTimeField(auto_now_add=True)\n\n    class Meta:\n        abstract = True\n\nclass Text(BaseContent):\n    body = models.TextField()\n</code></pre> <p>In this case, Django would create a table for the Text model only, including the title, created, and body fields.</p> <p>In multi-table inheritance, each model corresponds to a database table. Django creates a OneToOneField field for the relationship between the child model and its parent model. </p> <p>To use multi-table inheritance, you have to subclass an existing model. Django will create a database table for both the original model and the sub-model. The following example shows multi-table inheritance:</p> Python<pre><code>from django.db import models\n\nclass BaseContent(models.Model):\n    title = models.CharField(max_length=100)\n    created = models.DateTimeField(auto_now_add=True)\n\nclass Text(BaseContent):\n    body = models.TextField()\n</code></pre> <p>Django will include an automatically generated OneToOneField field in the Text model and create a database table for each model.</p> <p>A proxy model changes the behavior of a model. Both models operate on the database table of the original model. To create a proxy model, add <code>proxy=True</code> to the Meta class of the model. The following example illustrates how to create a proxy model:</p> Python<pre><code>from django.db import models\nfrom django.utils import timezone\n\nclass BaseContent(models.Model):\n    title = models.CharField(max_length=100)\n    created = models.DateTimeField(auto_now_add=True)\n\nclass OrderedContent(BaseContent):\n    class Meta:\n        proxy = True\n        ordering = ['created']\n\n    def created_delta(self):\n        return timezone.now() - self.created\n</code></pre> <p>Here, you define an OrderedContent model that is a proxy model for the Content model. This model provides a default ordering for QuerySets and an additional <code>created_delta()</code> method. Both models, Content and OrderedContent, operate on the same database table, and objects are accessible via the ORM through either model.</p>"},{"location":"blog/2024/05/14/django-model-inheritance/#creating-the-content-models","title":"Creating the Content models","text":"<p>The Content model of your courses application contains a generic relation to associate different types of content with it. You will create a different model for each type of content. All Content models will have some fields in common and additional fields to store custom data. You are going to create an abstract model that provides the common fields for all Content models.</p> <p>Edit the <code>models.py</code> file of the courses application and add the following code to it:</p> <p>Note</p> models.py<pre><code>from django.db import models\nfrom django.contrib.auth.models import User\n\nclass ItemBase(models.Model):\n    owner = models.ForeignKey(User, related_name='%(class)s_related', on_delete=models.CASCADE)\n    title = models.CharField(max_length=250)\n    created = models.DateTimeField(auto_now_add=True)\n    updated = models.DateTimeField(auto_now=True)\n\n    class Meta:\n        abstract = True\n\n        def __str__(self):\n            return self.title\n\nclass Text(ItemBase):\n    content = models.TextField()\n\nclass File(ItemBase):\n    file = models.FileField(upload_to='files')\n\nclass Image(ItemBase):\n    file = models.FileField(upload_to='images')\n\nclass Video(ItemBase):\n    url = models.URLField()\n</code></pre>"},{"location":"blog/2024/05/14/django-model-inheritance/#reference","title":"Reference","text":"<ul> <li>Django 4 by Example  by Antonio Mel\u00e9: pg 525</li> </ul>"},{"location":"blog/2024/04/20/splitting-django-modelspy-into-multiple-files/","title":"Splitting django models.py into multiple files","text":"","tags":["Python","Django"]},{"location":"blog/2024/04/20/splitting-django-modelspy-into-multiple-files/#splitting-django-modelspy-into-multiple-files","title":"Splitting django <code>models.py</code> into multiple files","text":"<p>M is bigger than V and C in Django</p> <p>In Django, models are classes that provide an object-oriented way of dealing with databases. Typically, each class refers to a database table and each attribute refers to a database column. You can make queries to these tables using an automatically generated API.</p>","tags":["Python","Django"]},{"location":"blog/2024/04/20/splitting-django-modelspy-into-multiple-files/#splitting-modelspy-into-multiple-files","title":"Splitting models.py into multiple files","text":"<p>Like most components of Django, a large <code>models.py</code> file can be split up into multiple files within a package. A package is implemented as a directory, which can contain multiple files, one of which must be a specially named file called <code>__init__.py</code>. This file can be empty, but should exist.</p> <p>All definitions that can be exposed at package level must be defined in <code>__init__.py</code> with global scope. For example, if we split models.py into individual classes, in corresponding files inside the models subdirectory such as <code>postable.py</code>, <code>post.py</code>, and <code>comment.py</code>, then the directory structure would look as follows:</p> <pre><code>models/\n\u251c\u2500\u2500 comment.py\n\u251c\u2500\u2500 __init__.py\n\u251c\u2500\u2500 postable.py\n\u2514\u2500\u2500 post.py\n</code></pre> <p>To ensure that all the models are imported correctly, <code>__init__.py</code>  should have the following lines.</p> <pre><code>from postable import Postable\nfrom post import Post\nfrom comment import Comment\n</code></pre> <p>Now you can import <code>models.Post</code> as previously.</p> <p>Any other code in the <code>__init__.py</code> file will be run when the package is imported. Hence, it is the ideal place for any package-level initialization code.</p>","tags":["Python","Django"]},{"location":"blog/2024/04/20/splitting-django-modelspy-into-multiple-files/#reference","title":"Reference","text":"<ul> <li> <p>Django Design Patterns and Best Practices  by Arun Ravindran : Second Edition - pg 39</p> </li> <li> <p>Django refactoring \u2014 how to split admin.py and models.py in 3 steps</p> </li> <li>Divide Models.py into smaller parts</li> </ul>","tags":["Python","Django"]},{"location":"blog/2024/05/09/django-admin-forms-with-formfield_overrides/","title":"Django Admin Forms with formfield_overrides","text":"","tags":["Python","Django"]},{"location":"blog/2024/05/09/django-admin-forms-with-formfield_overrides/#django-admin-forms-with-formfield_overrides","title":"Django Admin Forms with formfield_overrides","text":"<p><code>formfield_overrides</code> is a nifty attribute available in Django's <code>admin.ModelAdmin</code> class that allows developers to customize the form fields used in the admin interface for specific model fields. This feature enables you to enhance the user experience, integrate third-party widgets, and streamline data entry without the need for extensive customizations.</p> <pre><code>from django.contrib import admin\nfrom django.db import models\nfrom myapp.models import Article\n\nclass ArticleAdmin(admin.ModelAdmin):\n    formfield_overrides = {\n        models.TextField: {'widget': TinyMCE},\n    }\n\nadmin.site.register(Article, ArticleAdmin)\n</code></pre> <p>In this example, we've overridden the form field for TextField model fields to use the TinyMCE widget. Now, whenever administrators access the content field in the admin interface, they'll be greeted with a feature-rich editor, allowing them to format and style the article content effortlessly.</p>","tags":["Python","Django"]},{"location":"blog/2024/05/09/django-admin-forms-with-formfield_overrides/#lets-demonstrate-both-approaches-using-an-example","title":"Let's demonstrate both approaches using an example:","text":"<p>Using HTMLField directly from a third-party package like <code>tinymce.models</code> in your model has a similar effect to using <code>formfield_overrides</code> in the admin. However, there are some differences in how they work and their implications:</p>","tags":["Python","Django"]},{"location":"blog/2024/05/09/django-admin-forms-with-formfield_overrides/#1-directly-using-htmlfield-in-the-model","title":"1. Directly Using HTMLField in the Model:","text":"<ul> <li>This approach directly modifies the model field itself. Any form using this model will automatically render the content field using the specified HTML editor, in this case, TinyMCE.</li> <li>It affects all forms and views that use the NewsItem model, not just the admin interface. So if you have forms outside the admin that use the content field, they will also render with the HTML editor.</li> <li>It couples the model tightly with the specific HTML editor implementation. If you later decide to switch to a different HTML editor or remove it altogether, you'll need to update the model field definition and potentially refactor any related code.</li> </ul> models.py<pre><code>from django.db import models\nfrom tinymce.models import HTMLField\n\nclass NewsItem(models.Model):\n    title = models.CharField(max_length=120)\n    content = HTMLField()\n</code></pre> <p>Note</p> <p>In this approach, we're directly using HTMLField from tinymce.models as the field type for the content field in the NewsItem model. This means that whenever this model is used in a form, whether in the admin or elsewhere in your application, the content field will render with the TinyMCE HTML editor.</p>","tags":["Python","Django"]},{"location":"blog/2024/05/09/django-admin-forms-with-formfield_overrides/#2-using-formfield_overrides-in-the-admin","title":"2. Using formfield_overrides in the Admin:","text":"<ul> <li>This approach provides more flexibility and separation of concerns. It allows you to customize the form field used in the admin interface without directly modifying the model field.</li> <li>It only affects the admin interface. Other forms and views using the same model will continue to use the default form field unless explicitly overridden.</li> <li>It provides a cleaner separation between data models and presentation concerns. The model definition remains focused on data structure, while the admin customization is handled separately.</li> </ul> admin.py<pre><code>from django.contrib import admin\nfrom django.db import models\nfrom myapp.models import NewsItem\nfrom tinymce.widgets import TinyMCE\n\nclass NewsItemAdmin(admin.ModelAdmin):\n    formfield_overrides = {\n        models.TextField: {'widget': TinyMCE()},\n    }\n\nadmin.site.register(NewsItem, NewsItemAdmin)\n</code></pre> <p>Note</p> <p>In this approach, we're using formfield_overrides within the NewsItemAdmin class to specify that any TextField form fields in the admin interface should use the TinyMCE widget. This means that only in the admin interface will the content field render with the TinyMCE HTML editor. Outside of the admin, such as in custom forms or views, the default behavior of rendering a text input field for TextField will be preserved.</p>","tags":["Python","Django"]},{"location":"blog/2024/05/09/django-admin-forms-with-formfield_overrides/#summary","title":"Summary","text":"<p>Tip</p> <ul> <li>Directly Using HTMLField in the Model: Simple and straightforward, but affects all forms and views using the model, including those outside the admin.</li> <li>Using <code>formfield_overrides</code> in the Admin: Provides more flexibility and separation of concerns, allowing customization specifically for the admin interface without affecting other parts of the application.</li> </ul> <p>Choose the approach that best fits your project's requirements, considering factors such as reusability, maintainability, and the need for customization in different parts of your application. </p>","tags":["Python","Django"]},{"location":"blog/2024/05/09/django-admin-forms-with-formfield_overrides/#reference","title":"Reference","text":"","tags":["Python","Django"]},{"location":"blog/2024/05/08/customizing-how-models-are-displayed/","title":"Customizing how models are displayed","text":"","tags":["Python","Django"]},{"location":"blog/2024/05/08/customizing-how-models-are-displayed/#customizing-how-models-are-displayed","title":"Customizing how models are displayed","text":"<p>In Django, ModelAdmin is a class used in the Django admin interface to customize how models are displayed and interacted with. It allows you to specify various attributes and methods to control the behavior and appearance of models in the admin interface. </p> <p>Now, we will take a look at how to customize the administration site.</p> admin.py<pre><code>from django.contrib import admin\nfrom .models import Post\n\n@admin.register(Post)\nclass PostAdmin(admin.ModelAdmin):\n    list_display = ['title', 'slug', 'author', 'publish', 'status']\n    list_filter = ['status', 'created', 'publish', 'author']\n    search_fields = ['title', 'body']\n    prepopulated_fields = {'slug': ('title',)}\n    raw_id_fields = ['author']\n    date_hierarchy = 'publish'\n    ordering = ['status', 'publish']\n</code></pre>","tags":["Python","Django"]},{"location":"blog/2024/05/08/customizing-how-models-are-displayed/#understanding-modeladmin","title":"Understanding ModelAdmin","text":"<p>The ModelAdmin class serves as a bridge between Django models and the admin interface. By defining a ModelAdmin class for each model, developers gain fine-grained control over how data is presented and manipulated in the admin interface.</p> <p>Here are some common attributes used in ModelAdmin:</p> <p>Note</p> most usedall attribute <ol> <li>list_display: Specifies which fields should be displayed as columns in the list view of the admin interface.</li> <li>list_filter: Enables filtering of data based on specified fields, providing users with options to refine the displayed records.</li> <li>search_fields: Allows users to search for specific records within the admin interface, typically by specifying relevant field names.</li> <li>readonly_fields: Specifies fields that should be read-only in the admin interface, preventing users from modifying them.</li> <li>actions: Defines custom actions that can be performed on selected items in the admin interface, such as deleting multiple records at once.</li> <li>fieldsets: Organizes fields into sections in the detail view for improved readability and organization.</li> <li>list_editable: Specifies which fields can be edited directly from the list view, providing a convenient way to update multiple records at once.</li> <li>list_display_links: Specifies which fields should link to the change view from the list view, allowing users to quickly navigate to detailed. information.</li> <li>list_per_page: Sets the number of items displayed per page in the list view, allowing developers to control pagination.</li> <li>ordering: Defines the default ordering of records in the admin interface, typically based on one or more fields.</li> </ol> <ol> <li>list_display: A tuple or list of model field names that should be displayed as columns in the model's list view in the admin interface.</li> <li>list_filter: A tuple or list of field names that should be used as filters in the list view.</li> <li>search_fields: A tuple or list of field names that should be searchable in the admin interface.</li> <li>list_editable: A tuple or list of field names that can be edited directly from the list view.</li> <li>list_display_links: A tuple or list of field names that should link to the change view from the list view.</li> <li>list_per_page: An integer specifying the number of items displayed per page in the list view.</li> <li>list_select_related: A boolean specifying whether to use select_related() in the queryset for the list view.</li> <li>ordering: A tuple or list of field names used to order the queryset in the admin interface.</li> <li>fields: A tuple or list of field names to be displayed in the detail view of the model.</li> <li>fieldsets: A list of two-tuples, where each two-tuple represents a section of fields in the detail view.</li> <li>readonly_fields: A tuple or list of field names that should be read-only in the admin interface.</li> <li>date_hierarchy: A string representing the name of a DateField or DateTimeField used to create a date-based drilldown navigation in the admin interface.</li> <li>prepopulated_fields: A dictionary specifying fields whose values are automatically set based on other fields.</li> <li>actions: A list of custom actions that can be performed on selected items in the admin interface.</li> <li>filter_horizontal and filter_vertical: A tuple or list of field names used to specify ManyToManyField fields displayed as horizontal or vertical filter widgets, respectively.</li> </ol> <p>These are just a few of the most commonly used attributes of the ModelAdmin class. Depending on your needs, you may also override methods such as get_queryset(), formfield_for_foreignkey(), get_form() etc., to further customize the behavior of your model in the admin interface.</p>","tags":["Python","Django"]},{"location":"blog/2024/05/08/customizing-how-models-are-displayed/#reference","title":"Reference","text":"<ul> <li>Django 4 By Example Fourth Edition by Antonio Mel\u00e9:pg-28</li> </ul>","tags":["Python","Django"]},{"location":"blog/2024/06/25/django-queryset/","title":"Django QuerySet","text":"","tags":["django"]},{"location":"blog/2024/06/25/django-queryset/#django-queryset","title":"Django QuerySet","text":"<ul> <li>A QuerySet is a collection of data from a database.</li> <li>A QuerySet is built up as a list of objects.</li> <li>QuerySets makes it easier to get the data you actually need, by allowing you to filter and order the data at an early stage.</li> </ul> <p>In this tutorial we will be querying data from the Member table</p> <p>Tip</p> QuerySet GetQuerySet FilterQuerySet Order By","tags":["django"]},{"location":"blog/2024/06/25/django-queryset/#reference","title":"Reference","text":"<ul> <li>Django Queryset</li> </ul>","tags":["django"]},{"location":"blog/2024/05/12/understanding-slugify-and-slugfield-in-django/","title":"Understanding Slugify and SlugField in Django","text":""},{"location":"blog/2024/05/12/understanding-slugify-and-slugfield-in-django/#understanding-slugify-and-slugfield-in-django","title":"Understanding Slugify and SlugField in Django","text":"<p>In the world of web development with Django, creating clean and SEO-friendly URLs is crucial for enhancing user experience and search engine visibility. Two essential tools in achieving this are slugify and SlugField. Let's delve into what they are and how they play their roles in Django applications.</p>"},{"location":"blog/2024/05/12/understanding-slugify-and-slugfield-in-django/#slugify-generating-url-friendly-strings","title":"Slugify: Generating URL-Friendly Strings","text":"<p>Imagine you have user-generated content or dynamic data that you want to incorporate into URLs. This is where <code>slugify</code> steps in. It's a handy utility function provided by Django that transforms any string into a URL-friendly format. By removing special characters, spaces, and converting text to lowercase, <code>slugify</code> ensures that your URLs are clean, readable, and devoid of any funky characters that might cause issues.</p> python<pre><code>from django.utils.text import slugify\n\ntitle = \"Hello World, How are you?\"\nslug = slugify(title)\n# Output: \"hello-world-how-are-you\"\n</code></pre>"},{"location":"blog/2024/05/12/understanding-slugify-and-slugfield-in-django/#slugfield-storing-slugs-in-models","title":"SlugField: Storing Slugs in Models","text":"<p>Now, let's say you want to store these clean, URL-friendly strings in your database. That's where <code>SlugField</code> comes into play. In your Django model definitions, you can specify a <code>SlugField</code> to hold these slugs directly. Django takes care of generating the slug based on other fields in the model whenever an instance is created or updated. Plus, SlugField can enforce uniqueness constraints, ensuring that each slug is distinct within its scope.</p> Python<pre><code>from django.db import models\n\nclass MyModel(models.Model):\n    title = models.CharField(max_length=100)\n    slug = models.SlugField(unique=True)\n\n    def save(self, *args, **kwargs):\n        if not self.slug:\n            self.slug = slugify(self.title)\n        super().save(*args, **kwargs)\n</code></pre>"},{"location":"blog/2024/05/12/understanding-slugify-and-slugfield-in-django/#combining-slugify-and-slugfield","title":"Combining <code>Slugify</code> and <code>SlugField</code>","text":"<p>In practice, slugify and SlugField often work hand in hand. You use slugify to generate initial slug values from user input or dynamic data, and then store these slugs persistently using SlugField in your database models. This combination ensures that your URLs are both dynamic and clean, adapting to changing content while remaining SEO-friendly and user-readable.</p> <p>Here's a brief comparison:</p> ComparisonTheory <ul> <li> <p>Use of slugify:</p> <p>You use slugify when you need to generate a slug from a string outside of model instances, such as when processing user input or generating slugs for various purposes.</p> </li> <li> <p>Use of SlugField:</p> <p>You use SlugField when you want to store slugs directly in your database models. This is useful when you need to persistently store slugs associated with specific database records, such as articles, products, or user profiles. SlugField can automatically generate slugs based on other fields in the model and enforce uniqueness constraints.</p> </li> </ul> <ul> <li> <p>slugify:</p> <p>slugify is a utility function provided by Django to generate URL-friendly versions of strings. It is typically used to create slugs from user-generated content or dynamic data. slugify takes a string as input and converts it into a format suitable for use in URLs by removing special characters, spaces, and converting the text to lowercase.</p> </li> <li> <p>model.SlugField:</p> <p>SlugField is a field type provided by Django's ORM (Object-Relational Mapping) system for models. It is specifically designed to store URL-friendly strings, typically used as part of URLs to identify resources. When defining a model, you can use SlugField to specify that a particular field should hold a slug value. Django will then automatically generate a slug based on the input string whenever an instance of the model is created or updated.</p> </li> </ul>"},{"location":"blog/2024/05/12/understanding-slugify-and-slugfield-in-django/#conclusion","title":"Conclusion","text":"<p>In summary, you use <code>slugify</code> for generating slugs from strings, often for dynamic or user-generated content, while you use <code>SlugField</code> when you need to store slugs as part of your database models. They often complement each other, with slugify used to generate the initial slug value and SlugField used to store it persistently.</p> <p>In conclusion, understanding <code>slugify</code> and <code>SlugField</code> is essential for crafting elegant and effective URLs in your Django applications. Whether you're processing user input, managing dynamic content, or designing database models, these tools empower you to create URLs that enhance both usability and search engine optimization. So, embrace them in your Django projects and pave the way for smooth navigation and better discoverability!</p>"},{"location":"blog/2024/07/17/mastering-django-static-file-settings-static_url-static_root--staticfiles_dirs/","title":"Mastering Django Static File Settings: STATIC_URL, STATIC_ROOT &amp; STATICFILES_DIRS","text":"","tags":["Django"]},{"location":"blog/2024/07/17/mastering-django-static-file-settings-static_url-static_root--staticfiles_dirs/#mastering-django-static-file-settings-static_url-static_root-staticfiles_dirs","title":"Mastering Django Static File Settings: <code>STATIC_URL</code>, <code>STATIC_ROOT</code> &amp; <code>STATICFILES_DIRS</code>","text":"<p>Django's static file settings are configuration options in the <code>settings.py</code> file that control how static files (such as CSS, JavaScript, and images) are managed and served in a Django project.</p>","tags":["Django"]},{"location":"blog/2024/07/17/mastering-django-static-file-settings-static_url-static_root--staticfiles_dirs/#overview","title":"Overview","text":"<p>Static files are essential for adding styles, scripts, and images to your web application, and Django provides a structured way to handle these files both during development and in production.</p> <p>Mastering Django Static File Settings: From <code>STATIC_URL</code> to <code>STATICFILES_DIRS</code></p>","tags":["Django"]},{"location":"blog/2024/07/17/mastering-django-static-file-settings-static_url-static_root--staticfiles_dirs/#how-static-files-work","title":"How Static Files Work","text":"","tags":["Django"]},{"location":"blog/2024/07/17/mastering-django-static-file-settings-static_url-static_root--staticfiles_dirs/#1-development","title":"1. Development:","text":"<ul> <li>During development, Django uses the <code>STATIC_URL</code> setting to serve static files directly.</li> <li>The <code>STATICFILES_DIRS</code> setting allows you to include additional directories for static files.</li> </ul>","tags":["Django"]},{"location":"blog/2024/07/17/mastering-django-static-file-settings-static_url-static_root--staticfiles_dirs/#2-production","title":"2. Production:","text":"<ul> <li>When deploying, you run <code>python manage.py collectstatic</code> to gather all static files into the directory specified by <code>STATIC_ROOT</code>.</li> <li>Static files are then served by the web server (e.g., Nginx, Apache) rather than by Django itself.</li> </ul>","tags":["Django"]},{"location":"blog/2024/07/17/mastering-django-static-file-settings-static_url-static_root--staticfiles_dirs/#example-configuration","title":"Example Configuration","text":"<p>Here's a sample configuration that might be used in a Django project:</p> <pre><code># settings.py\n\n# URL prefix for serving static files\nSTATIC_URL = '/static/'\n\n# Additional directories to search for static files\nSTATICFILES_DIRS = [\n    os.path.join(BASE_DIR, 'assets'),\n]\n\n# Directory where static files will be collected for production\nSTATIC_ROOT = os.path.join(BASE_DIR, 'staticfiles')\n\n# Storage backend for static files (optional)\nSTATICFILES_STORAGE = 'django.contrib.staticfiles.storage.StaticFilesStorage'\n\n# Finders for locating static files (optional)\nSTATICFILES_FINDERS = [\n    'django.contrib.staticfiles.finders.FileSystemFinder',\n    'django.contrib.staticfiles.finders.AppDirectoriesFinder',\n]\n</code></pre>","tags":["Django"]},{"location":"blog/2024/07/17/mastering-django-static-file-settings-static_url-static_root--staticfiles_dirs/#summary","title":"Summary","text":"<p>Django's static file settings provide a framework for managing static assets in your project. They help you configure how static files are served and collected, ensuring that your CSS, JavaScript, and images are available to users both during development and in production.</p>","tags":["Django"]},{"location":"blog/2024/07/17/mastering-django-static-file-settings-static_url-static_root--staticfiles_dirs/#explanation","title":"Explanation","text":"","tags":["Django"]},{"location":"blog/2024/07/17/mastering-django-static-file-settings-static_url-static_root--staticfiles_dirs/#1-static_url","title":"1. STATIC_URL","text":"<p>Purpose:</p> <ul> <li><code>STATIC_URL</code> defines the URL prefix for serving static files. It tells Django where static files can be accessed from the web.</li> </ul> <p>Manual Folder Creation:</p> <ul> <li>You do not need to create a folder manually for <code>STATIC_URL</code>. This setting is for defining the URL path, not a file system path.</li> </ul> <p>Configuration:</p> <ul> <li>Type: String</li> <li>Required: Yes</li> <li>Typical Value: <code>/static/</code></li> </ul> <pre><code>STATIC_URL = '/static/'\n</code></pre> <p>This means that static files will be served at URLs starting with <code>/static/</code>, such as <code>http://example.com/static/css/style.css</code>.</p>","tags":["Django"]},{"location":"blog/2024/07/17/mastering-django-static-file-settings-static_url-static_root--staticfiles_dirs/#2-static_root","title":"2. STATIC_ROOT","text":"<p>Purpose:</p> <p><code>STATIC_ROOT</code> specifies the directory where all static files will be collected when you run the <code>collectstatic</code> command. This is used in production to gather all static files into one place so that they can be served efficiently by a web server.</p> <p>Manual Folder Creation:</p> <ul> <li>You do not need to manually create the <code>STATIC_ROOT</code> folder before running <code>collectstatic</code>. Django will create this folder for you if it does not already exist. However, ensure that the directory is writable by the user running the Django application.</li> </ul> <p>Configuration:</p> <ul> <li>Type: String (directory path)</li> <li>Required: No, but it is necessary for production environments.</li> <li>Typical Value: <code>os.path.join(BASE_DIR, 'staticfiles')</code></li> </ul> <pre><code>STATIC_ROOT = os.path.join(BASE_DIR, 'staticfiles')\n</code></pre> <p>This means that when you run <code>python manage.py collectstatic</code>, all your static files will be gathered into the <code>staticfiles</code> directory inside your project\u2019s base directory.</p>","tags":["Django"]},{"location":"blog/2024/07/17/mastering-django-static-file-settings-static_url-static_root--staticfiles_dirs/#3-staticfiles_dirs","title":"3. STATICFILES_DIRS","text":"<p>Purpose:</p> <p><code>STATICFILES_DIRS</code> is a list of additional directories where Django should look for static files, in addition to each app\u2019s <code>static</code> directory. It\u2019s useful for specifying global static file locations outside of individual apps.</p> <p>Manual Folder Creation:</p> <ul> <li>Yes, you need to manually create the folders listed in <code>STATICFILES_DIRS</code> if they do not already exist. For example, if you specify <code>assets</code> in <code>STATICFILES_DIRS</code>, you should create the <code>assets</code> folder in your project directory and place your static files there.</li> </ul> <p>Configuration:</p> <ul> <li>Type: List of strings (directory paths)</li> <li>Required: No, but useful if you need to add global directories for static files.</li> <li>Typical Value: <code>[os.path.join(BASE_DIR, 'assets')]</code></li> </ul> <pre><code>STATICFILES_DIRS = [\n    os.path.join(BASE_DIR, 'assets'),\n]\n</code></pre> <p>This tells Django to also look in the <code>assets</code> directory at the base level of your project for static files.</p>","tags":["Django"]},{"location":"blog/2024/07/17/mastering-django-static-file-settings-static_url-static_root--staticfiles_dirs/#summary_1","title":"Summary","text":"<ul> <li>STATIC_URL: Defines the URL path to access static files. No manual folder creation is needed.</li> <li>STATIC_ROOT: Directory where static files are collected for production. Django creates this folder during the collectstatic process if it does not exist.</li> <li>STATICFILES_DIRS: List of additional directories to search for static files. You need to manually create these directories and place static files in them.</li> </ul> <p>By configuring these settings properly and creating necessary directories, you ensure that Django can correctly manage and serve static files both during development and in production.</p>","tags":["Django"]},{"location":"blog/2024/07/17/mastering-django-static-file-settings-static_url-static_root--staticfiles_dirs/#advanced","title":"Advanced","text":"<p>In Django, a top-level directory for global static files is a directory located at the root of your project directory that is used to store static files that are not tied to any specific Django app but are shared across the entire project. This directory is an optional but useful organization technique for managing static assets that you want to be accessible throughout your project but are not directly associated with any particular application.</p>","tags":["Django"]},{"location":"blog/2024/07/17/mastering-django-static-file-settings-static_url-static_root--staticfiles_dirs/#purpose-of-a-top-level-global-static-directory","title":"Purpose of a Top-Level Global Static Directory","text":"<ul> <li>Centralization: Keeps global static files in one place rather than scattering them across different apps.</li> <li>Organization: Helps in maintaining a clear structure by separating static files used across the project from those specific to individual apps.</li> <li>Convenience: Provides an easy way to manage and reference global assets, such as site-wide CSS or JavaScript files, that are used throughout the project.</li> </ul> <pre><code>myproject/\n    myapp1/\n        static/\n            myapp1/\n                css/\n                js/\n                images/\n    myapp2/\n        static/\n            myapp2/\n                css/\n                js/\n                images/\n    assets/  # This is the global static directory\n        css/\n        js/\n        images/\n    myproject/\n        __init__.py\n        settings.py\n        urls.py\n        wsgi.py\n    manage.py\n</code></pre> settings.py<pre><code>import os\nfrom pathlib import Path\n\nBASE_DIR = Path(__file__).resolve().parent.parent\n\n\n# URL prefix for serving static files\nSTATIC_URL = '/static/'\n\n# Directory where static files will be collected for production\nSTATIC_ROOT = os.path.join(BASE_DIR, 'staticfiles')\n\n# Additional directories where Django will look for static files\nSTATICFILES_DIRS = [\n    os.path.join(BASE_DIR, 'assets'),  # Global static directory\n]\n</code></pre> Explanation <ul> <li>STATIC_URL: Defines the base URL for serving static files. In this case, <code>/static/</code> means that static files will be served at URLs starting with <code>/static/</code>.</li> <li>STATICFILES_DIRS: Lists additional directories for Django to search for static files. The assets directory is specified here, so Django will also look in <code>myproject/assets/</code> for static files.</li> </ul>","tags":["Django"]},{"location":"blog/2024/07/17/mastering-django-static-file-settings-static_url-static_root--staticfiles_dirs/#using-static-files-in-templates","title":"Using Static Files in Templates","text":"<p>When you use static files in your Django templates, you will reference them with the URL defined by <code>STATIC_URL</code>. For example:</p> <pre><code>&lt;!-- Linking a CSS file from the global assets directory --&gt;\n&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"{% static 'css/style.css' %}\" /&gt;\n</code></pre> <p>In this case, Django will look for <code>style.css</code> in the <code>assets/css/</code> directory and serve it at <code>http://example.com/static/css/style.css</code>.</p>","tags":["Django"]},{"location":"blog/2024/07/17/mastering-django-static-file-settings-static_url-static_root--staticfiles_dirs/#summary_2","title":"Summary","text":"<ul> <li>Top-Level Global Static Directory: A directory like <code>assets/</code> at the root level of your project that stores static files shared across the entire project.</li> <li>Purpose: Centralizes and organizes global static files that are not specific to any particular app.</li> <li>Configuration: Use the <code>STATICFILES_DIRS</code> setting in <code>settings.py</code> to include this directory in Django's static file search paths.</li> </ul> <p>By organizing your static files this way, you can maintain a clear and manageable structure, especially in larger projects where multiple apps and global assets are involved.</p>","tags":["Django"]},{"location":"blog/2024/07/17/mastering-django-static-file-settings-static_url-static_root--staticfiles_dirs/#hidden-magic","title":"Hidden Magic","text":"<pre><code>python3 manage.py shell\n</code></pre>","tags":["Django"]},{"location":"blog/2024/07/17/mastering-django-static-file-settings-static_url-static_root--staticfiles_dirs/#list-all-the-seetings","title":"List all the seetings","text":"<pre><code>from django.conf import settings\ndir(settings)\n</code></pre>","tags":["Django"]},{"location":"blog/2024/07/17/mastering-django-static-file-settings-static_url-static_root--staticfiles_dirs/#diffsettings","title":"<code>diffsettings</code>","text":"<p>Running <code>python manage.py diffsettings</code> will show you the settings that differ from the default values. This can be useful to see which static file settings have been explicitly defined in your project.</p> <pre><code>python manage.py diffsettings\n</code></pre>","tags":["Django"]},{"location":"blog/2024/01/06/drf-yasg-swagger/","title":"drf-yasg: Swagger","text":"","tags":["Python","Drf"]},{"location":"blog/2024/01/06/drf-yasg-swagger/#drf-yasg-swagger","title":"drf-yasg: Swagger","text":"<p><code>drf-yasg</code> (Yet Another Swagger Generator) is a popular Django package that generates Swagger/OpenAPI documentation for your Django REST framework APIs. It allows you to have a clean, interactive, and dynamic API documentation that makes it easy for developers to understand and test your API.</p> <ol> <li> <p>Install drf-yasg:</p> <pre><code># Install the package using pip:\n\n$ pip install drf-yasg\n</code></pre> </li> <li> <p>Add <code>drf_yasg</code> to INSTALLED_APPS:</p> <pre><code># Open your settings.py file and add drf_yasg to the INSTALLED_APPS:\n\nINSTALLED_APPS = [\n    # ...\n    'drf_yasg',\n    # ...\n]\n</code></pre> </li> <li> <p>Configure <code>drf-yasg</code> in your project's <code>urls.py</code>:</p> <pre><code># Add the following to your project's urls.py:\n\nfrom django.urls import path, re_path, include\nfrom django.conf import settings\nfrom django.conf.urls.static import static\nfrom rest_framework import permissions\nfrom drf_yasg.views import get_schema_view\nfrom drf_yasg import openapi\n\nschema_view = get_schema_view(\n    openapi.Info(\n        title=\"Your API Title\",\n        default_version='v1',\n        description=\"Your API description\",\n        terms_of_service=\"https://www.yourapp.com/terms/\",\n        contact=openapi.Contact(email=\"contact@yourapp.com\"),\n        license=openapi.License(name=\"Your License\"),\n    ),\n    public=True,\n    permission_classes=(permissions.AllowAny,),\n)\n\nurlpatterns = [\n    # ... your other URL patterns\n    re_path(r'^swagger(?P&lt;format&gt;\\.json|\\.yaml)$', schema_view.without_ui(cache_timeout=0), name='schema-json'),\n    path('swagger/', schema_view.with_ui('swagger', cache_timeout=0), name='schema-swagger-ui'),\n    path('redoc/', schema_view.with_ui('redoc', cache_timeout=0), name='schema-redoc'),\n]\n\nif settings.DEBUG:\n    urlpatterns += static(settings.STATIC_URL, document_root=settings.STATIC_ROOT)\n</code></pre> <p>Replace \"Your API Title\" and other information in the openapi.Info section with your actual API details.</p> </li> <li> <p>Run your Django development server:</p> <pre><code># Start your Django development server:\n\n$ python manage.py runserver\n</code></pre> <p>Now you can access the Swagger documentation by navigating to http://127.0.0.1:8000/swagger/ or http://127.0.0.1:8000/redoc/ in your web browser.</p> <ul> <li>The Swagger UI is available at the /swagger/ endpoint.</li> <li>The ReDoc UI is available at the /redoc/ endpoint.</li> </ul> </li> <li> <p>Explore and Test Your API:</p> <p>Once in the Swagger or ReDoc UI, you can explore your <code>API's endpoints</code>, view the available methods, and even test your API directly from the interface.</p> <p>That's it! You've now integrated <code>drf-yasg</code> into your Django project, providing interactive API documentation for your RESTful API.</p> </li> </ol> <p>Notes</p> <p>Keep in mind Django Rest Swagger is now considered deprecated in favor of its successor, <code>drf-yasg</code>. You might want to consider using <code>drf-yasg</code> for newer projects. To use <code>drf-yasg</code>, follow my instructions above.</p>","tags":["Python","Drf"]},{"location":"blog/2024/01/06/drf-yasg-swagger/#reference","title":"Reference","text":"<ul> <li>drf-yasg: github</li> </ul>","tags":["Python","Drf"]},{"location":"blog/2024/05/16/get-related-blogs-using-django-taggit/","title":"Get related blogs using django-taggit","text":"","tags":["Python","Django"]},{"location":"blog/2024/05/16/get-related-blogs-using-django-taggit/#get-related-blogs-using-django-taggit","title":"Get related blogs using <code>django-taggit</code>","text":"<p>To display the title of the other suggested blogs as clickable links in your NewsDetailsView, you can modify the template to include links to the suggested blog items. Here's how you can do it:</p> <p>Sure, here's a simple example of how you can implement tags in Django using the django-taggit library:</p> <p>First, install django-taggit:</p> bash<pre><code>pip install django-taggit\n</code></pre> <ol> <li> <p>Update the <code>NewsDetailsView</code> to pass the related blogs to the template:</p> <p>views.py</p> Python<pre><code>class NewsDetailsView(DetailView):\n    model = NewsItem\n    template_name = \"news/item.html\"\n    context_object_name = \"news_detail\"\n    slug_field = \"slug\"\n\n    def get_context_data(self, **kwargs):\n        context = super().get_context_data(**kwargs)\n        context['related_blogs'] = self.object.get_related_blogs()\n        return context\n</code></pre> </li> <li> <p>Modify the <code>NewsItem</code> model to include the method for getting related blogs:</p> <p>models.py</p> Python<pre><code>class NewsItem(models.Model):\n    title = models.CharField(max_length=100)\n    content = models.TextField()\n    tags = TaggableManager()\n    # Other fields as needed\n\n    def __str__(self):\n        return self.title\n\n    def get_absolute_url(self):\n        return reverse('news_detail', kwargs={'slug': self.slug})\n\n    def get_related_blogs(self):\n        return NewsItem.objects.filter(tags__in=self.tags.all()).exclude(id=self.id).distinct()[:5]\n</code></pre> </li> <li> <p>Update your <code>news/item.html</code> template to display the suggested blogs with clickable links:</p> <p>item.html</p> Python<pre><code>&lt;h2&gt;{{ news_detail.title }}&lt;/h2&gt;\n&lt;p&gt;{{ news_detail.content }}&lt;/p&gt;\n{% if related_blogs %}\n    &lt;h3&gt;Related Blogs:&lt;/h3&gt;\n    &lt;ul&gt;\n        {% for blog in related_blogs %}\n            &lt;li&gt;&lt;a href=\"{{ blog.get_absolute_url }}\"&gt;{{ blog.title }}&lt;/a&gt;&lt;/li&gt;\n        {% endfor %}\n    &lt;/ul&gt;\n{% endif %}\n</code></pre> <p>In this template, <code>{{ blog.get_absolute_url }}</code> is assumed to be a method on your NewsItem model that returns the URL to view the detail of the blog item. Make sure to replace it with the appropriate method if you have a different way of generating the URL for your blog items.</p> </li> </ol>","tags":["Python","Django"]},{"location":"blog/2024/05/16/get-related-blogs-using-django-taggit/#get_absolute_url-method","title":"get_absolute_url method","text":"<p>The <code>get_absolute_url</code> method is not predefined in Django models; you need to define it yourself. It's a method that returns the canonical URL for an object. This is useful for providing a consistent way to get the URL of an object, especially in templates or when redirecting to object detail pages.</p> <p>Here's how you can define <code>get_absolute_url</code> in your <code>NewsItem</code> model:</p> models.py<pre><code>from django.db import models\nfrom django.urls import reverse\nfrom taggit.managers import TaggableManager\n\nclass NewsItem(models.Model):\n    title = models.CharField(max_length=100)\n    content = models.TextField()\n    tags = TaggableManager()\n    # Other fields as needed\n\n    def __str__(self):\n        return self.title\n\n    def get_absolute_url(self):\n        return reverse('news_detail', kwargs={'slug': self.slug})\n</code></pre> <p>In this example:</p> <ul> <li>We import the reverse function from <code>django.urls</code>.</li> <li>Inside the <code>NewsItem model</code>, we define a method called <code>get_absolute_url</code>.</li> <li>This method uses the <code>reverse</code> function to build the URL for the <code>news_detail view</code>, passing the slug of the <code>NewsItem</code> as a keyword argument.</li> <li>Make sure you replace <code>news_detail</code> with the actual name of your detail view, and slug with the appropriate field name used for slugs in your model.</li> <li>This method will return the URL for the detail view of the <code>NewsItem</code>, which can be used in templates or views.</li> </ul>","tags":["Python","Django"]},{"location":"blog/2024/05/16/get-related-blogs-using-django-taggit/#theory","title":"Theory","text":"","tags":["Python","Django"]},{"location":"blog/2024/05/16/get-related-blogs-using-django-taggit/#what-is-get_absolute_url","title":"What is get_absolute_url?","text":"<p>get_absolute_url is a method that you define on your Django models. It returns the canonical URL for an instance of the model. This method is incredibly useful for generating URLs to detail views or other specific views associated with the model instance.</p>","tags":["Python","Django"]},{"location":"blog/2024/05/16/get-related-blogs-using-django-taggit/#why-use-get_absolute_url","title":"Why use get_absolute_url?","text":"<p>Implementing <code>get_absolute_url</code> in your models offers several benefits:</p> <ol> <li> <p>Consistency:</p> <p>By providing a standardized way to retrieve the URL for an object, you ensure consistency across your application. This can simplify template rendering and make your codebase more maintainable.</p> </li> <li> <p>Flexibility:</p> <p>You can easily change the URL structure of your application without having to update every template or view that references model instances. Simply update the <code>get_absolute_url</code> method, and all references will automatically reflect the changes.</p> </li> <li> <p>Readability:</p> <p>Using <code>get_absolute_url</code> in templates and views makes your code more readable and self-explanatory. Developers and designers can quickly understand how to link to specific pages without needing to dig into URL configurations.</p> </li> </ol>","tags":["Python","Django"]},{"location":"blog/2024/05/16/get-related-blogs-using-django-taggit/#how-to-implement-get_absolute_url","title":"How to implement get_absolute_url?","text":"<p>Implementing <code>get_absolute_url</code> is straightforward. Here's a step-by-step guide:</p> <ol> <li> <p>Define the method:</p> <p>Inside your model class, define a method named <code>get_absolute_url</code>. This method should return the URL for the detail view of the model instance.</p> </li> <li> <p>Use the reverse function:</p> <p>Within the <code>get_absolute_url</code> method, use Django's reverse function to generate the URL for the desired view. Pass any necessary parameters, such as the primary key or slug, to identify the specific instance.</p> </li> <li> <p>Update templates and views:</p> <p>In your templates or views, use the <code>get_absolute_url</code> method to generate links to model instances. This ensures that links remain up-to-date even if the URL structure changes.</p> </li> </ol>","tags":["Python","Django"]},{"location":"blog/2024/05/16/get-related-blogs-using-django-taggit/#example-newsitem-model-with-get_absolute_url","title":"Example: <code>NewsItem</code> model with <code>get_absolute_url</code>","text":"<p>Let's consider a <code>NewsItem</code> model in a hypothetical news website application. We want each news item to have a detail view accessible via a unique slug-based URL.</p> <pre><code>from django.db import models\nfrom django.urls import reverse\n\nclass NewsItem(models.Model):\n    title = models.CharField(max_length=100)\n    content = models.TextField()\n    slug = models.SlugField(unique=True)\n\n    def __str__(self):\n        return self.title\n\n    def get_absolute_url(self):\n        return reverse('news_detail', kwargs={'slug': self.slug})\n</code></pre> <p>In this example, we define a <code>get_absolute_url</code> method that returns the URL for the <code>news_detail</code> view, using the slug field as the identifier. This method ensures that we can easily generate links to individual news items in our templates or views.</p>","tags":["Python","Django"]},{"location":"blog/2024/05/16/get-related-blogs-using-django-taggit/#conclusion","title":"Conclusion","text":"<p>Implementing <code>get_absolute_url</code> in your Django models is a simple yet powerful way to enhance the usability and maintainability of your application. By providing a consistent and flexible way to generate URLs for model instances, you can streamline development and improve the overall user experience of your application.</p>","tags":["Python","Django"]},{"location":"blog/2024/05/16/get-related-blogs-using-django-taggit/#reference","title":"Reference","text":"<ul> <li>django-taggit</li> </ul>","tags":["Python","Django"]},{"location":"blog/2024/05/06/django-with-ajax/","title":"Django with ajax","text":"","tags":["Django"]},{"location":"blog/2024/05/06/django-with-ajax/#django-with-ajax","title":"Django with ajax","text":"<p>In the ever-evolving landscape of web development, enhancing user experience is paramount. One powerful tool for achieving this is AJAX (<code>Asynchronous JavaScript and XML</code>), which allows for seamless, asynchronous communication between the client and server. When integrated with Django, a high-level Python web framework, AJAX can elevate your web applications to new heights of interactivity and responsiveness.</p> <p>We need AJAX for dynamic, seamless, and responsive web experiences by enabling asynchronous communication between the client and server, reducing page reloads, enhancing user interaction, and improving performance.</p> <p>Success</p> bodyscriptviews.pyurls.pymisc <pre><code>&lt;div class=\"col-md-4\"&gt;\n    &lt;div class=\"accordion\" id=\"accordionExample3\"&gt;\n      &lt;div class=\"accordion-item\"&gt;\n          &lt;h2 class=\"accordion-header\"&gt;\n              &lt;button class=\"accordion-button\" type=\"button\" data-bs-toggle=\"collapse\" data-bs-target=\"#collapseThree\" aria-expanded=\"true\" aria-controls=\"collapseOne\"&gt;\n                IT Services\n              &lt;/button&gt;\n          &lt;/h2&gt;\n          {% for item in header_business %}\n            {% if item.category == '3' %}\n            &lt;div id=\"collapseThree\" class=\"accordion-collapse collapse show\" data-bs-parent=\"#accordionExample3\"&gt;\n                &lt;div class=\"accordion-body\"&gt;\n                  &lt;a href=\"#\" class=\"business-item-link\" data-slug=\"{{ item.slug }}\"&gt;{{ item.title }}&lt;/a&gt;\n                &lt;/div&gt;\n            &lt;/div&gt;\n            {% endif %}\n          {% endfor %}\n      &lt;/div&gt;\n    &lt;/div&gt;\n  &lt;/div&gt;\n  &lt;div class=\"col-md-8\"&gt;\n    {% if not request.is_ajax %}\n        &lt;h5 class=\"bt__bussiness--title bt-sec-title\"&gt;{{ business_item.title }}&lt;/h5&gt;\n        &lt;div class=\"business-item-content\"&gt;{{ business_item.content | safe }}&lt;/div&gt;\n    {% else %}\n      &lt;h5 class=\"bt__bussiness--title bt-sec-title\"&gt;&lt;/h5&gt;\n      &lt;div class=\"business-item-content\"&gt; &lt;/div&gt;\n    {% endif %}\n  &lt;/div&gt;\n</code></pre> script<pre><code>&lt;script&gt;\n$(document).ready(function(){\n    // Get CSRF token from cookie\n    function getCookie(name) {\n        var cookieValue = null;\n        if (document.cookie &amp;&amp; document.cookie !== '') {\n            var cookies = document.cookie.split(';');\n            for (var i = 0; i &lt; cookies.length; i++) {\n                var cookie = cookies[i].trim();\n                // Does this cookie string begin with the name we want?\n                if (cookie.substring(0, name.length + 1) === (name + '=')) {\n                    cookieValue = decodeURIComponent(cookie.substring(name.length + 1));\n                    break;\n                }\n            }\n        }\n        return cookieValue;\n    }\n    var csrftoken = getCookie('csrftoken');\n\n    // Handle click event for anchor tag with class 'business-item-link'\n    $('.business-item-link').click(function(event) {\n        // Prevent default behavior of anchor tag\n        event.preventDefault();\n\n        // Get the slug value from data attribute\n        var slug = $(this).data('slug');\n\n        // AJAX GET request to fetch data\n        $.ajax({\n            url: '/business/' + slug + '/ajax/',\n            type: 'GET',\n            beforeSend: function(xhr, settings) {\n                // Include CSRF token in headers\n                xhr.setRequestHeader(\"X-CSRFToken\", csrftoken);\n            },\n            success: function(response){\n                console.log('Response data:', response.title);\n\n                // Ensure that response contains the title property\n                if (response.hasOwnProperty('title')) {\n                    // Update HTML content with received data\n                    $('.bt__bussiness--title').text(response.title);\n                }\n\n                // Ensure that response contains the content property\n                if (response.hasOwnProperty('content')) {\n                    $('.business-item-content').html(response.content);\n                }\n            },\n            error: function(xhr, errmsg, err){\n                console.error('Error fetching data:', errmsg);\n            }\n        });\n    });\n});\n&lt;/script&gt;\n</code></pre> <pre><code>from django.http import JsonResponse\n\n...\n\nclass BusinessItemView(HeaderFooterMixin, TemplateView):\n    template_name = 'business/business-item.html'\n\n    def get_context_data(self, **kwargs):\n        context = super().get_context_data(**kwargs)\n        slug = kwargs['slug']\n        business_item = get_object_or_404(BusinessItem, slug=slug)\n        context['business_item'] = business_item\n\n        business_inner = BusinessInner.objects.first()\n        context['business_inner'] = business_inner\n\n        return context\n\n    def get_ajax_data(self, request, *args, **kwargs):\n        slug = kwargs['slug']\n        business_item = get_object_or_404(BusinessItem, slug=slug)\n\n        print(\"REQUEST xxxx\")\n\n        # Construct data to send in JSON response\n        print(\"business_item: \", business_item)\n\n        data = {\n            'title': business_item.title,\n            'content': business_item.content,\n            # Add more data as needed\n        }\n        return JsonResponse(data)\n\n    def dispatch(self, request, *args, **kwargs):\n        # Check if it's an AJAX request\n        # if request.is_ajax(): is depreciated\n        if request.META.get('HTTP_X_REQUESTED_WITH') == 'XMLHttpRequest':\n            # If yes, call the get_ajax_data method\n            return self.get_ajax_data(request, *args, **kwargs)\n        else:\n            # If not, call the parent dispatch method to handle the regular view\n            return super().dispatch(request, *args, **kwargs)\n</code></pre> <pre><code>urlpatterns = [\n    path('', BusinessPageView.as_view(), name='inner'),\n    path('&lt;slug&gt;/', BusinessItemView.as_view(), name='item'),\n    path('&lt;slug&gt;/ajax/', BusinessItemView.as_view(), name='item_ajax'), \n]\n</code></pre> base.html<pre><code>&lt;head&gt;\n    &lt;script src=\"{% static 'js/jquery-3.7.1.min.js' %}\"&gt;&lt;/script&gt;\n&lt;/head&gt;\n&lt;body&gt;\n\nuse script before body\n</code></pre>","tags":["Django"]},{"location":"blog/2024/05/06/django-with-ajax/#reference","title":"Reference","text":"","tags":["Django"]},{"location":"blog/2024/06/13/django-with-tailwind/","title":"Django with Tailwind","text":"","tags":["Django","tailwindcss"]},{"location":"blog/2024/06/13/django-with-tailwind/#django-with-tailwind","title":"Django with Tailwind","text":"<p>Develop with Tailwind CSS in Django flavour.</p> <p>Quick Start</p> <ol> <li> <p>Install django-tailwindcss from pip</p> <pre><code>pip install django-tailwindcss\n</code></pre> </li> </ol>","tags":["Django","tailwindcss"]},{"location":"blog/2024/06/13/django-with-tailwind/#reference","title":"Reference","text":"<ul> <li>django-tailwindcss: pypi</li> <li>django-tailwindcss: github</li> </ul>","tags":["Django","tailwindcss"]},{"location":"blog/2024/01/03/blog-crud-application-using-drf--viewsets/","title":"Blog CRUD Application Using DRF \u2014 Viewsets","text":"","tags":["Python","Drf"]},{"location":"blog/2024/01/03/blog-crud-application-using-drf--viewsets/#blog-crud-application-using-drf-viewsets","title":"Blog CRUD Application Using DRF \u2014 Viewsets","text":"<p>Django Rest Framework is a powerful tool that allows you to easily build RESTful APIs using Django. By defining your models, serializers, views, and URLs, you can quickly create a blog post application that allows users to create, read, update, and delete blog posts via a web API.</p> <pre><code># Installing Django and Django REST framework at once\n\n$ pip install django djangorestframework\n</code></pre> <p>In Django Rest Framework, a ViewSet is a class-based view that provides a set of common actions (i.e., CRUD operations) for a specific model or queryset.</p> <p>ViewSets allow you to define your API endpoints in a more concise and structured way, as they provide a set of default methods that handle common HTTP operations, such as GET, POST, PUT, PATCH, and DELETE.</p> <p>There are two main types of ViewSets in Django Rest Framework: ModelViewSet and ReadOnlyModelViewSet.</p> <p>The ModelViewSet is the most commonly used ViewSet, as it provides all the actions that are required to implement a full CRUD API. It includes methods such as list, create, retrieve, update, and destroy, which correspond to the HTTP GET, POST, GET (single object), PUT/PATCH, and DELETE methods, respectively.</p> <p>You can also override these default methods to add custom behavior, such as filtering or authentication.</p> <p>Today, We are going to check ModelViewSets</p>","tags":["Python","Drf"]},{"location":"blog/2024/01/03/blog-crud-application-using-drf--viewsets/#create-a-django-project","title":"Create a django-project","text":"<p>I have create a project named \"api\".</p> <pre><code>$ django-admin startproject api\n</code></pre> <p>Now, let create a new app called \"books\".</p> <pre><code>$ cd api\n\n$ py manage.py startapp books\n</code></pre>","tags":["Python","Drf"]},{"location":"blog/2024/01/03/blog-crud-application-using-drf--viewsets/#books-app","title":"books <code>app</code>","text":"<pre><code># models.py\n\nfrom django.db import models\n\nclass Book(models.Model):\n    title = models.CharField(max_length=255)\n    author = models.CharField(max_length=150)\n\n    class Meta:\n        db_table = \"Book\"\n\n    def __str__(self):\n        return self.title\n</code></pre> <pre><code># serializers.py\n\nfrom rest_framework import serializers\nfrom .models import Book\n\nclass BookSerializer(serializers.ModelSerializer):\n    class Meta:\n        model = Book\n        fields = '__all__'\n</code></pre> <pre><code># views.py\n\nfrom rest_framework import viewsets\nfrom .models import Book\nfrom .serializers import BookSerializer\n\nclass BookViewSet(viewsets.ModelViewSet):\n    queryset = Book.objects.all()\n    serializer_class = BookSerializer\n</code></pre> <pre><code># urls.py\n\nfrom rest_framework.routers import DefaultRouter\nfrom django.urls import include, path\nfrom .views import BookViewSet\n\nrouter = DefaultRouter()\nrouter.register(r'book_post', BookViewSet)\n\nurlpatterns = [\n    path('', include(router.urls))\n]\n</code></pre>","tags":["Python","Drf"]},{"location":"blog/2024/01/03/blog-crud-application-using-drf--viewsets/#api-project","title":"api <code>project</code>","text":"<pre><code># urls.py\n\nfrom django.contrib import admin\nfrom django.urls import path, include\nfrom rest_framework_simplejwt.views import TokenObtainPairView, TokenRefreshView\n\nurlpatterns = [\n    path('admin/', admin.site.urls),\n    path('api/token/', TokenObtainPairView.as_view(), name=\"token_obtain_pair\"),\n    path('api/token/refresh', TokenRefreshView.as_view(), name=\"token_refresh\"),\n    # apps\n    path('api/blog/', include('apps.blogs.urls')),\n    path('api/member/', include('apps.privateapi.urls')),\n    path('api/books/', include('apps.books.urls')),\n]\n</code></pre>","tags":["Python","Drf"]},{"location":"blog/2024/01/03/blog-crud-application-using-drf--viewsets/#reference","title":"Reference","text":"<ul> <li>Django REST Framework Views - ViewSets</li> <li>Blog CRUD Application Using DRF \u2014 Viewsets</li> </ul>","tags":["Python","Drf"]},{"location":"blog/2024/07/23/what-is-the-equivalent-concept-to-javascripts-prototype-chain-in-python/","title":"What is the Equivalent Concept to JavaScript's Prototype Chain in Python?","text":"","tags":["Python","Javascript"]},{"location":"blog/2024/07/23/what-is-the-equivalent-concept-to-javascripts-prototype-chain-in-python/#what-is-the-equivalent-concept-to-javascripts-prototype-chain-in-python","title":"What is the Equivalent Concept to JavaScript's Prototype Chain in Python?","text":"<p>In Python, the equivalent concept to JavaScript's prototype chain is the <code>inheritance model</code> that utilizes classes and <code>method resolution order</code> (MRO).</p> <p>What is the equivalent concept to JavaScript's prototype chain in Python, and how does Python handle object-oriented programming?</p>","tags":["Python","Javascript"]},{"location":"blog/2024/07/23/what-is-the-equivalent-concept-to-javascripts-prototype-chain-in-python/#1-classes-and-inheritance","title":"1. Classes and Inheritance:","text":"<ul> <li> <p>In Python, you define classes to create objects. A class can inherit from another class, allowing it to use methods and properties of the parent class. This creates a hierarchy similar to JavaScript's prototype chain.</p> </li> <li> <p>For example:</p> </li> </ul> <pre><code>class Parent:\n    def greet(self):\n        return \"Hello from the Parent!\"\n\nclass Child(Parent):\n    def greet_child(self):\n        return \"Hello from the Child!\"\n\nchild_instance = Child()\nprint(child_instance.greet())  # Inherits from Parent\n</code></pre>","tags":["Python","Javascript"]},{"location":"blog/2024/07/23/what-is-the-equivalent-concept-to-javascripts-prototype-chain-in-python/#2-method-resolution-order-mro","title":"2. Method Resolution Order (MRO):","text":"<ul> <li> <p>Python uses the C3 linearization algorithm to determine the order in which classes are searched when executing a method. This is important in multiple inheritance scenarios.</p> </li> <li> <p>You can check the MRO using the <code>__mro__</code> attribute:</p> </li> </ul> <pre><code>print(Child.__mro__)  # Outputs the method resolution order\n</code></pre>","tags":["Python","Javascript"]},{"location":"blog/2024/07/23/what-is-the-equivalent-concept-to-javascripts-prototype-chain-in-python/#3-dynamic-typing","title":"3. Dynamic Typing:","text":"<ul> <li>While JavaScript\u2019s prototype chain allows for dynamic addition of properties and methods to objects, Python's dynamic typing means you can add attributes to instances of classes at runtime, but it\u2019s less about prototype inheritance and more about class definitions.</li> </ul>","tags":["Python","Javascript"]},{"location":"blog/2024/07/23/what-is-the-equivalent-concept-to-javascripts-prototype-chain-in-python/#4-mixins-and-composition","title":"4. Mixins and Composition:","text":"<ul> <li>In Python, you can also use mixins and composition to achieve behavior similar to inheritance. This is often preferred for code reuse without creating deep inheritance hierarchies.</li> </ul>","tags":["Python","Javascript"]},{"location":"blog/2024/07/23/what-is-the-equivalent-concept-to-javascripts-prototype-chain-in-python/#summary","title":"Summary","text":"<ul> <li>Prototype Chain (JavaScript): Involves object-based inheritance where objects can inherit properties and methods from other objects.</li> <li>Class Inheritance (Python): Involves defining classes that can inherit from other classes, with a defined method resolution order.</li> </ul> <p>Both languages have their own ways of implementing inheritance and method sharing, and understanding these concepts is crucial for mastering object-oriented programming in either language.</p>","tags":["Python","Javascript"]},{"location":"blog/2024/06/15/handling-boolean-environment-variables-in-django-settings/","title":"Handling Boolean Environment Variables in Django Settings","text":"","tags":["django","env"]},{"location":"blog/2024/06/15/handling-boolean-environment-variables-in-django-settings/#handling-boolean-environment-variables-in-django-settings","title":"Handling Boolean Environment Variables in Django Settings","text":"<p>In Django development, managing environment variables is crucial for configuring application settings across different environments. One common pitfall developers encounter involves boolean settings, such as DEBUG, which are often stored as strings in environment files (<code>.env</code>). Let\u2019s delve into why this can be problematic and how to effectively solve it.</p> <p>The Problem</p> <p>Consider the DEBUG setting in Django, which dictates whether the application runs in debug mode (True) or not (False).</p> <p>Environment variables, when fetched using <code>os.environ.get('DEBUG')</code>, return strings. For instance, if <code>DEBUG=False</code> is stored in the <code>.env</code> file, <code>os.environ.get('DEBUG')</code> retrieves 'False' as a string, not False as expected by Django.</p> <p>How It Solves It</p> TheoryIn DepthAdditional <p>To correctly interpret boolean values from environment variables, a reliable approach involves:</p> <ol> <li> <p>Fetching and Lowercasing: Use <code>os.environ.get('DEBUG', 'False').lower()</code> to retrieve the setting as a lowercase string. This ensures consistency, regardless of the casing used in the .env file.</p> </li> <li> <p>Boolean Conversion: Check if the lowercase string ('true', '1', 't') exists in ('true', '1', 't') using the in operator. This converts the string representation of boolean values to their actual boolean counterparts (<code>True</code> or <code>False</code>).</p> </li> <li> <p>Assignment: Assign the boolean result to the <code>DEBUG</code> setting. This approach ensures that Django interprets the <code>DEBUG</code> setting correctly, aligning with its expected boolean format.</p> </li> </ol> settings.py<pre><code>from dotenv import load_dotenv\nfrom pathlib import Path\nimport os\n\n# Load environment variables from the .env file\nload_dotenv()\n\n# Convert the DEBUG value to a boolean\nDEBUG = os.environ.get('DEBUG', 'False').lower() in ('true', '1', 't')\n\n# Now you can use the DEBUG variable in your Django settings\n</code></pre> <ul> <li> <p>When DEBUG=True in <code>.env</code>:</p> <pre><code>os.environ.get('DEBUG', 'False')  # 'True'\n'True'.lower()                    # 'true'\n'true' in ('true', '1', 't')      # True\nDEBUG = True\n</code></pre> </li> <li> <p>When DEBUG=False in <code>.env</code>:</p> <pre><code>os.environ.get('DEBUG', 'False')  # 'False'\n'False'.lower()                   # 'false'\n'false' in ('true', '1', 't')     # False\nDEBUG = False\n</code></pre> </li> <li> <p>When DEBUG is not set in <code>.env</code>:</p> <pre><code>os.environ.get('DEBUG', 'False')  # 'False' (default value)\n'False'.lower()                   # 'false'\n'false' in ('true', '1', 't')     # False\nDEBUG = False\n</code></pre> </li> </ul> <p>In summary, the conversion to a boolean is done using the <code>in</code> operator, which checks if the string (converted to lowercase) is one of the true-like values. If it matches any of these values, DEBUG is set to <code>True</code>; otherwise, it is set to False.</p> <p>The expression 'false' in ('true', '1', 't') evaluates whether the string 'false' exists within the tuple ('true', '1', 't'). Here\u2019s a simple explanation of what happens:</p> <ol> <li> <p>Tuple Definition: ('true', '1', 't') is a tuple containing three strings: 'true', '1', and 't'.</p> </li> <li> <p>Membership Check: The in operator checks if the string 'false' is present within this tuple.</p> </li> <li> <p>Evaluation: Since 'false' is not in the tuple ('true', '1', 't'), the expression evaluates to False</p> </li> </ol> <p>In Python, the in operator is used to check if a value exists within a sequence (like a <code>list</code>, <code>tuple</code>, or <code>string</code>). If the value is found in the sequence, in returns <code>True</code>; otherwise, it returns <code>False</code>. Therefore, 'false' in ('true', '1', 't') evaluates to <code>False</code> because 'false' is not one of the elements in the tuple ('true', '1', 't').</p> <pre><code># Define the tuple\noptions = ('true', '1', 't')\n\n# Check if 'false' is in the tuple\nresult = 'false' in options\n\nprint(result)  # Output: False\n</code></pre> <p>This example demonstrates that 'false' is not found within the tuple ('true', '1', 't'), confirming that the expression evaluates to False.</p>","tags":["django","env"]},{"location":"blog/2024/06/15/handling-boolean-environment-variables-in-django-settings/#conclusion","title":"Conclusion","text":"<p>By adopting this method, developers can effectively manage boolean environment variables in Django applications. It ensures that settings like DEBUG are accurately interpreted as boolean values (<code>True</code> or <code>False</code>), preventing potential configuration errors and enhancing the reliability of your Django projects across different environments. Proper handling of environment variables not only simplifies configuration but also promotes consistency and robustness in application deployment.</p>","tags":["django","env"]},{"location":"blog/2024/04/23/enhancing-django-development-with-model-help_text/","title":"Enhancing Django Development with Model help_text","text":"","tags":["Python","Django"]},{"location":"blog/2024/04/23/enhancing-django-development-with-model-help_text/#enhancing-django-development-with-model-help_text","title":"Enhancing Django Development with Model <code>help_text</code>","text":"<p>In the bustling world of web development, Django stands out as a beacon of efficiency and clarity. Its robust features streamline the creation of dynamic web applications, but one often underestimated gem is the <code>help_text</code> attribute of Django models. Let's uncover its power and potential impact with a closer look.</p>","tags":["Python","Django"]},{"location":"blog/2024/04/23/enhancing-django-development-with-model-help_text/#understanding-help_text","title":"Understanding help_text","text":"<p>At its core, <code>help_text</code> is a simple yet incredibly valuable attribute that developers can add to Django model fields. It serves as a descriptive text, offering guidance and clarity on the purpose and expected input of each field.</p>","tags":["Python","Django"]},{"location":"blog/2024/04/23/enhancing-django-development-with-model-help_text/#clarity-and-documentation-made-easy","title":"Clarity and Documentation Made Easy","text":"<p>Consider a scenario where you're collaborating on a Django project with fellow developers. You dive into the <code>models.py</code> file, greeted by a myriad of fields across various models. Without proper documentation, understanding the intent of each field can feel like navigating a labyrinth. Here's where help_text shines. By adding succinct descriptions to fields, you provide instant clarity to your team, reducing confusion and streamlining the development process.</p> <p>Tip</p> Python<pre><code>from django.db import models\n\nclass Product(models.Model):\n    name = models.CharField(max_length=100, help_text=\"Enter the name of the product\")\n    price = models.DecimalField(max_digits=8, decimal_places=2, help_text=\"Specify the price of the product\")\n    description = models.TextField(help_text=\"Provide a brief description of the product\")\n</code></pre>","tags":["Python","Django"]},{"location":"blog/2024/04/23/enhancing-django-development-with-model-help_text/#elevating-user-experience","title":"Elevating User Experience","text":"<p>Beyond aiding developers, help_text contributes to a smoother user experience. Picture a user faced with a form to fill out. Clear, concise guidance accompanying each field can make the difference between frustration and satisfaction. With help_text, you empower users to navigate your application effortlessly, enhancing usability and satisfaction. Best Practices and Examples</p> <p>To leverage <code>help_text</code> effectively, adhere to these best practices:</p> <ul> <li>Be Concise: Keep descriptions brief yet informative.</li> <li>Use Clear Language: Ensure your <code>help_text</code> is easily understandable by both developers and users.</li> <li>Provide Examples: When needed, include examples to clarify the expected input.</li> </ul>","tags":["Python","Django"]},{"location":"blog/2024/04/23/enhancing-django-development-with-model-help_text/#conclusion-a-small-feature-with-big-impact","title":"Conclusion: A Small Feature with Big Impact","text":"<p>In the grand tapestry of Django development, <code>help_text</code> might seem like a minor detail. Yet, its impact on code clarity, collaboration, and user experience is undeniable. By embracing <code>help_text</code>, you elevate your Django projects to new heights of clarity and usability.</p> <p>So, the next time you define a model in Django, remember the power of <code>help_text</code> \u2014 a small addition that makes a world of difference.</p>","tags":["Python","Django"]},{"location":"blog/2024/07/25/how-to-order-multiple-inheritance-in-python-and-what-is-the-order-of-execution/","title":"How to Order Multiple Inheritance in Python, and What is the Order of Execution?","text":"","tags":["Python","Javascript"]},{"location":"blog/2024/07/25/how-to-order-multiple-inheritance-in-python-and-what-is-the-order-of-execution/#how-to-order-multiple-inheritance-in-python-and-what-is-the-order-of-execution","title":"How to Order Multiple Inheritance in Python, and What is the Order of Execution?","text":"<p>In Python, the order of multiple inheritance is controlled by the class definition and is determined by the Method Resolution Order (MRO).</p> <p>How can you control the order of multiple inheritance in Python, and what determines the order in which methods are executed?</p>","tags":["Python","Javascript"]},{"location":"blog/2024/07/25/how-to-order-multiple-inheritance-in-python-and-what-is-the-order-of-execution/#1-defining-the-inheritance-order","title":"1. Defining the Inheritance Order","text":"<p>When you define a class with multiple parents, the order in which you list those parent classes determines the MRO. The first class listed is checked first when searching for methods.</p> <pre><code>class A:\n    def greet(self):\n        return \"Hello from A\"\n\nclass B(A):\n    def greet(self):\n        return \"Hello from B\"\n\nclass C(A):\n    def greet(self):\n        return \"Hello from C\"\n\nclass D(B, C):  # B is checked before C\n    pass\n\nd_instance = D()\nprint(d_instance.greet())  # Output: \"Hello from B\"\n</code></pre>","tags":["Python","Javascript"]},{"location":"blog/2024/07/25/how-to-order-multiple-inheritance-in-python-and-what-is-the-order-of-execution/#2-understanding-method-resolution-order-mro","title":"2. Understanding Method Resolution Order (MRO)","text":"<p>To see the MRO for any class, you can use the <code>mro()</code> method or the <code>__mro__</code> attribute:</p> <pre><code>print(D.mro())       # Output: [&lt;class '__main__.D'&gt;, &lt;class '__main__.B'&gt;, &lt;class '__main__.C'&gt;, &lt;class '__main__.A'&gt;, &lt;class 'object'&gt;]\nprint(D.__mro__)     # Same as above\n</code></pre> <p>The MRO indicates that:</p> <ol> <li>D checks B first,</li> <li>Then checks C,</li> <li>Then checks A,</li> <li>Finally checks the base class object.</li> </ol>","tags":["Python","Javascript"]},{"location":"blog/2024/07/25/how-to-order-multiple-inheritance-in-python-and-what-is-the-order-of-execution/#3-changing-the-inheritance-order","title":"3. Changing the Inheritance Order","text":"<p>If you want to prioritize a different class, simply change the order in which you list the parent classes in your definition.</p> <pre><code>class D(C, B):  # Now C is checked before B\n    pass\n\nd_instance = D()\nprint(d_instance.greet())  # Output: \"Hello from C\"\n</code></pre>","tags":["Python","Javascript"]},{"location":"blog/2024/07/25/how-to-order-multiple-inheritance-in-python-and-what-is-the-order-of-execution/#summary-of-execution-order","title":"Summary of Execution Order","text":"<ol> <li>First: Check the first parent class.</li> <li>Second: If the method isn\u2019t found, check the next parent in the order.</li> <li>Continue: This continues down the MRO until a method is found or all classes are checked.</li> <li>Finally: If no method is found, Python raises an <code>AttributeError</code>.</li> </ol>","tags":["Python","Javascript"]},{"location":"blog/2024/07/25/how-to-order-multiple-inheritance-in-python-and-what-is-the-order-of-execution/#conclusion","title":"Conclusion","text":"<p>By defining the order of parent classes in your class declaration, you control the MRO and thus the order of execution for methods in a multiple inheritance scenario.</p>","tags":["Python","Javascript"]},{"location":"blog/2024/07/25/how-to-order-multiple-inheritance-in-python-and-what-is-the-order-of-execution/#additonal","title":"Additonal","text":"<p>Example 1: Animal Classes</p> <p>Imagine a scenario with different types of animals and their sounds.</p> ExampleExplanation <pre><code>class Animal:\n    def sound(self):\n        return \"Some generic sound\"\n\nclass Dog(Animal):\n    def sound(self):\n        return \"Bark\"\n\nclass Cat(Animal):\n    def sound(self):\n        return \"Meow\"\n\nclass Poodle(Dog):\n    def sound(self):\n        return \"Woof\"\n\nclass PersianCat(Cat):\n    def sound(self):\n        return \"Purr\"\n\nclass Pet(Poodle, PersianCat):\n    pass\n\npet = Pet()\nprint(pet.sound())  # Output: \"Woof\"\nprint(Pet.mro())    # Output: [&lt;class '__main__.Pet'&gt;, &lt;class '__main__.Poodle'&gt;, &lt;class '__main__.PersianCat'&gt;, &lt;class '__main__.Cat'&gt;, &lt;class '__main__.Animal'&gt;, &lt;class 'object'&gt;]\n</code></pre> <ul> <li>When calling <code>pet.sound()</code>, Python first checks <code>Poodle</code> (since it\u2019s listed first), finds the <code>sound</code> method there, and executes it.</li> <li>The MRO shows the order in which Python checks for methods.</li> </ul> <p>Example 2: Working with Vehicles</p> <p>Consider a scenario involving different types of vehicles.</p> ExampleExplanation <pre><code>class Vehicle:\n    def drive(self):\n        return \"Driving a vehicle\"\n\nclass Car(Vehicle):\n    def drive(self):\n        return \"Driving a car\"\n\nclass Truck(Vehicle):\n    def drive(self):\n        return \"Driving a truck\"\n\nclass ElectricCar(Car):\n    def drive(self):\n        return \"Driving an electric car\"\n\nclass HybridTruck(Truck):\n    pass\n\nclass SuperTruck(HybridTruck, ElectricCar):\n    pass\n\nsuper_truck = SuperTruck()\nprint(super_truck.drive())  # Output: \"Driving a truck\"\nprint(SuperTruck.mro())      # Output: [&lt;class '__main__.SuperTruck'&gt;, &lt;class '__main__.HybridTruck'&gt;, &lt;class '__main__.Truck'&gt;, &lt;class '__main__.Vehicle'&gt;, &lt;class 'object'&gt;]\n</code></pre> <ul> <li>In this case, <code>SuperTruck</code> inherits from <code>HybridTruck</code> (which in turn inherits from <code>Truck</code>). The drive method from <code>Truck</code> is called because it's higher up the hierarchy compared to <code>ElectricCar</code>.</li> </ul> <p>Example 3: Mixing Behaviors</p> <p>Let\u2019s create a scenario where we mix different behaviors using multiple inheritance.</p> ExampleExplanation <pre><code>class Swimmer:\n    def swim(self):\n        return \"Swimming\"\n\nclass Flyer:\n    def fly(self):\n        return \"Flying\"\n\nclass Duck(Swimmer, Flyer):\n    def quack(self):\n        return \"Quack\"\n\nduck = Duck()\nprint(duck.swim())  # Output: \"Swimming\"\nprint(duck.fly())   # Output: \"Flying\"\nprint(duck.quack()) # Output: \"Quack\"\nprint(Duck.mro())    # Output: [&lt;class '__main__.Duck'&gt;, &lt;class '__main__.Swimmer'&gt;, &lt;class '__main__.Flyer'&gt;, &lt;class 'object'&gt;]\n</code></pre> <ul> <li>Here, <code>Duck</code> inherits both swimming and flying behaviors from <code>Swimmer</code> and <code>Flyer</code>. It showcases how multiple inheritance allows a class to combine functionalities from different classes.</li> </ul> <p>Summary</p> <p>These examples illustrate how multiple inheritance works in Python, how methods are resolved based on the MRO, and how you can effectively design your classes to leverage multiple inheritance for combining behaviors and functionalities.</p>","tags":["Python","Javascript"]},{"location":"blog/2024/06/17/installation-django/","title":"Installation Django","text":"","tags":["django","python"]},{"location":"blog/2024/06/17/installation-django/#installation-django","title":"Installation Django","text":"<p>To install Django, you must have Python installed, and a package manager like PIP. In other words, using ~=4.0 ensures that you get the latest minor release of Django within the 4.0 series. For example, it could install Django 4.0.1, 4.0.2, 4.1.0, etc., but it won't install Django 5.0 or higher.</p> Install DjangoVerify installation <p>install</p> <pre><code>pip install django~=4.0\n</code></pre> <p>verify</p> <pre><code>django-admin --version\n</code></pre>","tags":["django","python"]},{"location":"blog/2024/06/17/installation-django/#using-poetry-python-dependency-management-tool","title":"Using Poetry (Python dependency management tool)","text":"<p>If you prefer using Poetry for managing dependencies:</p> <ol> <li> <p>Install Poetry: Install Poetry by following the instructions at python-poetry.org.</p> </li> <li> <p>Create a new Django project and install Django 4:</p> <pre><code>poetry new myproject\ncd myproject\npoetry add django~=4.0\n</code></pre> </li> <li> <p>Activate virtual environment: Poetry automatically creates a virtual environment for each project. To activate it, run:</p> <pre><code>poetry shell\n</code></pre> </li> <li> <p>Verify installation: Check Django version:</p> <pre><code>python -m django --version\n</code></pre> </li> </ol> <ul> <li>Django: ImproperlyConfigured: The SECRET_KEY setting must not be empty: stackoverflow</li> </ul>","tags":["django","python"]},{"location":"blog/2024/07/16/mastering-apis-the-key-to-unlocking-advanced-web-programming-skills/","title":"Mastering APIs: The Key to Unlocking Advanced Web Programming Skills","text":"","tags":["mastering","onething","skills","api"]},{"location":"blog/2024/07/16/mastering-apis-the-key-to-unlocking-advanced-web-programming-skills/#mastering-apis-the-key-to-unlocking-advanced-web-programming-skills","title":"Mastering APIs: The Key to Unlocking Advanced Web Programming Skills","text":"<p>Mastering web programming involves a lot of skills, but if I had to distill it down to one absolute thing, it would be understanding how to effectively use and integrate APIs. APIs (Application Programming Interfaces) are fundamental for modern web development as they allow different software systems to communicate with each other.</p> what is the absolute one thing to master the web programing","tags":["mastering","onething","skills","api"]},{"location":"blog/2024/07/16/mastering-apis-the-key-to-unlocking-advanced-web-programming-skills/#heres-why-mastering-apis-is-crucial","title":"Here\u2019s why mastering APIs is crucial:","text":"<ol> <li> <p>Data Integration: APIs allow you to connect your web application to external services, databases, and platforms. Whether you\u2019re pulling in data from a weather service, social media, or an internal database, understanding how to use APIs efficiently is essential.</p> </li> <li> <p>Enhanced Functionality: Many modern applications rely on third-party APIs to extend their capabilities, like payment gateways, authentication services, or mapping tools. Mastery of APIs means you can leverage these tools effectively.</p> </li> <li> <p>Interactivity: APIs often enable interactive features on websites, such as real-time updates, user authentication, and dynamic content. Knowing how to integrate these features can make your web applications more engaging and functional.</p> </li> <li> <p>Scalability: APIs help in building scalable and modular applications. Understanding how to create and consume APIs can help you design your applications in a more maintainable and scalable way.</p> </li> </ol>","tags":["mastering","onething","skills","api"]},{"location":"blog/2024/07/16/mastering-apis-the-key-to-unlocking-advanced-web-programming-skills/#to-truly-master-this-you-should-be-comfortable-with","title":"To truly master this, you should be comfortable with:","text":"<ul> <li>Making API requests: Using tools and libraries to fetch and send data.</li> <li>Handling responses: Parsing and using data returned by APIs.</li> <li>Error handling: Managing issues that arise from API interactions.</li> <li>Authentication and security: Ensuring secure interactions with APIs, including understanding OAuth and other authentication methods.</li> </ul> <p>Of course, this is built on foundational knowledge of HTML, CSS, JavaScript, and backend technologies, but API mastery is often where advanced and practical skills come into play.</p>","tags":["mastering","onething","skills","api"]},{"location":"blog/2024/04/17/managing-settings-for-multiple-environments-in-django/","title":"Managing settings for multiple environments in django","text":"","tags":["Programming","Django"]},{"location":"blog/2024/04/17/managing-settings-for-multiple-environments-in-django/#managing-settings-for-multiple-environments-in-django","title":"Managing settings for multiple environments in django","text":"<p>In real-world projects, you will have to deal with multiple environments. we have at least a local environment for development and a production environment for serving your application. </p> <p>we will use a base file that defines common settings, and a settings file per environment that overrides any necessary settings and defines additional ones.</p> <p>Create a <code>settings/</code> directory next to the <code>settings.py</code> file of the your project. Rename the <code>settings.py</code> file to <code>base.py</code> and move it into the new <code>settings/</code> directory.</p> <p>Create the following additional files inside the <code>settings/</code> folder so that the new directory looks as follows:</p> <pre><code>settings/\n    __init__.py\n    base.py\n    local.py\n    prod.py\n</code></pre> <p>These files are as follows:</p> <ul> <li><code>base.py</code>: The base settings file that contains common settings (previously <code>settings.py</code>)</li> <li><code>local.py</code>: Custom settings for your local environment</li> <li><code>prod.py</code>: Custom settings for the production environment</li> </ul> <p>You have moved the settings files to a directory one level below, so you need to update the BASE_DIR setting in the <code>settings/base.py</code> file to point to the main project directory.</p> <p>When handling multiple environments, create a base settings file and a settings file for each environment. Environment settings files should inherit the common settings and override environment-specific settings.</p> <p>Edit the <code>settings/base.py</code> file and replace the following line:</p> <pre><code>BASE_DIR = Path(__file__).resolve().parent.parent\n</code></pre> <p>with the following one:</p> <p>settings/base.py</p> <pre><code>BASE_DIR = Path(__file__).resolve().parent.parent.parent\n</code></pre> <p>You point to one directory above by adding .parent to the BASE_DIR path. Let\u2019s configure the settings for the local environment.</p>","tags":["Programming","Django"]},{"location":"blog/2024/04/17/managing-settings-for-multiple-environments-in-django/#local-environment-settings","title":"Local environment settings","text":"<p>Instead of using a default configuration for the DEBUG and DATABASES settings, you will define them for each environment explicitly. These settings will be environment specific. Edit the <code>settings/local.py</code> file and add the following lines:</p> local.py<pre><code>from .base import *\n\nDEBUG = True\n\nDATABASES = {\n    'default': {\n        'ENGINE': 'django.db.backends.sqlite3',\n        'NAME': BASE_DIR / 'db.sqlite3',\n    }\n}\n</code></pre> <p>This is the settings file for your local environment. In this file, you import all settings defined in the <code>base.py</code> file, and you define the DEBUG and DATABASES settings for this environment. The DEBUG and DATABASES settings remain the same as you have been using for development.</p> <p>Now remove the DATABASES and DEBUG settings from the <code>base.py</code> settings file.</p> <p>Django management commands won\u2019t automatically detect the settings file to use because the project settings file is not the default <code>settings.py</code> file. When running management commands, you need to indicate the settings module to use by adding a <code>--settings</code> option, as follows:</p> <p>Python</p> <pre><code>python manage.py runserver --settings=educa.settings.local\n</code></pre> <p>Next, we are going to validate the project and the local environment configuration.</p>","tags":["Programming","Django"]},{"location":"blog/2024/04/17/managing-settings-for-multiple-environments-in-django/#defining-environment-variable","title":"Defining environment variable","text":"<p>If don\u2019t want to pass the <code>--settings</code> option every time you run a management command, you can define the DJANGO_SETTINGS_MODULE environment variable. Django will use it to identify the settings module to use. </p> <p>If you are using Linux or macOS, you can define the environment variable by executing the following command in the shell:</p> <p>Linux</p> <pre><code>export DJANGO_SETTINGS_MODULE=educa.settings.local\n</code></pre> <p>To remove an environment variable in Linux, including one set with the syntax <code>export VARIABLE=\"value\"</code>, you can unset it using the unset command. </p> <p>Linux</p> <pre><code>unset VARIABLE\n</code></pre> <p>If you are using Windows, you can execute the following command in the shell:</p> <p>Windows</p> <pre><code>set DJANGO_SETTINGS_MODULE=educa.settings.local\n</code></pre> <p>Any management command you execute after will use the settings defined in the DJANGO_SETTINGS_MODULE environment variable.</p>","tags":["Programming","Django"]},{"location":"blog/2024/04/17/managing-settings-for-multiple-environments-in-django/#production-environment-settings","title":"Production environment settings","text":"<p>Let\u2019s start by adding initial settings for the production environment. Edit the <code>settings/prod.py</code> file and make it look as follows:</p> prod.py<pre><code>from .base import *\n\nDEBUG = False\n\nADMINS = [\n    ('Antonio M', 'email@mydomain.com'),\n]\n\nALLOWED_HOSTS = ['*']\n\nDATABASES = {\n    'default': {\n    }\n}\n</code></pre> <p>These are the settings for the production environment:</p> <ul> <li><code>DEBUG</code>: Setting DEBUG to False is necessary for any production environment. Failing to do so will result in the traceback information and sensitive configuration data being exposed to everyone.</li> <li><code>ADMINS</code>: When DEBUG is False and a view raises an exception, all information will be sent by email to the people listed in the ADMINS setting. Make sure that you replace the name/email tuple with your own information.</li> <li><code>ALLOWED_HOSTS</code>: For security reasons, Django will only allow the hosts included in this list to serve the project. For now, you allow all hosts by using the asterisk symbol, <code>*</code>. You will limit the hosts that can be used for serving the project later.</li> <li><code>DATABASES</code>: You keep default database settings empty because you will configure the production database later.</li> </ul>","tags":["Programming","Django"]},{"location":"blog/2024/04/17/managing-settings-for-multiple-environments-in-django/#reference","title":"Reference","text":"<ul> <li>Configuring Django Settings: Best Practices </li> <li>Configuring Django Settings: Best Practices: 2 </li> <li>Django 4 By Example Fourth Edition: pg-672</li> </ul>","tags":["Programming","Django"]},{"location":"blog/2024/06/22/managing-multiple-python-versions-with-pyenv/","title":"Managing Multiple Python Versions With pyenv","text":"","tags":["pyenv","version","python"]},{"location":"blog/2024/06/22/managing-multiple-python-versions-with-pyenv/#managing-multiple-python-versions-with-pyenv","title":"Managing Multiple Python Versions With pyenv","text":"<p>pyenv: Allows you to install and manage multiple versions of Python on your machine.</p> <pre><code>pyenv install --list\n\npyenv install 3.8.12\n\n# After installation, set Python 3.8 as the global or local version:\npyenv global 3.8.12\n</code></pre> Steps to Resolve: <p>To resolve this issue and ensure that pipenv uses Python 3.8.1 as specified:</p> <ol> <li> <p>Verify pyenv Installation:</p> <p>Confirm that <code>pyenv</code> has successfully installed Python 3.8.1 and it is available:</p> <pre><code>pyenv versions\n</code></pre> <p>Ensure that <code>3.8.1</code> is listed as one of the installed versions.</p> </li> <li> <p>Set Global Python Version:</p> <p>Set Python <code>3.8.1</code> as the global version to ensure all pipenv commands use this version:</p> <pre><code>pyenv global 3.8.1\n</code></pre> <p>This command sets Python 3.8.1 globally, so pipenv will use it when creating environments.</p> </li> <li> <p>Recreate pipenv Environment:</p> <p>Remove the existing <code>pipenv</code> environment (if it's not set up correctly) and recreate it to ensure it uses Python 3.8.1:</p> <pre><code>pipenv --rm  # Remove existing environment\npipenv --python 3.8.1  # Recreate environment with Python 3.8.1\n</code></pre> <p>This will delete the current pipenv environment and recreate it using Python 3.8.1 specified by pyenv.</p> </li> <li> <p>Update Pipfile Configuration:</p> <p>After recreating the environment, ensure the Pipfile reflects the correct Python version:</p> <pre><code>cat Pipfile\n</code></pre> <p>Update <code>[requires]</code> section to specify python_version = \"3.8\" instead of <code>3.12</code> if necessary</p> </li> <li> <p>Activate pipenv Environment:</p> <p>Activate the <code>pipenv</code> environment to start using it for your project:</p> <pre><code>pipenv shell\n</code></pre> <p>This command activates the virtual environment and sets up the environment variables accordingly.</p> </li> </ol> <p>Additional Considerations:</p> <ul> <li> <p>Shell Configuration: Ensure that your shell configuration (e.g., <code>~/.bashrc</code>, <code>~/.zshrc</code>) reflects the correct pyenv settings and Python version. Sometimes, restarting your shell session after setting the global Python version (<code>pyenv global 3.8.1</code>) can help apply the changes correctly.</p> </li> <li> <p>Clean Environment: If issues persist, consider cleaning up any residual files or caches (<code>pipenv --clear</code>) and retrying the steps above.</p> </li> </ul> <p>By following these steps, you should be able to resolve the issue where pipenv is using the incorrect Python version and ensure it uses Python 3.8.1 as intended. This aligns your development environment properly and ensures consistency across your project.</p>","tags":["pyenv","version","python"]},{"location":"blog/2024/06/22/managing-multiple-python-versions-with-pyenv/#reference","title":"Reference","text":"<ul> <li>Managing Multiple Python Versions With pyenv</li> </ul>","tags":["pyenv","version","python"]},{"location":"blog/2024/07/07/mastering-django-configuration/","title":"Mastering Django Configuration","text":"","tags":["django","env"]},{"location":"blog/2024/07/07/mastering-django-configuration/#mastering-django-configuration","title":"Mastering Django Configuration","text":"<p>Mastering the <code>django-environ</code> package involves understanding how to use it effectively for managing environment variables in Django projects. </p> Mastering Django Configuration: A Comprehensive Guide to Using django-environ <p>Here's a comprehensive guide to help you get a good grasp of it:</p> <p>Understanding django-environ</p> <p><code>django-environ</code> is a Django package that allows you to handle environment variables and configuration settings in a clean and manageable way. It integrates with Django\u2019s settings module to load environment variables from <code>.env</code> files or other sources.</p> <ol> <li> <p>Installation</p> <p>Start by installing <code>django-environ</code> via pip:</p> <pre><code>pip install django-environ\n</code></pre> </li> <li> <p>Setting Up <code>.env</code> File</p> <p>Create a <code>.env</code> file in the root of your Django project. This file will store your environment variables. Here\u2019s an example <code>.env</code> file:</p> <pre><code>DEBUG=True\nSECRET_KEY=your-secret-key\nDATABASE_URL=postgres://user:password@localhost/dbname\nALLOWED_HOSTS=localhost,127.0.0.1\n</code></pre> </li> <li> <p>Configuring <code>django-environ</code> in Django Settings</p> <p>Modify your Django settings file (<code>settings.py</code>) to use <code>django-environ</code>. Here\u2019s a step-by-step process:</p> <ol> <li> <p>Import <code>environ</code> and initialize it:</p> <pre><code>import environ\n\n# Initialise environment variables\nenv = environ.Env()\n</code></pre> </li> <li> <p>Read the <code>.env</code> file:</p> <pre><code># Read the .env file if it exists\nenviron.Env.read_env()\n</code></pre> </li> <li> <p>Replace existing settings with environment variables:</p> <pre><code>DEBUG = env.bool(\"DEBUG\", default=False)\nSECRET_KEY = env(\"SECRET_KEY\")\nDATABASES = {\n    'default': env.db(),  # Reads DATABASE_URL\n}\nALLOWED_HOSTS = env.list(\"ALLOWED_HOSTS\", default=[])\n</code></pre> <ul> <li><code>env.bool()</code>: Converts environment variable to boolean.</li> <li><code>env()</code>: Retrieves string values.</li> <li><code>env.db()</code>: Parses and retrieves database configurations.</li> <li><code>env.list()</code>: Converts a comma-separated string into a list.</li> </ul> </li> </ol> </li> <li> <p>Advanced Usage</p> <ul> <li> <p>Default Values and Casting:</p> <p>You can specify default values and cast types:</p> <pre><code>MY_SETTING = env.int(\"MY_SETTING\", default=42)\n</code></pre> </li> <li> <p>Custom Parsers:</p> <p>You can create custom parsers for special types or formats if needed.</p> </li> <li> <p>Environment-Specific Files:</p> <p>For different environments (development, production), you might have different <code>.env</code> files like <code>.env.development</code> or <code>.env.production</code>. You can specify which file to read based on the environment.</p> </li> </ul> </li> <li> <p>Security Considerations</p> <ul> <li> <p>Keep <code>.env</code> File Secure:</p> <p>Ensure the <code>.env</code> file is not committed to version control. Add <code>.env</code> to your <code>.gitignore</code>.</p> </li> <li> <p>Use Environment Variables in Deployment:</p> <p>In production, consider setting environment variables directly in the hosting environment or using tools like Docker or Kubernetes.</p> </li> </ul> </li> <li> <p>Testing</p> <ul> <li> <p>Testing Locally:</p> <p>Ensure your <code>.env</code> file is correctly loaded and variables are applied as expected.</p> </li> <li> <p>Testing Deployment:</p> <p>Verify that environment variables are correctly set in the deployment environment and that your application behaves as expected.</p> </li> </ul> </li> </ol>","tags":["django","env"]},{"location":"blog/2024/07/07/mastering-django-configuration/#example-usage-in-django-settingspy","title":"Example Usage in Django settings.py","text":"<p>Here\u2019s an example of how you might use these data types in your Django settings:</p> <pre><code>import environ\n\nenv = environ.Env()\nenviron.Env.read_env()\n\nDEBUG = env.bool(\"DEBUG\", default=False)\nSECRET_KEY = env(\"SECRET_KEY\")\nDATABASES = {\n    'default': env.db(),  # Parses DATABASE_URL\n}\nALLOWED_HOSTS = env.list(\"ALLOWED_HOSTS\", default=[])\nCACHE_TIMEOUT = env.int(\"CACHE_TIMEOUT\", default=300)\nLOGGING_LEVEL = env(\"LOGGING_LEVEL\", default=\"INFO\")\n</code></pre>","tags":["django","env"]},{"location":"blog/2024/07/07/mastering-django-configuration/#data-types-supported-explanation","title":"Data types supported: Explanation","text":"<ol> <li> <p>String: Directly retrieved using <code>env()</code>. No casting needed.</p> <pre><code>MY_STRING = env(\"MY_STRING\", default=\"Default String\")\n</code></pre> </li> <li> <p>Integer: Use <code>env.int()</code> to convert the environment variable to an integer.</p> <pre><code>MY_INT = env.int(\"MY_INT\", default=0)\n</code></pre> </li> <li> <p>Float: Use <code>env.float()</code> to convert the environment variable to a float.</p> <pre><code>MY_FLOAT = env.float(\"MY_FLOAT\", default=0.0)\n</code></pre> </li> <li> <p>Boolean: Use <code>env.bool()</code> to convert the environment variable to a boolean.</p> <pre><code>MY_BOOL = env.bool(\"MY_BOOL\", default=False)\n</code></pre> </li> <li> <p>List: Use <code>env.list()</code> to convert a comma-separated string to a list.</p> <pre><code>MY_LIST = env.list(\"MY_LIST\", default=[])\n</code></pre> </li> <li> <p>Dictionary: Use <code>json.loads()</code> to parse a JSON formatted string into a dictionary.</p> <pre><code>import json\nMY_DICT = json.loads(env(\"MY_DICT\", default='{\"key\": \"value\"}'))\n</code></pre> </li> <li> <p>URL: Use <code>env.db()</code> to parse a database URL into a Django-compatible database configuration.</p> <pre><code>DATABASES = {\n    'default': env.db(),\n}\n</code></pre> </li> <li> <p>File Path: Retrieve file paths as strings.</p> <pre><code>MY_FILE_PATH = env(\"MY_FILE_PATH\", default=\"/default/path\")\n</code></pre> </li> <li> <p>Custom Type: Define a custom parser function and use it with the cast argument in env().</p> <pre><code>def parse_custom(value):\n    # Custom parsing logic\n    return value\n\nMY_CUSTOM_TYPE = env(\"MY_CUSTOM_TYPE\", default=\"default_value\", cast=parse_custom)\n</code></pre> </li> </ol> <p>This setup allows you to handle a wide range of data types in your Django application using django-environ, making your configuration more flexible and manageable.</p>","tags":["django","env"]},{"location":"blog/2024/07/07/mastering-django-configuration/#real-time-example","title":"Real Time Example","text":"","tags":["django","env"]},{"location":"blog/2024/07/07/mastering-django-configuration/#env","title":"env","text":"<pre><code># Django Secret Key - String\nSECRET_KEY=your-secret-key-here\n\n# Debug mode - Boolean\nDEBUG=True\n\n# Allowed Hosts - List (comma-separated values)\nALLOWED_HOSTS=localhost,127.0.0.1,example.com\n\n# Database URL - URL\nDATABASE_URL=postgres://user:password@localhost:5432/mydatabase\n\n# Redis URL - URL (for caching or other purposes)\nREDIS_URL=redis://127.0.0.1:6379/1\n\n# Cache Timeout - Integer\nCACHE_TIMEOUT=300\n\n# Max Upload Size - Integer (size in MB)\nMAX_UPLOAD_SIZE_MB=10\n\n# API Key - String\nAPI_KEY=your-api-key-here\n\n# Log Level - String (e.g., DEBUG, INFO, WARNING)\nLOG_LEVEL=INFO\n\n# Feature Toggle - Boolean\nFEATURE_TOGGLE=True\n\n# Number of Retries - Integer\nNUM_RETRIES=5\n\n# Timeout in Seconds - Float\nTIMEOUT_SECONDS=2.5\n\n# File Upload Path - File Path\nFILE_UPLOAD_PATH=/path/to/uploads\n\n# Custom Data - Dictionary (JSON formatted string)\nCUSTOM_SETTINGS={\"feature_enabled\": true, \"max_items\": 100}\n\n# Custom Value - Example for custom type\nCUSTOM_VALUE=custom_value\n</code></pre>","tags":["django","env"]},{"location":"blog/2024/07/07/mastering-django-configuration/#how-to-use-the-env-variables-in-settingspy","title":"How to Use the .env Variables in settings.py","text":"<p>Here's how to read these variables in your Django settings.py using django-environ:</p> <pre><code>import environ\nimport json\n\n# Initialize environment variables\nenv = environ.Env()\n# Read the .env file\nenviron.Env.read_env()\n\n# Secret Key - String\nSECRET_KEY = env(\"SECRET_KEY\")\n\n# Debug mode - Boolean\nDEBUG = env.bool(\"DEBUG\", default=False)\n\n# Allowed Hosts - List\nALLOWED_HOSTS = env.list(\"ALLOWED_HOSTS\", default=[])\n\n# Database Configuration - URL\nDATABASES = {\n    'default': env.db(),  # Parses DATABASE_URL\n}\n\n# Redis Configuration - URL\nREDIS_URL = env(\"REDIS_URL\")\n\n# Cache Timeout - Integer\nCACHE_TIMEOUT = env.int(\"CACHE_TIMEOUT\", default=300)\n\n# Max Upload Size - Integer\nMAX_UPLOAD_SIZE_MB = env.int(\"MAX_UPLOAD_SIZE_MB\", default=10)\n\n# API Key - String\nAPI_KEY = env(\"API_KEY\")\n\n# Log Level - String\nLOG_LEVEL = env(\"LOG_LEVEL\", default=\"INFO\")\n\n# Feature Toggle - Boolean\nFEATURE_TOGGLE = env.bool(\"FEATURE_TOGGLE\", default=False)\n\n# Number of Retries - Integer\nNUM_RETRIES = env.int(\"NUM_RETRIES\", default=3)\n\n# Timeout in Seconds - Float\nTIMEOUT_SECONDS = env.float(\"TIMEOUT_SECONDS\", default=5.0)\n\n# File Upload Path - File Path\nFILE_UPLOAD_PATH = env(\"FILE_UPLOAD_PATH\", default=\"/default/path\")\n\n# Custom Data - Dictionary (JSON formatted string)\nCUSTOM_SETTINGS = json.loads(env(\"CUSTOM_SETTINGS\", default='{\"feature_enabled\": false, \"max_items\": 10}'))\n\n# Custom Value - Example for custom type\ndef parse_custom(value):\n    # Example custom parsing logic\n    return value\n\nCUSTOM_VALUE = env(\"CUSTOM_VALUE\", default=\"default_value\", cast=parse_custom)\n\n# Example usage (print settings)\nprint(\"Secret Key:\", SECRET_KEY)\nprint(\"Debug Mode:\", DEBUG)\nprint(\"Allowed Hosts:\", ALLOWED_HOSTS)\nprint(\"Database URL:\", DATABASES['default'])\nprint(\"Redis URL:\", REDIS_URL)\nprint(\"Cache Timeout:\", CACHE_TIMEOUT)\nprint(\"Max Upload Size (MB):\", MAX_UPLOAD_SIZE_MB)\nprint(\"API Key:\", API_KEY)\nprint(\"Log Level:\", LOG_LEVEL)\nprint(\"Feature Toggle:\", FEATURE_TOGGLE)\nprint(\"Number of Retries:\", NUM_RETRIES)\nprint(\"Timeout Seconds:\", TIMEOUT_SECONDS)\nprint(\"File Upload Path:\", FILE_UPLOAD_PATH)\nprint(\"Custom Settings:\", CUSTOM_SETTINGS)\nprint(\"Custom Value:\", CUSTOM_VALUE)\n</code></pre>","tags":["django","env"]},{"location":"blog/2024/07/07/mastering-django-configuration/#explanation","title":"Explanation","text":"<ol> <li>String Values: Directly retrieved with <code>env()</code>.</li> <li>Boolean Values: Use <code>env.bool()</code>.</li> <li>List Values: Use <code>env.list()</code> to parse comma-separated values.</li> <li>Dictionary Values: Use <code>json.loads()</code> to parse JSON strings into dictionaries.</li> <li>Integer and Float Values: Use <code>env.int()</code> and <code>env.float()</code>.</li> <li>URLs: Use <code>env.db()</code> for database URLs and retrieve other URLs directly.</li> <li>File Paths: Retrieved as strings.</li> </ol> <p>This example demonstrates how to handle different data types effectively using <code>django-environ</code>, making your Django project configuration more flexible and manageable.</p>","tags":["django","env"]},{"location":"blog/2024/07/07/mastering-django-configuration/#quotes","title":"Quotes","text":"<p>In a <code>.env</code> file used with django-environ, the handling of quotes depends on the context of the data type. Here\u2019s a breakdown of when and why you might use or omit quotes:</p>","tags":["django","env"]},{"location":"blog/2024/07/07/mastering-django-configuration/#when-to-use-quotes","title":"When to Use Quotes","text":"<ol> <li> <p>String Values:</p> <ul> <li> <p>No Special Characters: For simple strings, quotes are optional.</p> </li> <li> <p>Special Characters or Spaces: Quotes are useful if the string contains special characters or spaces.</p> <pre><code>STRING_WITH_SPACES=\"Hello World\"\nSTRING_WITH_SPECIAL_CHAR=\"Hello$World\"\n</code></pre> </li> </ul> </li> <li> <p>List Values (Comma-Separated):</p> <ul> <li> <p>Quotes are generally not needed if there are no spaces or special characters.</p> <pre><code>LIST_VALUES=item1,item2,item3\n</code></pre> </li> <li> <p>Use quotes if the list items contain commas or spaces:</p> <pre><code>LIST_VALUES=\"item1, item2, item3\"\n</code></pre> </li> </ul> </li> <li> <p>JSON or Complex Data Structures:</p> <ul> <li> <p>Quotes are necessary for JSON formatted strings.</p> <pre><code>JSON_DATA=\"{\\\"key1\\\": \\\"value1\\\", \\\"key2\\\": \\\"value2\\\"}\"\n</code></pre> </li> </ul> </li> <li> <p>Custom Types or Data Structures:</p> <ul> <li> <p>For custom parsers or data structures like JSON, quotes are typically required to ensure the entire value is treated as a single string.</p> <pre><code>CUSTOM_DATA=\"some_custom_data\"\n</code></pre> </li> </ul> </li> </ol>","tags":["django","env"]},{"location":"blog/2024/07/07/mastering-django-configuration/#when-quotes-are-not-needed","title":"When Quotes are Not Needed","text":"<ol> <li> <p>Integer and Float Values:</p> <ul> <li> <p>These can be written directly without quotes, as they are parsed into numbers</p> <pre><code>INTEGER_VALUE=123\nFLOAT_VALUE=3.14\n</code></pre> </li> </ul> </li> <li> <p>Boolean Values:</p> <ul> <li> <p>Use boolean literals without quotes.</p> <pre><code>BOOLEAN_TRUE=True\nBOOLEAN_FALSE=False\n</code></pre> </li> </ul> </li> <li> <p>URLs and File Paths:</p> <ul> <li> <p>These are often written without quotes unless they contain spaces or special characters.</p> <pre><code>DATABASE_URL=postgres://user:password@localhost:5432/mydatabase\nFILE_PATH=/path/to/file\n</code></pre> </li> </ul> </li> </ol> <p>Summary</p> <ul> <li>No Quotes Needed: For simple strings, integers, floats, booleans, URLs, and file paths, quotes are generally optional unless special characters or spaces are involved.</li> <li>Quotes Recommended: For strings containing spaces, special characters, or JSON data, using quotes ensures that the entire value is interpreted correctly.</li> </ul>","tags":["django","env"]},{"location":"blog/2024/07/07/mastering-django-configuration/#example-env-file-with-quotes-and-without-quotes","title":"Example <code>.env</code> File with Quotes and Without Quotes","text":"<pre><code># Simple String (no quotes needed)\nSIMPLE_STRING=HelloWorld\n\n# String with Spaces (quotes needed)\nSTRING_WITH_SPACES=\"Hello World\"\n\n# Integer (no quotes needed)\nINTEGER_VALUE=123\n\n# Float (no quotes needed)\nFLOAT_VALUE=3.14\n\n# Boolean (no quotes needed)\nBOOLEAN_TRUE=True\n\n# URL (no quotes needed)\nDATABASE_URL=postgres://user:password@localhost:5432/mydatabase\n\n# File Path (no quotes needed)\nFILE_PATH=/path/to/file\n\n# JSON Data (quotes needed)\nJSON_DATA=\"{\\\"key1\\\": \\\"value1\\\", \\\"key2\\\": \\\"value2\\\"}\"\n\n# List (no quotes if simple, use quotes if items contain commas or spaces)\nLIST_VALUES=item1,item2,item3\nLIST_VALUES_WITH_QUOTES=\"item1, item2, item3\"\n</code></pre> <p>By following these guidelines, you can ensure that your <code>.env</code> file is correctly interpreted by <code>django-environ</code>, and the environment variables are loaded properly into your Django settings.</p>","tags":["django","env"]},{"location":"blog/2024/06/24/mixins-in-python/","title":"Mixins in python","text":"","tags":["django"]},{"location":"blog/2024/06/24/mixins-in-python/#mixins-in-python","title":"Mixins in python","text":"<p>Mixins in Python are a concept used in object-oriented programming to promote code reuse and add functionality to classes. A mixin is a class that provides methods to other classes through inheritance but is not intended to stand alone. Mixins are typically used to \"mix in\" additional behavior to classes, enabling the composition of complex behaviors from simpler ones.</p> <ul> <li>django braces - Reusable, generic mixins for Django</li> </ul>","tags":["django"]},{"location":"blog/2024/06/24/mixins-in-python/#introduction","title":"Introduction","text":"<p>Mixins are the essence of DRY code in <code>class-based views</code>. Like model mixins, a view mixin takes advantage of Python's multiple inheritance to easily reuse chunks of functionality.</p> <p>They are often <code>parent-less classes</code> in Python 3 (or derived from <code>object</code> in Python 2 since they are new-style classes).</p>","tags":["django"]},{"location":"blog/2024/06/24/mixins-in-python/#order-of-mixins","title":"Order of mixins","text":"<p>You might have come across code with several mixins as follows:</p> <pre><code>class ComplexView(MyMixin, YourMixin, AccessMixin, DetailView):\n</code></pre> <p>It can get quite tricky figuring out the order to list the base classes. Like most things in Django, the normal rules of Python apply. Python's Method Resolution Order (MRO) determines how they should be arranged.</p> <p>In a nutshell, mixins come first and base classes come last. The more specialized the parent class is, the more it moves to the left. In practice, this is the only rule you will need to remember.</p> <p>Note</p> <p>Python's MRO usually follows a depth-first, left-to-right order to select a method in the class hierarchy. More details can be found</p> example BasicExample <p>Key Characteristics of Mixins</p> <ol> <li>Reusability: Mixins are designed to be reusable across multiple classes.</li> <li>Single Responsibility: Each mixin typically focuses on a single piece of functionality.</li> <li>Composition: Mixins allow for the composition of behaviors in a flexible way, avoiding deep inheritance hierarchies.</li> <li>Not Standalone: Mixins are not meant to be instantiated on their own; they are used to augment other classes.</li> </ol> <p>Advantages of Using Mixins</p> <ol> <li>Modularity: Mixins help in breaking down complex behaviors into smaller, manageable pieces.</li> <li>Avoidance of Multiple Inheritance Issues: Mixins allow the combination of behaviors without the complications that often arise with multiple inheritance.</li> <li>Code Reuse: Common functionalities can be extracted into mixins and reused across different classes.</li> </ol> <p>When to Use Mixins</p> <ol> <li>When you have common functionality that can be shared across multiple unrelated classes.</li> <li>When you want to add multiple behaviors to a class without using deep inheritance hierarchies.</li> <li>When you need to maintain a single responsibility for classes, keeping each focused on one aspect of functionality.</li> </ol> <p>Let's consider a simple example to illustrate how mixins work. Suppose we have a set of classes representing different kinds of animals, and we want to add behaviors like flying and swimming.</p> <pre><code>class FlyingMixin:\n    def fly(self):\n        print(\"I can fly!\")\n\nclass SwimmingMixin:\n    def swim(self):\n        print(\"I can swim!\")\n\nclass Animal:\n    def __init__(self, name):\n        self.name = name\n\nclass Bird(Animal, FlyingMixin):\n    pass\n\nclass Fish(Animal, SwimmingMixin):\n    pass\n\nclass Duck(Animal, FlyingMixin, SwimmingMixin):\n    pass\n\n# Using the mixins\nbird = Bird(\"Sparrow\")\nbird.fly()  # Output: I can fly!\n\nfish = Fish(\"Goldfish\")\nfish.swim()  # Output: I can swim!\n\nduck = Duck(\"Mallard\")\nduck.fly()  # Output: I can fly!\nduck.swim()  # Output: I can swim!\n</code></pre> <p>In this example:</p> <ul> <li><code>FlyingMixin</code> and <code>SwimmingMixin</code> are mixins that provide the fly and swim methods, respectively.</li> <li><code>Bird</code> and <code>Fish</code> classes inherit from Animal and the respective mixin to gain the desired behavior.</li> <li><code>Duck</code> inherits from both <code>FlyingMixin</code> and <code>SwimmingMixin</code>, thus acquiring both flying and swimming capabilities</li> </ul> <p>Conclusion</p> <p>Mixins are a powerful tool in Python for promoting code reuse and maintaining clean, modular code. By using mixins, you can compose complex behaviors in a flexible and maintainable way, enhancing the capabilities of your classes without resorting to deep or complicated inheritance structures.</p>","tags":["django"]},{"location":"blog/2024/06/24/mixins-in-python/#reference","title":"Reference","text":"<ul> <li>Django design patterns and best practices - second edition</li> <li>django braces - Reusable, generic mixins for Django</li> </ul>","tags":["django"]},{"location":"blog/2024/04/24/how-to-handle-nullable--non-nullable-fields-in-django/","title":"How to handle nullable &amp; non-nullable fields in django","text":"","tags":["Django"]},{"location":"blog/2024/04/24/how-to-handle-nullable--non-nullable-fields-in-django/#how-to-handle-nullable-non-nullable-fields-in-django","title":"How to handle nullable &amp; non-nullable fields in django","text":"<p>When designing databases in Django models, one common scenario is dealing with nullable fields. These fields allow for flexibility in data entry, as they can be left empty when necessary. However, managing nullable fields effectively is crucial to ensure consistency and usability within your application.</p>","tags":["Django"]},{"location":"blog/2024/04/24/how-to-handle-nullable--non-nullable-fields-in-django/#1-handling-nullable-fields-in-django-models","title":"1. Handling Nullable Fields in Django Models","text":"<p>Consider the scenario where we have a Django model called <code>YourModel</code>, which includes a <code>title</code> field that is allowed to be nullable. Here's how we can handle this situation:</p> Python<pre><code>from django.db import models\n\nclass YourModel(models.Model):\n    title = models.CharField(max_length=100, null=True)\n\n    def __str__(self):\n        return self.title if self.title is not None else \"Untitled\"\n</code></pre> <p>In this model, <code>title</code> is defined as a <code>CharField</code> with <code>max_length=100</code> and <code>null=True</code>, indicating that it can be left empty (<code>None</code>). Within the <code>__str__</code> method, we check if the title is <code>None</code>. If it is, we return a default string \"Untitled\" to represent the absence of a title.</p> <p>Handling nullable fields in this way ensures that our Django models maintain consistency in their string representations, even when certain fields are left blank. This approach enhances the user experience by providing meaningful defaults and maintaining clarity in the absence of data.</p> <p>In conclusion, when working with nullable fields in Django models, it's essential to consider how they are represented in string form, especially when displaying data to users. By implementing a concise and effective approach, such as the one demonstrated above, you can ensure your application remains robust and user-friendly.</p>","tags":["Django"]},{"location":"blog/2024/04/24/how-to-handle-nullable--non-nullable-fields-in-django/#2-handling-non-nullable-fields-in-django-models","title":"2. Handling Non-Nullable Fields in Django Models","text":"<ol> <li> <p>Provide a Default Value:</p> <p>One option is to specify a default value for the new field. This ensures that existing rows get populated with some initial value. For instance, setting the default value of 'image' to a default image path could be a viable solution.</p> Python<pre><code>class BusinessInner(models.Model):\nimage = models.ImageField(upload_to='images/', default='default_image.jpg')\n# Other fields...\n</code></pre> </li> <li> <p>Allow Null Values:</p> <p>If making the field nullable is acceptable for your application, you can add the field with <code>null=True</code>. This allows existing rows to have a null value for the field.</p> Python<pre><code>class BusinessInner(models.Model):\n    image = models.ImageField(upload_to='images/', null=True)\n    # Other fields...\n</code></pre> </li> <li> <p>Data Migration:</p> <p>In cases where neither providing a default value nor allowing null values is suitable, a data migration comes to the rescue. This involves writing a Python script that updates the database, ensuring each existing row gets a value for the new field.</p> Python<pre><code>from django.db import migrations\n\ndef populate_image_field(apps, schema_editor):\n    BusinessInner = apps.get_model('your_app_name', 'BusinessInner')\n    for obj in BusinessInner.objects.all():\n        obj.image = 'default_image.jpg'  # Or whatever default value you choose\n        obj.save()\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        ('your_app_name', 'previous_migration'),\n    ]\n\n    operations = [\n        migrations.AddField(\n            model_name='businessinner',\n            name='image',\n            field=models.ImageField(upload_to='images/'),\n        ),\n        migrations.RunPython(populate_image_field),\n    ]\n</code></pre> </li> </ol>","tags":["Django"]},{"location":"blog/2024/07/21/optimizing-static-files-in-django/","title":"Optimizing Static Files in Django","text":"","tags":["Django","production"]},{"location":"blog/2024/07/21/optimizing-static-files-in-django/#optimizing-static-files-in-django","title":"Optimizing Static Files in Django","text":"<p>When building a Django project, optimizing static files like CSS and JavaScript is crucial for improving performance and delivering a better user experience</p> <p>This blog post will guide you through two effective techniques: compressing static files and implementing cache busting. We\u2019ll cover both simple and advanced methods to help you get the most out of your static assets.</p> <p>Optimizing Static Files in Django: Simple and Advanced Techniques</p>","tags":["Django","production"]},{"location":"blog/2024/07/21/optimizing-static-files-in-django/#simple-method-using-django-compressor","title":"Simple Method: Using <code>django-compressor</code>","text":"<ol> <li> <p>Install <code>django-compressor</code></p> <p>First, you need to install <code>django-compressor</code>, which simplifies the minification and compression of CSS and JavaScript files.</p> <pre><code>pip install django-compressor\n</code></pre> </li> <li> <p>Configure <code>django-compressor</code> in Your Django Project</p> <p>Add <code>compressor</code> to your <code>INSTALLED_APPS</code> in <code>settings.py</code>:</p> <pre><code>INSTALLED_APPS = [\n    # other apps\n    'compressor',\n]\n</code></pre> <p>Add the following settings to your <code>settings.py</code> to configure <code>django-compressor</code>:</p> <pre><code>COMPRESS_ENABLED = True\nCOMPRESS_OFFLINE = True\nCOMPRESS_ROOT = os.path.join(BASE_DIR, 'static')\nCOMPRESS_URL = '/static/'\nCOMPRESS_PRECOMPILERS = (\n    ('text/x-scss', 'sass --stdin --no-cache --style compressed'),\n)\n</code></pre> </li> <li> <p>Update Your Templates</p> <p>Use the <code>{% compress %}</code> tag in your templates to specify which files should be compressed:</p> <pre><code>{% load compress %} {% compress css %}\n&lt;link rel=\"stylesheet\" href=\"{% static 'css/style.css' %}\" /&gt;\n{% endcompress %} {% compress js %}\n&lt;script src=\"{% static 'js/main.js' %}\"&gt;&lt;/script&gt;\n{% endcompress %}\n</code></pre> </li> <li> <p>Collect Static Files</p> <p>Run the following command to collect static files and generate compressed files:</p> <pre><code>python manage.py collectstatic\n</code></pre> </li> </ol>","tags":["Django","production"]},{"location":"blog/2024/07/21/optimizing-static-files-in-django/#advanced-method-using-whitenoise-and-cache-busting","title":"Advanced Method: Using <code>whitenoise</code> and Cache Busting","text":"<ol> <li> <p>Install <code>whitenoise</code></p> <p><code>whitenoise</code> helps to serve compressed static files and manage cache-busting easily. Install it with:</p> <pre><code>pip install whitenoise\n</code></pre> </li> <li> <p>Configure <code>whitenoise</code> in Your Django Project</p> <p>In <code>settings.py</code>, add <code>whitenoise.middleware.WhiteNoiseMiddleware</code> to your <code>MIDDLEWARE</code> list:</p> <pre><code>MIDDLEWARE = [\n    # other middleware\n    'whitenoise.middleware.WhiteNoiseMiddleware',\n]\n</code></pre> <p>Add the following settings to enable compression and cache-busting:</p> <pre><code>STATICFILES_STORAGE = 'whitenoise.storage.CompressedManifestStaticFilesStorage'\n</code></pre> </li> <li> <p>Configure Cache Busting</p> <p><code>whitenoise</code> uses the <code>CompressedManifestStaticFilesStorage</code> to automatically handle cache busting by appending hashed filenames to static files. You don\u2019t need to do anything extra; it works out of the box.</p> <ol> <li>Update Your Templates</li> </ol> <p>Continue using the <code>{% static %}</code> template tag as usual. <code>whitenoise</code> will handle the cache-busting automatically:</p> <pre><code>&lt;link rel=\"stylesheet\" href=\"{% static 'css/style.css' %}\" /&gt;\n&lt;script src=\"{% static 'js/main.js' %}\"&gt;&lt;/script&gt;\n</code></pre> </li> <li> <p>Collect Static Files</p> <p>Run the command to collect static files and apply optimizations:</p> <pre><code>python manage.py collectstatic\n</code></pre> </li> </ol>","tags":["Django","production"]},{"location":"blog/2024/07/21/optimizing-static-files-in-django/#conclusion","title":"Conclusion","text":"<p>Optimizing static files is a key part of improving your Django application\u2019s performance. By using django-compressor, you can easily minify and compress your CSS and JavaScript files. For advanced optimization, <code>whitenoise</code> provides built-in support for serving compressed files and managing cache busting with minimal configuration. Implement these techniques to ensure your application is fast, efficient, and delivers the latest content to your users.</p>","tags":["Django","production"]},{"location":"blog/2024/07/21/optimizing-static-files-in-django/#question","title":"Question","text":"<p>Understanding django-compressor and whitenoise</p> <p>Understanding django-compressor and whitenoise</p> <p><code>django-compressor</code> and <code>whitenoise</code> are two different tools used for optimizing static files in Django projects. Each serves a unique purpose and can be used in different scenarios based on your project needs. Here\u2019s a detailed comparison to help you understand when to use each one and their capabilities.</p>","tags":["Django","production"]},{"location":"blog/2024/07/21/optimizing-static-files-in-django/#django-compressor","title":"<code>django-compressor</code>","text":"<p>What is django-compressor?</p> <p>django-compressor is a Django library that helps to compress and minify CSS and JavaScript files. It works by combining multiple CSS or JS files into a single file and minifying them to reduce their size, which improves load times and reduces HTTP requests.</p> Key Features <ul> <li>Minification: Compresses CSS and JavaScript files by removing whitespace and comments.</li> <li>Concatenation: Combines multiple CSS or JS files into a single file to reduce the number of HTTP requests.</li> <li>Preprocessing: Supports preprocessing languages like SCSS, LESS, and CoffeeScript.</li> <li>Offline Compression: Can pre-compress files and serve them efficiently.</li> </ul> When to Use django-compressor <ul> <li>If You Need File Minification and Concatenation: Ideal for projects where CSS and JavaScript files need to be minified and combined to optimize loading times.</li> <li>When Using Preprocessors: If you use CSS preprocessors (like SCSS) or JavaScript preprocessors, <code>django-compressor</code> can handle these transformations.</li> </ul> When Not to Use django-compressor <ul> <li>If You Prefer Built-in Solutions for Static Files: For simple static file handling, <code>whitenoise</code> might be a better choice as it provides built-in compression and caching features without additional setup.</li> <li>If You Need Advanced Caching: <code>django-compressor</code> does not handle cache-busting out of the box, which can be a limitation in certain scenarios.</li> </ul> Limitations <ul> <li>Does Not Handle Image Files: <code>django-compressor</code> is specifically designed for CSS and JavaScript files. It does not handle image optimization.</li> </ul>","tags":["Django","production"]},{"location":"blog/2024/07/21/optimizing-static-files-in-django/#whitenoise","title":"whitenoise","text":"<p>What is whitenoise?</p> <p><code>whitenoise</code> is a Django middleware that provides a simple way to serve static files directly from your Django application. It supports compressed static files, cache-busting, and can be a more straightforward solution for handling static files in production.</p> Key Features <ul> <li>Static File Serving: Serves static files efficiently without needing a separate web server configuration.</li> <li>Compression: Automatically compresses CSS and JavaScript files using gzip and Brotli.</li> <li>Cache-Busting: Handles cache-busting by appending hashed file names.</li> <li>Easy Setup: Requires minimal configuration compared to <code>django-compressor</code>.</li> </ul> When to Use whitenoise <ul> <li>If You Need Simple Static File Serving: Great for projects that need an easy way to serve static files with built-in optimization features.</li> <li>For Cache-Busting Needs: Automatically handles cache-busting for static files, making it easier to ensure users receive the latest versions of files.</li> <li>If You Want Minimal Configuration: Easier to set up compared to <code>django-compressor</code>, with fewer configuration steps required.</li> </ul> When Not to Use whitenoise <ul> <li>If You Need Advanced Preprocessing: If you require preprocessing of CSS or JavaScript files (e.g., SCSS to CSS), <code>whitenoise</code> does not provide this functionality.</li> <li>For Projects with High Customization Needs: If you need a highly customized setup for static file management, <code>django-compressor</code> might offer more flexibility.</li> </ul> Limitations <ul> <li>Does Not Handle Image File Optimization: Like <code>django-compressor</code>, <code>whitenoise</code> does not handle image file compression or optimization.</li> </ul>","tags":["Django","production"]},{"location":"blog/2024/07/21/optimizing-static-files-in-django/#summary","title":"Summary","text":"<ul> <li>Use <code>django-compressor</code> if you need to minify, concatenate, and preprocess CSS and JavaScript files. It's particularly useful for more complex setups where file transformation is required.</li> <li>Use whitenoise if you want a simple and efficient way to serve static files with built-in support for compression and cache-busting. It\u2019s great for straightforward use cases and offers minimal configuration.</li> </ul> <p>Both tools are powerful but serve different needs. Choose based on your project's requirements for static file handling, preprocessing, and optimization. Neither <code>django-compressor</code> nor <code>whitenoise</code> directly handles image file optimization, so consider additional tools or libraries if image optimization is also a requirement.</p>","tags":["Django","production"]},{"location":"blog/2024/07/21/optimizing-static-files-in-django/#difference","title":"Difference","text":"<p>The key difference between <code>django-compressor</code> and <code>whitenoise</code> is their primary function:</p> <ul> <li> <p><code>django-compressor</code> focuses on minifying and concatenating CSS and JavaScript files, and it supports preprocessing languages like SCSS and LESS. It is primarily a tool for optimizing and managing the delivery of these static assets.</p> </li> <li> <p><code>whitenoise</code> is primarily a tool for serving static files directly from your <code>Django application</code> with built-in compression and cache-busting. It simplifies static file handling and improves performance with minimal configuration.</p> </li> </ul> <p>In summary, <code>django-compressor</code> is about optimizing and transforming static files, while whitenoise is about efficiently serving static files with built-in optimizations.</p> <p><code>django-compressor</code> focuses on optimizing and minifying CSS and JavaScript files, while <code>whitenoise</code> is designed for efficiently serving static files with built-in compression and cache-busting.</p>","tags":["Django","production"]},{"location":"blog/2024/06/16/pipenv/","title":"Pipenv","text":"","tags":["package","python"]},{"location":"blog/2024/06/16/pipenv/#pipenv","title":"Pipenv","text":"<p>pipenv is for Python what NPM is for Node.js. However, pipenv is used for much more than package management, and it also creates and manages a virtual environment for you. </p> <p>Environment Management with Pipenv</p> <p>The three primary commands you\u2019ll use in managing your pipenv environment are:</p> <pre><code>$ pipenv install,\n$ pipenv uninstall, &amp; \n$ pipenv lock.\n</code></pre> <p>In the previous chapters, we used <code>virtualenv</code> to create our virtual environment; however, Kenneth Reitz (the creator of the popular package requests) created <code>pipenv</code>. pipenv is for Python what NPM is for Node.js. However, pipenv is used for much more than package management, and it also creates and manages a virtual environment for you. In my opinion, there are a lot of advantages of the old development workflows, but for me, there are two things that stand out: the first is that you no longer need two different tools (pip, virtualenv), and the second is that it is much simpler to have all these great features in just one place.</p> <p>Another thing that I really like about pipenv is the use of Pipfile. Sometimes, it is really hard to work with requirement files. Our production environment and development environment have the same dependencies, and you end up having to maintain two different files; plus, every time you need to remove one dependency, you will need to edit the requirement file manually.</p> <p>With <code>pipenv</code>, you don't need to worry about having multiple requirement files. Development and production dependencies are placed in the same file, and pipenv also takes care of updating the <code>Pipfile</code>.</p> <pre><code># Installing pipenv is quite simple, just run:\npip install pipenv\n\n# After installing it you can run:\npipenv --help\n\n# use pipenv to create our virtual environment\npipenv --python python3.6\n\npipenv install requests\n</code></pre> <p>The author of <code>pipenv</code> is the same developer who created the popular <code>requests</code> library.</p> <pre><code>$ pipenv install &lt;package&gt;\n</code></pre> <p>This will create a <code>Pipfile</code> if one doesn\u2019t exist. If one does exist, it will automatically be edited with the new package your provided.</p> <p>Next, activate the <code>Pipenv</code> shell:</p> <pre><code>$ pipenv shell\n$ python --version\n</code></pre> Specifying Versions of Python <p>To create a new virtualenv, using a specific version of Python you have installed (and on your PATH), use the <code>--python VERSION</code> flag, like so:</p> <p>Use Python 3:</p> <pre><code>$ pipenv --python 3\n</code></pre> <p>Use Python3.6:</p> <pre><code>$ pipenv --python 3.6\n</code></pre> <p>Use Python 2.7.14:</p> <pre><code>$ pipenv --python 2.7.14\n</code></pre> <p>When given a Python version, like this, <code>Pipenv</code> will automatically scan your system for a Python that matches that given version.</p> <p>If a <code>Pipfile</code> hasn\u2019t been created yet, one will be created for you, that looks like this:</p> <pre><code>[[source]]\nurl = \"https://pypi.python.org/simple\"\nverify_ssl = true\n\n[dev-packages]\n\n[packages]\n\n[requires]\npython_version = \"3.6\"\n</code></pre>","tags":["package","python"]},{"location":"blog/2024/06/16/pipenv/#reference","title":"Reference","text":"<ul> <li>Python Programming Blueprints by Daniel Furtado : pg-158</li> <li>pipenv-es.readthedocs.io</li> </ul>","tags":["package","python"]},{"location":"blog/2024/07/14/how-to-connect-postgresql-database-in-django/","title":"How to Connect PostgreSQL Database in Django\"","text":"","tags":["databse","django","postgresql"]},{"location":"blog/2024/07/14/how-to-connect-postgresql-database-in-django/#how-to-connect-postgresql-database-in-django","title":"How to Connect PostgreSQL Database in Django\"","text":"<p>PostgreSQL is an open-source, powerful, and widely used relational database management system (RDBMS), similar to MySQL. It allows you to store and manage data and supports advanced features like JSON support, full-text search, and more complex querying options.</p> How to Connect PostgreSQL Database in Django: A Step-by-Step Guide","tags":["databse","django","postgresql"]},{"location":"blog/2024/07/14/how-to-connect-postgresql-database-in-django/#to-connect-a-postgresql-database-to-your-django-project-follow-these-steps","title":"To connect a PostgreSQL database to your Django project, follow these steps:","text":"","tags":["databse","django","postgresql"]},{"location":"blog/2024/07/14/how-to-connect-postgresql-database-in-django/#1-install-postgresql-and-psycopg2","title":"1.  Install PostgreSQL and psycopg2","text":"<p>First, make sure PostgreSQL is installed on your system. If it isn't, you can install it using the appropriate method for your system:</p> <ul> <li> <p>On Ubuntu:</p> <pre><code>sudo apt update\nsudo apt install postgresql postgresql-contrib\n</code></pre> </li> <li> <p>On Mac: You can use Homebrew:</p> <pre><code>brew install postgresql\n</code></pre> </li> </ul> <p>Next, install <code>psycopg2</code>, the PostgreSQL adapter for Python, which is required for Django to interact with PostgreSQL.</p> <pre><code>pip install psycopg2\n</code></pre> <p>Alternatively, you can install <code>psycopg2-binary</code> for simplicity:</p> <pre><code>pip install psycopg2-binary\n</code></pre>","tags":["databse","django","postgresql"]},{"location":"blog/2024/07/14/how-to-connect-postgresql-database-in-django/#2-configure-postgresql","title":"2.  Configure PostgreSQL","text":"<p>Once PostgreSQL is installed, create a database and a user for your Django application.</p> <ol> <li> <p>Access the PostgreSQL prompt:</p> <pre><code>sudo -u postgres psql\n</code></pre> </li> <li> <p>Create a database:</p> <pre><code>CREATE DATABASE mydatabase;\n</code></pre> </li> <li> <p>Create a user with a password:</p> <pre><code>CREATE USER myuser WITH PASSWORD 'mypassword';\n</code></pre> </li> <li> <p>Grant all privileges on the database to the user:</p> <pre><code>GRANT ALL PRIVILEGES ON DATABASE mydatabase TO myuser;\n</code></pre> </li> <li> <p>Exit the PostgreSQL prompt:</p> <pre><code>\\q\n</code></pre> </li> </ol>","tags":["databse","django","postgresql"]},{"location":"blog/2024/07/14/how-to-connect-postgresql-database-in-django/#3-update-settingspy-in-django","title":"3.  Update <code>settings.py</code> in Django","text":"<p>Now, update your Django project's <code>settings.py</code> to configure PostgreSQL as the database:</p> <ol> <li>Open your <code>settings.py</code> file.</li> <li>Modify the <code>DATABASES</code> setting to look like this:</li> </ol> <pre><code>DATABASES = {\n    'default': {\n        'ENGINE': 'django.db.backends.postgresql',\n        'NAME': 'mydatabase',  # Replace with your database name\n        'USER': 'myuser',      # Replace with your database user\n        'PASSWORD': 'mypassword',  # Replace with your user password\n        'HOST': 'localhost',   # Or the IP address if using a remote database\n        'PORT': '5432',        # Default PostgreSQL port\n    }\n}\n</code></pre>","tags":["databse","django","postgresql"]},{"location":"blog/2024/07/14/how-to-connect-postgresql-database-in-django/#4-apply-migrations","title":"4.  Apply Migrations","text":"<p>Once PostgreSQL is configured, run the following commands to apply migrations and create the necessary database tables:</p> <pre><code>python manage.py migrate\n</code></pre>","tags":["databse","django","postgresql"]},{"location":"blog/2024/07/14/how-to-connect-postgresql-database-in-django/#5-run-the-django-application","title":"5.  Run the Django Application","text":"<p>Now, you can run your Django application with PostgreSQL as the database:</p> <pre><code>python manage.py runserver\n</code></pre> <p>Your Django project is now connected to PostgreSQL!</p>","tags":["databse","django","postgresql"]},{"location":"blog/2024/07/14/how-to-connect-postgresql-database-in-django/#differences-between-postgresql-and-mysql","title":"Differences Between PostgreSQL and MySQL:","text":"<ul> <li>SQL Standard Compliance: PostgreSQL is considered more SQL-compliant and provides advanced features like foreign key constraints, window functions, and Common Table Expressions (CTEs).</li> <li>Extensibility: PostgreSQL is known for its extensibility, allowing users to add custom functions, data types, and operators.</li> <li>Data Integrity: PostgreSQL emphasizes data integrity and transactional reliability.</li> <li>License: PostgreSQL uses a more permissive license, while MySQL is under Oracle's ownership with a different licensing model.</li> </ul>","tags":["databse","django","postgresql"]},{"location":"blog/2024/07/14/how-to-connect-postgresql-database-in-django/#installation-and-running-postgresql","title":"Installation and Running PostgreSQL","text":"<p>Unlike XAMPP (which bundles MySQL, Apache, etc.), PostgreSQL is usually installed separately. After installation, PostgreSQL runs as a service, similar to how MySQL runs in the background on XAMPP.</p> Steps to Install PostgreSQL: <ol> <li> <p>Install PostgreSQL:</p> <ul> <li> <p>On Linux (Ubuntu):</p> <pre><code>sudo service postgresql start\n</code></pre> </li> <li> <p>On macOS (using Homebrew):</p> <pre><code>brew services start postgresql\n</code></pre> </li> </ul> </li> <li> <p>Start the PostgreSQL Service:</p> <ul> <li> <p>On Linux:</p> <pre><code>sudo service postgresql start\n</code></pre> </li> <li> <p>On macOS:</p> <pre><code>brew services start postgresql\n</code></pre> </li> </ul> </li> <li> <p>Verify if PostgreSQL is running:</p> <ul> <li> <p>You can check if PostgreSQL is running using the command:</p> <pre><code>sudo service postgresql status\n</code></pre> </li> <li> <p>Or use <code>psql</code>, the PostgreSQL command-line tool:</p> <pre><code>psql -U postgres\n</code></pre> </li> </ul> </li> </ol>","tags":["databse","django","postgresql"]},{"location":"blog/2024/07/14/how-to-connect-postgresql-database-in-django/#do-you-need-to-start-a-server-manually","title":"Do You Need to Start a Server Manually?","text":"<p>Yes, just like MySQL in XAMPP, PostgreSQL runs as a server (or service) in the background. Once installed, it will automatically start when your machine boots up. You can start, stop, or restart PostgreSQL as needed.</p> In summary: <ul> <li>PostgreSQL is a standalone database server, like MySQL.</li> <li>After installation, PostgreSQL runs as a service (you don't need a XAMPP-like tool).</li> <li>You interact with PostgreSQL using its own command-line tool (<code>psql</code>) or through applications like Django, which connects to it once the service is running.</li> </ul>","tags":["databse","django","postgresql"]},{"location":"blog/2024/07/10/pre-commit/","title":"Pre-commit","text":"","tags":["Programming","Django"]},{"location":"blog/2024/07/10/pre-commit/#pre-commit","title":"Pre-commit","text":"<p>Pre-commit is a framework for managing and maintaining multi-language pre-commit hooks. These hooks are scripts that run automatically before a commit is finalized, helping to ensure code quality and adherence to coding standards.</p> When to Use Pre-commit <p>Pre-commit is useful in a variety of scenarios, particularly when you want to automate code quality checks and ensure consistency across a project. Here are some common use cases:</p> <ol> <li>Code Quality Assurance: Automatically run linters and formatters to ensure that code adheres to style guidelines before it\u2019s committed.</li> <li>Security Checks: Use hooks to scan for common security issues, such as sensitive data leaks or known vulnerabilities.</li> <li>Error Prevention: Catch issues early, such as syntax errors or missing files, that might otherwise slip through manual checks.</li> <li>Consistency Across Teams: Ensure that all team members adhere to the same coding standards and practices, reducing discrepancies and integration issues.</li> <li>Automating Tasks: Automate repetitive tasks, like fixing minor formatting issues or updating documentation, before commits are finalized.</li> </ol>","tags":["Programming","Django"]},{"location":"blog/2024/07/10/pre-commit/#how-to-use-pre-commit","title":"How to Use Pre-commit","text":"<ol> <li> <p>Install Pre-commit:</p> <ul> <li> <p>First, you need to install the pre-commit package. You can do this using pip</p> <pre><code>pip install pre-commit\n</code></pre> </li> </ul> </li> <li> <p>Create a Configuration File:</p> <ul> <li> <p>In the root of your repository, create a <code>.pre-commit-config.yaml</code> file. This file will list the hooks you want to use. For example:</p> <pre><code>repos:\n    -   repo: https://github.com/pre-commit/pre-commit-hooks\n        rev: v3.4.0  # Use the appropriate version tag\n        hooks:\n            - id: trailing-whitespace\n            - id: end-of-file-fixer\n</code></pre> </li> </ul> </li> <li> <p>Install the Git Hooks:</p> <ul> <li> <p>Run the following command to set up the Git hooks based on the configuration file.</p> <pre><code>pre-commit install\n</code></pre> </li> <li> <p>This command installs the hooks in your <code>.git/hooks</code> directory, which will run automatically before each commit.</p> </li> </ul> </li> <li> <p>Run Hooks Manually (Optional):</p> <ul> <li> <p>You can manually run hooks against all files or specific files if you want to test them without making a commit:</p> <pre><code>pre-commit run --all-files\n</code></pre> </li> <li> <p>Or run a specific hook:</p> <pre><code>pre-commit run &lt;hook-id&gt;\n</code></pre> </li> </ul> </li> <li> <p>Update Hooks (Optional):</p> <ul> <li> <p>To update the hooks to their latest versions as specified in the configuration file, use:</p> <pre><code>pre-commit autoupdate\n</code></pre> </li> </ul> </li> <li> <p>Customize Hooks:</p> <p>Some hooks can be configured with additional options. For example, you can set specific arguments or configurations directly in the <code>.pre-commit-config.yaml</code> file.</p> </li> </ol> <p>By following these steps, you can integrate pre-commit hooks into your development workflow, automating checks and improving code quality.</p> difference between","tags":["Programming","Django"]},{"location":"blog/2024/07/10/pre-commit/#pre-commit-hooks-vs-github-actions","title":"Pre-commit Hooks <code>vs</code> GitHub Actions","text":"<p>Whether to use pre-commit hooks or GitHub Actions for code formatting and testing largely depends on your workflow and needs. Both have their advantages and can even complement each other. Here's a breakdown to help you decide which to use or how to use both effectively:</p> Pre-commit HooksGitHub Actions <p>Advantages:</p> <ol> <li>Immediate Feedback: Pre-commit hooks run locally on the developer's machine before the commit is made, providing immediate feedback and ensuring that code formatting and linting issues are caught before they reach the repository.</li> <li>Consistency: By catching issues locally, pre-commit hooks help maintain code consistency across all contributors, reducing the likelihood of formatting issues slipping through.</li> <li>Lower CI Costs: Running checks locally can reduce the load on CI systems and potentially lower associated costs.</li> </ol> <p>Use Cases:</p> <ul> <li>Ensuring that all code adheres to formatting and linting rules before committing.</li> <li>Automating repetitive tasks, like fixing code style issues or applying certain modifications automatically.</li> </ul> <pre><code>repos:\n  - repo: https://github.com/pre-commit/pre-commit-hooks\n    rev: v3.4.0\n    hooks:\n      - id: black\n      - id: flake8\n</code></pre> <p>Advantages:</p> <ol> <li>Centralized Checks: GitHub Actions run in a centralized CI/CD environment, ensuring that all code changes are validated in the same environment, regardless of where they were committed from.</li> <li>Integration with Workflow: Actions can be integrated into a broader CI/CD pipeline, including building, testing, and deploying code, not just formatting and linting.</li> <li>Flexibility: Actions offer a wide range of capabilities, from running complex workflows to deploying applications, and can be customized with various workflows and environment variables.</li> </ol> <p>Use Cases:</p> <ul> <li>Running code formatting and linting checks as part of a continuous integration pipeline.</li> <li>Performing additional tasks like building, testing, and deploying code.</li> <li>Enforcing checks that should be validated on every pull request or push to the repository.</li> </ul> <pre><code>name: Code Quality\n\non: [push, pull_request]\n\njobs:\n    lint:\n        runs-on: ubuntu-latest\n        steps:\n            - name: Checkout code\n                uses: actions/checkout@v3\n            - name: Set up Python\n                uses: actions/setup-python@v4\n                with:\n                python-version: '3.x'\n            - name: Install dependencies\n                run: |\n                python -m pip install --upgrade pip\n                pip install black flake8\n            - name: Run Black\n                run: black --check .\n            - name: Run Flake8\n                run: flake8 .\n</code></pre>","tags":["Programming","Django"]},{"location":"blog/2024/07/10/pre-commit/#using-both-together","title":"Using Both Together","text":"<p>You can use both pre-commit hooks and GitHub Actions in your workflow for optimal results:</p> <ol> <li>Pre-commit Hooks: Set up pre-commit hooks to catch issues locally before commits are made, ensuring immediate feedback and consistent formatting.</li> <li>GitHub Actions: Set up GitHub Actions to run code quality checks on every push and pull request, ensuring that all code is validated in a consistent CI environment before being merged.</li> </ol> <p>This combination helps to catch issues early, maintain code quality, and integrate smoothly with your development workflow and CI/CD pipeline.</p>","tags":["Programming","Django"]},{"location":"blog/2024/05/01/preventing-unintended-form-resubmission-in-web-applications/","title":"Preventing Unintended Form Resubmission in Web Applications","text":"","tags":["Django"]},{"location":"blog/2024/05/01/preventing-unintended-form-resubmission-in-web-applications/#preventing-unintended-form-resubmission-in-web-applications","title":"Preventing Unintended Form Resubmission in Web Applications","text":"<p>Have you ever encountered the frustrating message \"Contact Form Resubmission\" while using web forms? This message typically appears when you attempt to resubmit form data after a page refresh or navigation action. Not only is it annoying, but it can also lead to unintended consequences such as duplicate transactions or data corruption. In this blog post, we'll explore why this happens and how to prevent it in your web applications.</p>","tags":["Django"]},{"location":"blog/2024/05/01/preventing-unintended-form-resubmission-in-web-applications/#understanding-the-issue","title":"Understanding the Issue","text":"<p>Modern web browsers implement a security feature to prevent unintended duplicate form submissions. This feature detects when users attempt to resubmit form data after actions like refreshing the page or navigating back to it. The \"Contact Form Resubmission\" message is a warning to users that their browser has detected a duplicate form submission.</p>","tags":["Django"]},{"location":"blog/2024/05/01/preventing-unintended-form-resubmission-in-web-applications/#common-causes","title":"Common Causes","text":"<p>Several factors can trigger the \"Contact Form Resubmission\" message:</p> <ul> <li> <p>Manual Refresh:</p> <p>Users manually refreshing the page after submitting the form.</p> </li> <li> <p>Back/Forward Navigation:</p> <p>Users navigating away from the form page and returning to it, then attempting to resubmit the form.</p> </li> <li> <p>Browser Confirmation Dialog:</p> <p>Some browsers prompt users to confirm form resubmission, adding an extra step to the process.</p> </li> </ul>","tags":["Django"]},{"location":"blog/2024/05/01/preventing-unintended-form-resubmission-in-web-applications/#solutions","title":"Solutions","text":"<p>To address this issue and provide a smoother user experience, consider implementing the following solutions in your web applications:</p> <ol> <li> <p>Post/Redirect/Get (PRG) Pattern:</p> <p>After processing the form submission on the server side, redirect users to a different page using an HTTP redirect response. This prevents the browser from resubmitting the form data when users refresh the page or navigate back to it.</p> </li> <li> <p>JavaScript Form Submission:</p> <p>Use JavaScript to submit the form asynchronously, such as via AJAX. By doing so, you can prevent the browser from considering the form submission as a page reload, thus avoiding the resubmission prompt.</p> </li> <li> <p>Browser Confirmation Dialog Handling:</p> <p>Inform users about the consequences of resubmitting the form and allow them to proceed or cancel the action. While this doesn't prevent resubmission, it helps users understand why they're seeing the message and gives them control over the process.</p> </li> </ol> Post/Redirect/Get (PRG) pattern <p>In the Post/Redirect/Get (PRG) pattern, <code>success_url</code> refers to the URL where you want to redirect users after the form submission is successful. This URL can be any valid URL within your Django project.</p> <p>There are two common approaches to defining the success_url:</p> <ol> <li>Hardcoded URL: Specify the URL directly in your view code.</li> <li>URL Name: Define a URL pattern with a name in your urls.py file and use that name as success_url. This approach is more flexible and allows you to change the URL later without modifying your view code.</li> </ol> <p>Here's how you can define success_url using both approaches:</p> <ol> <li> <p>Hardcoded URL:</p> Python<pre><code>class FormSubmissionView(View):\nsuccess_url = '/success/'  # Replace with the actual URL\n\ndef post(self, request):\n  # Process form submission\n  return redirect(self.success_url)\n</code></pre> </li> <li> <p>URL Name:</p> urls.py<pre><code>from django.urls import path\nfrom .views import FormSubmissionView, SuccessView\n\nurlpatterns = [\n  path('success/', SuccessView.as_view(), name='success_url'),\n  # Other URL patterns\n]\n</code></pre> views.py<pre><code>from django.views.generic import TemplateView\nfrom django.urls import reverse_lazy\n\nclass FormSubmissionView(View):\n  success_url = reverse_lazy('success_url')\n\n  def post(self, request):\n    # Process form submission\n    return redirect(self.success_url)\n\n#\nclass SuccessView(TemplateView):\n  template_name = 'success.html'\n</code></pre> <p>In the URL name approach, <code>reverse_lazy</code> is used to retrieve the URL dynamically based on the name defined in urls.py. This allows you to change the URL later without modifying the view code. Ensure that the name 'success_url' matches the name you've defined in your <code>urls.py</code> file.</p> </li> </ol>","tags":["Django"]},{"location":"blog/2024/05/01/preventing-unintended-form-resubmission-in-web-applications/#conclusion","title":"Conclusion","text":"<p>Unintended form resubmission can disrupt the user experience and lead to data integrity issues in web applications. By implementing strategies like the PRG pattern, JavaScript form submission, and effective user communication, you can mitigate this issue and provide a smoother form submission experience for your users. Remember to consider your application's requirements and user experience when choosing the appropriate solution.</p> <p>With these solutions in place, you can ensure that users can submit forms seamlessly without encountering the dreaded \"Contact Form Resubmission\" message.</p>","tags":["Django"]},{"location":"blog/2024/07/11/project-specific-configuration-vscode/","title":"Project-Specific Configuration vscode","text":"","tags":["Django"]},{"location":"blog/2024/07/11/project-specific-configuration-vscode/#project-specific-configuration-vscode","title":"Project-Specific Configuration <code>vscode</code>","text":"<p>Yes, you can and often should save the <code>settings.json</code> file in your repository for project-specific configuration. This approach ensures that everyone working on the project has the same settings, which helps maintain consistency across different development environments. Here\u2019s how you can do it and why it\u2019s a good practice:</p>","tags":["Django"]},{"location":"blog/2024/07/11/project-specific-configuration-vscode/#how-to-save-settingsjson-in-your-repo","title":"How to Save settings.json in Your Repo","text":"<ol> <li> <p>Create a .vscode Directory:</p> <ul> <li>In the root of your project repository, create a directory named .vscode if it doesn\u2019t already exist.</li> </ul> </li> <li> <p>Add settings.json:</p> <ul> <li>Inside the .vscode directory, create a file named settings.json.</li> </ul> </li> <li> <p>Configure Your Settings:</p> <ul> <li> <p>Add the necessary configuration to settings.json. For example:</p> <pre><code>{\n    \"python.formatting.provider\": \"black\",\n    \"editor.formatOnSave\": true\n}\n</code></pre> </li> <li> <p>You can add any other settings specific to your project here.</p> </li> </ul> </li> <li> <p>Commit and Push:</p> <ul> <li> <p>Add the <code>.vscode/settings.json</code> file to your version control system (e.g., Git):</p> <pre><code>git add .vscode/settings.json\ngit commit -m \"Add VS Code settings for Python formatting\"\ngit push\n</code></pre> </li> </ul> </li> </ol> Benefits of Including settings.json in Your Repo <ol> <li> <p>Consistency:</p> <ul> <li>Ensures that all contributors use the same formatting and development settings, reducing the likelihood of style discrepancies and configuration issues.</li> </ul> </li> <li> <p>Project-Specific Configuration:</p> <ul> <li>Allows you to define settings that are specific to your project without affecting the global configuration of developers' VS Code installations.</li> </ul> </li> <li> <p>Ease of Setup:</p> <ul> <li>New developers who clone the repository will automatically get the same editor settings when they open the project in VS Code, improving onboarding and reducing setup time.</li> </ul> </li> </ol> Best Practices <ol> <li> <p>Review and Document:</p> <ul> <li>Ensure that the settings you include in <code>settings.json</code> are relevant and agreed upon by the team. Document any special configuration requirements in your project\u2019s README or contributing guidelines.</li> </ul> </li> <li> <p>Avoid Overwriting Personal Preferences:</p> <ul> <li>Be mindful of settings that might override personal preferences. Include only project-specific settings that all team members should adhere to.</li> </ul> </li> <li> <p>Use Workspace Settings:</p> <ul> <li>The <code>.vscode/settings.json</code> file is for workspace settings, which are specific to the project and do not affect global VS Code settings. This is ideal for settings like formatting options, linting rules, and debugger configurations.</li> </ul> </li> <li> <p>Consider Other Config Files:</p> <ul> <li>For Python projects, you might also include other configuration files, like <code>.flake8</code> or <code>pyproject.toml</code>, to ensure consistent code style and behavior across different tools.</li> </ul> </li> </ol> <p>By including <code>settings.json</code> in your repository, you enhance collaboration and maintain consistency across development environments, making it a recommended practice for team projects.</p>","tags":["Django"]},{"location":"blog/2024/07/11/project-specific-configuration-vscode/#other-config-files","title":"Other Config Files","text":"<p>For Python projects, configuration files such as .flake8 and pyproject.toml are typically placed in the root directory of your project. Here\u2019s how to include and use these files:</p> <ol> <li> <p><code>pyproject.toml</code></p> <p>Purpose: This file is used by various Python tools to configure project-specific settings. Black, flake8, and other tools often look for configuration options here.</p> <p>Location: Place <code>pyproject.toml</code> in the root directory of your project.</p> <pre><code>[tool.black]\nline-length = 88\ntarget-version = ['py38']\n\n[tool.flake8]\nmax-line-length = 88\nignore = E203, E266, E501, W503\n</code></pre> <p>Creating and Using:</p> <ul> <li>Create a file named <code>pyproject.toml</code> in the root of your project.</li> <li>Add configuration settings for tools that support it. Black and Flake8 are common tools that use this file for configuration.</li> </ul> Black Example Configuration<pre><code>[tool.black]\nline-length = 88\n</code></pre> Flake8 Example Configuration<pre><code>[tool.flake8]\nmax-line-length = 88\nignore = E203, E266, E501, W503\n</code></pre> </li> <li> <p><code>.flake8</code></p> <p>Purpose: This file is used to configure flake8, a tool for linting Python code.</p> <p>Location: Place <code>.flake8</code> in the root directory of your project.</p> <pre><code>[flake8]\nmax-line-length = 88\nignore = E203, E266, E501, W503\n</code></pre> <p>Creating and Using:</p> <ul> <li>Create a file named <code>.flake8</code> in the root of your project.</li> <li>Add configuration settings to customize linting rules and behavior.</li> </ul> </li> </ol> Best Practices for Including Config Files <ol> <li> <p>Place in Root Directory:</p> <ul> <li>Both <code>pyproject.toml</code> and <code>.flake8</code> should be in the root directory of your project to be easily discovered by tools and IDEs.</li> </ul> </li> <li> <p>Version Control:</p> <ul> <li>Commit these configuration files to your version control system (e.g., Git) to ensure that all team members use the same settings.</li> </ul> <pre><code>git add pyproject.toml .flake8\ngit commit -m \"Add configuration files for Black and Flake8\"\ngit push\n</code></pre> </li> <li> <p>Documentation:</p> <ul> <li>Document any specific configurations or guidelines in your project\u2019s README or contributing guidelines. This helps new developers understand the purpose of these files and the configurations used.</li> </ul> </li> <li> <p>Consistency:</p> <ul> <li>Ensure that the configurations in these files are aligned with the overall code style and quality goals of your project. Consistent settings help maintain a uniform codebase and improve collaboration.</li> </ul> </li> </ol> <p>By including these configuration files in the root directory of your project, you make it easier to manage code quality and formatting across different tools and development environments, promoting a consistent and well-maintained codebase.</p>","tags":["Django"]},{"location":"blog/2024/07/11/project-specific-configuration-vscode/#folder-structure","title":"Folder Structure","text":"<p>In Visual Studio Code (VS Code), you can place the <code>settings.json file</code> in a specific folder within your project to configure settings that apply to that particular workspace. Here's how you should organize your folder structure to include <code>settings.json</code> and other configuration files:</p> <p>Here\u2019s a typical folder structure for a Python project that includes VS Code settings and other configuration files:</p> <pre><code>my_project/\n\u251c\u2500\u2500 .vscode/\n\u2502   \u2514\u2500\u2500 settings.json\n\u251c\u2500\u2500 src/\n\u2502   \u2514\u2500\u2500 main.py\n\u251c\u2500\u2500 tests/\n\u2502   \u2514\u2500\u2500 test_main.py\n\u251c\u2500\u2500 pyproject.toml\n\u251c\u2500\u2500 .flake8\n\u2514\u2500\u2500 README.md\n</code></pre> <ul> <li><code>.vscode/settings.json</code>: Contains VS Code settings for this specific project.</li> <li><code>pyproject.toml</code>: Contains configuration for Black and other tools.</li> <li><code>.flake8</code>: Contains flake8 configuration.</li> </ul>","tags":["Django"]},{"location":"blog/2024/07/11/project-specific-configuration-vscode/#example-settingsjson-configuration","title":"Example <code>settings.json</code> Configuration","text":"<p>Here\u2019s what a basic <code>settings.json</code> might look like for a Python project using Black and Flake8:</p> <pre><code>{\n  \"python.formatting.provider\": \"black\",\n  \"editor.formatOnSave\": true,\n  \"python.linting.flake8Enabled\": true,\n  \"python.linting.enabled\": true\n}\n</code></pre>","tags":["Django"]},{"location":"blog/2024/07/11/project-specific-configuration-vscode/#why-use-this-structure","title":"Why Use This Structure?","text":"<ol> <li> <p>Workspace-Specific Configuration:</p> <ul> <li>The <code>.vscode/settings.json</code> file allows you to specify settings that are unique to the workspace. These settings will only apply to the current project and won't affect other projects or your global VS Code settings.</li> </ul> </li> <li> <p>Project Consistency:</p> <ul> <li>By committing the <code>.vscode/settings.json</code> file to your version control system, you ensure that all team members have a consistent development environment setup.</li> </ul> </li> </ol>","tags":["Django"]},{"location":"blog/2024/07/11/project-specific-configuration-vscode/#adding-other-config-files","title":"Adding Other Config Files","text":"<ul> <li> <p><code>pyproject.toml</code>: Place in the root of your project. This file is used for configuring tools like Black and other project-specific settings.</p> </li> <li> <p><code>.flake8</code>: Also place in the root of your project. This file configures flake8\u2019s linting rules.</p> </li> </ul> <p>This structure helps keep your project organized and ensures that all contributors use the same settings, improving consistency and reducing configuration issues.</p>","tags":["Django"]},{"location":"blog/2024/07/11/project-specific-configuration-vscode/#question","title":"Question","text":"why we are creating separaye .flake8 file if we add flake8 configuration in pyproject.toml <p>You don\u2019t need both files. The decision between using <code>pyproject.toml</code> and <code>.flake8</code> often comes down to whether you prefer a unified configuration file for all tools or a dedicated file for Flake8. If you\u2019re starting a new project or modernizing an existing one, using <code>pyproject.toml</code> is a good practice due to its ability to handle configurations for multiple tools in one place. However, if you\u2019re maintaining an older project or have specific reasons, using .flake8 is also perfectly valid.</p>","tags":["Django"]},{"location":"blog/2024/01/18/how-to-set-up-a-virtual-environment-in-python/","title":"How to Set Up a Virtual Environment in Python","text":"","tags":["Python"]},{"location":"blog/2024/01/18/how-to-set-up-a-virtual-environment-in-python/#how-to-set-up-a-virtual-environment-in-python","title":"How to Set Up a Virtual Environment in Python","text":"<p>A Python virtual environment is a self-contained directory that contains its own Python interpreter and a set of libraries and packages. This environment is isolated from the global Python environment on your system, allowing you to manage project-specific dependencies without affecting other projects or the system-wide Python installation.</p> <p>The primary purpose of a virtual environment is to create an isolated environment for a specific Python project, ensuring that the project's dependencies are consistent and do not interfere with other projects or the system.</p> <p><code>venv</code> is a built-in module in Python that provides support for creating lightweight, isolated Python environments.</p> <ul> <li><code>venv</code> is a standard Python module for creating virtual environments.</li> <li><code>pyenv</code> is a separate tool for managing multiple Python versions.</li> <li><code>pyenv-virtualenv</code> is a plugin for pyenv that extends its functionality to include virtual environment management.</li> </ul> <p>The most commonly used tools for creating virtual environments in Python are <code>venv</code> (built into Python 3.3 and later) and <code>virtualenv</code> (a third-party package). These tools allow you to:</p> venvvirtualenvconda <ul> <li> <p>Description:</p> <p><code>venv</code> is a built-in module in Python 3.3 and later, and it's used for creating lightweight, isolated Python environments. If you're using Python 3.3 or later, <code>venv</code> is a good choice for managing virtual environments.</p> </li> <li> <p>Strengths:</p> <ul> <li>Simplicity and ease of use.</li> <li>Built into the Python standard library.</li> <li>Ideal for basic use cases and projects with straightforward requirements.</li> </ul> </li> <li> <p>Commands:</p> bash<pre><code># Create a virtual environment\npython -m venv venv\n\n# OR:: Replace \"myenv\" with your preferred environment name\n# To Create Specific python version\npython3.8 -m venv myenv\n\n# Activate the virtual environment\n\n# On Windows\n.\\myenv\\Scripts\\activate\n\n# On Unix or MacOS\nsource myenv/bin/activate\n</code></pre> <p>Replace <code>3.8</code> with the desired Python version. The <code>-m venv</code> command uses the <code>venv</code> module to create the virtual environment. This will create a virtual environment with the specified Python version.</p> </li> </ul> <ul> <li> <p>Description</p> <p><code>virtualenv</code> is a third-party Python package that provides tools for creating isolated Python environments. It allows you to create multiple virtual environments on a single system, each with its own Python interpreter and set of installed packages.</p> <p><code>virtualenv</code> is not included in the Python standard library, so you need to install it separately using  <code>pip</code>.</p> </li> <li> <p>Strength</p> <ul> <li>Compatible with both <code>Python 2</code> and <code>Python 3</code>, providing flexibility for projects on different Python versions.</li> <li>Allows customization during virtual environment creation, such as specifying the Python interpreter version and additional options.</li> <li>Offers high-level isolation, allowing for independent Python environments for different projects.</li> </ul> </li> <li> <p>Commands</p> bash<pre><code># Install virtualenv if not already installed\npip install virtualenv\n\n# Replace \"myenv\" with your preferred environment name\nvirtualenv myenv\n\n# OR:: Replace \"myenv\" with your preferred environment name\nvirtualenv --python=python3.8 myenv\n\n# Activate the virtual environment\n\n# On Windows\n.\\myenv\\Scripts\\activate\n\n# On Unix or MacOS\nsource myenv/bin/activate\n</code></pre> <p>Replace <code>3.8</code> with the desired Python version. The <code>--python</code> option allows you to specify the Python interpreter for the virtual environment.</p> </li> </ul> <ul> <li> <p>Description:</p> <p>Conda is a cross-platform package manager and environment manager that can install, run, and update packages and their dependencies. It is not Python-specific and can manage environments for multiple programming languages.</p> </li> <li> <p>Strengths</p> <ul> <li>Cross-language support (not limited to Python).</li> <li>Manages both Python packages and non-Python packages.</li> <li>Handles complex dependencies and environments effectively.</li> </ul> </li> <li> <p>Commands</p> bash<pre><code># Create a conda environment\nconda create --name myenv\n\n# OR::\nconda create --name my_env python=3.8\n\n# Activate the conda environment\nconda activate myenv\n\n# Deactivate the conda environment\nconda deactivate\n</code></pre> <p>Conda can be particularly useful when working on projects with dependencies that extend beyond Python, or when you need to manage environments with specific versions of non-Python libraries.</p> </li> </ul> <p>Notes</p> <p>Choose the approach that fits your preferences and requirements. Keep in mind that <code>venv</code> is included in the Python standard library, while <code>virtualenv</code> is a separate package that needs to be installed. If you're using a specific Python version, it's crucial to ensure that version is installed on your system before creating the virtual environment.</p>","tags":["Python"]},{"location":"blog/2024/01/18/how-to-set-up-a-virtual-environment-in-python/#reference","title":"Reference","text":"<ul> <li> <p>What is the difference between venv, pyvenv, pyenv, virtualenv, virtualenvwrapper, pipenv</p> </li> <li> <p>Understanding Python virtual environments using venv and virtualenv</p> </li> </ul>","tags":["Python"]},{"location":"blog/2024/06/29/python---magic-or-dunder-methods/","title":"Python - Magic or Dunder Methods","text":"","tags":["python","magic"]},{"location":"blog/2024/06/29/python---magic-or-dunder-methods/#python-magic-or-dunder-methods","title":"Python - Magic or Dunder Methods","text":"<p>In Python, <code>special methods</code> are also called <code>magic methods</code>, or <code>dunder methods</code>. This latter terminology, dunder, refers to a particular naming convention that Python uses to name its special methods and attributes. </p> <p>Python magic methods, also known as <code>dunder methods</code> (short for \"double underscore\"), are special methods that Python uses to perform various operations. They are called \"magic\" ==because they are invoked implicitly by the Python interpreter in response to specific operations on objects=.</p> Special Method Description <code>.__init__()</code> Provides an initializer in Python classes <code>.__str__() and .__repr__()</code> Provide string representations for objects <code>.__call__()</code> Makes the instances of a class callable <code>.__len__()</code> Supports the len() function <code>__main__</code> <p>In Python, main is not a magic method but rather a special name for the namespace in which the top-level script executes. When a Python file is run directly as a script (not imported as a module), the Python interpreter sets the special variable name to have the value \"main\" within that script's namespace.</p> <p>Here\u2019s how it typically works:</p> <ol> <li> <p>Main Script Execution: When you run a Python script directly by calling python script.py from the command line, Python sets name to \"main\" for that script.</p> </li> <li> <p>Module Import: If a script is imported as a module by another script using import, then name is set to the name of the module (e.g., \"module_name\"), not \"main\".</p> </li> </ol> <p>This mechanism allows Python scripts to distinguish between being run as the main program versus being imported as a module into another program. This distinction is often used to include or exclude certain blocks of code depending on how the script is being used.</p> <code>__name__</code> built-in variable <p>In Python, <code>__name__</code> is a special built-in variable. Its value depends on how and where the Python interpreter is running the code.</p> <ol> <li> <p>When Python runs a script directly:</p> <ul> <li>If a Python script is executed directly using python script.py from the command line or by clicking on it in an IDE, Python sets <code>__name__</code> to \"main\" in that script's namespace.</li> <li> <p>This allows the script to execute certain code only if it is being run as the main program and not when it is imported as a module into another script.</p> <pre><code># script.py\n\ndef main():\n    print(\"This is the main function.\")\n\nif __name__ == \"__main__\":\n    main()\n</code></pre> </li> <li> <p>When you run python <code>script.py</code>, the condition <code>__name__</code> == \"main\" evaluates to True, so main() function will be called and \"This is the main function.\" will be printed.</p> </li> </ul> </li> <li> <p>When Python imports a module:</p> <ul> <li>If a Python script is imported as a module into another script using import script, Python sets <code>__name__</code> to \"script\" in the imported script's namespace.</li> <li> <p>This allows the imported script to define functions, classes, and variables without executing the main logic that may be intended only for direct execution.</p> <pre><code># another_script.py\nimport script\n\n# In script.py, __name__ will be \"script\", \n# so the code under if __name__ == \"__main__\": will not execute.\n</code></pre> </li> <li> <p>Here, <code>__name__</code> in <code>script.py</code> will be \"script\", so the code inside the if <code>__name__</code> == \"main\": block will not execute when script.py is imported as a module.</p> </li> </ul> </li> </ol> <p>Summary:</p> <ul> <li><code>__name__</code> == \"main\": Used to check if a script is being run directly by the Python interpreter.</li> <li><code>__name__</code> == \"<code>&lt;module_name&gt;</code>\": Used when a script is imported as a module into another script, indicating its module name.</li> </ul> <p>By using <code>__name__</code>, Python scripts can be designed to behave differently based on whether they are the main program or a module being imported, providing flexibility in organizing and executing Python code.</p>","tags":["python","magic"]},{"location":"blog/2024/06/29/python---magic-or-dunder-methods/#reference","title":"Reference","text":"<ul> <li>Python - Magic or Dunder Methods</li> <li>Python's Magic Methods</li> <li> <p>A Guide to Python's Magic Methods</p> </li> <li> <p>Defining Main Functions in Python</p> </li> </ul>","tags":["python","magic"]},{"location":"blog/2024/06/18/the-restful-api-architecture/","title":"The RESTful API architecture","text":"","tags":["package","python"]},{"location":"blog/2024/06/18/the-restful-api-architecture/#the-restful-api-architecture","title":"The RESTful API architecture","text":"<p>DRF is an extension of Django for developing and deploying RESTful APIs.</p> <ul> <li>Introducing RESTful APIs</li> <li>Building RESTful APIs with DRF</li> <li>Error handling</li> </ul> <p></p>","tags":["package","python"]},{"location":"blog/2024/06/18/the-restful-api-architecture/#introduction","title":"Introduction","text":"<p>RESTful APIs cover the following basic parts:</p> <p>intro</p> <ul> <li> <p>Resources:</p> <p>The information a client can request where the API gathers the information per entity as a resource such as a customer or product. In the example of <code>Figure 5.1</code>, the trip is a resource. And for our sample microservices application, the address is a resource.</p> </li> <li> <p>Endpoints:</p> <p>The URLs where the API exposes itself and clients send requests.</p> </li> </ul> <p>And RESTful APIs process these parts to handle requests:</p> <ol> <li> <p>HTTP methods: The methods a client uses to send a request to an API:</p> <p>methods</p> <ul> <li>GET request: Retrieve data about a resource</li> <li>POST request: Create a resource</li> <li>PATCH request: Update a resource partially</li> <li>PUT request: Overwrite a resource entirely</li> <li>DELETE request: Remove a resource</li> </ul> </li> <li> <p>Parameters: The options clients send to an endpoint to retrieve specific resource information or to authenticate:</p> <p>parameters</p> <ul> <li>Header: Such as an API security key to authorize a request</li> <li>Path: As part of the called URL to address a specific resource</li> <li>Query string: As part of the called URL to select a subset of resources</li> </ul> </li> <li> <p>Request body: The JSON or XML objects a client sends to an API as resource data</p> </li> </ol> <p>Let\u2019s bring these parts together in some <code>curl</code> examples. The first example requests a list of all hostels in the Tripadvisor system:</p> <pre><code>$ curl -X GET https://api.trip.com/v1/hostels/\n</code></pre>","tags":["package","python"]},{"location":"blog/2024/06/18/the-restful-api-architecture/#building-restful-apis-with-drf","title":"Building RESTful APIs with DRF","text":"<p>DRF is an extension of Django for developing and deploying RESTful APIs.</p> <p>Abstract</p> <p>DRF provides us with these functionalities:</p> <ul> <li>The actual API that clients can access through one or more endpoints</li> <li>Serializers that collaborate with Django ORM to transform data from data source to JSON and the other way around</li> <li>A set of pre-defined views to quickly and easily create API endpoints for CRUD operation</li> </ul> <p>DRF</p> <p>If we transpose this to Django and zoom in on the Django file structure, we\u2019ll see that DRF is primarily about these standard Django files:</p> <ul> <li>models.py: Containing the data model for our API</li> <li>views.py: Containing the API viewset and specifications for CRUD operations</li> <li>urls.py: Containing the endpoints for our API views</li> </ul> <p>There is also this specific DRF file:</p> <ul> <li>serializers.py: Containing the serialization specification for the model</li> </ul> <p>These files work closely together as the <code>serializer</code>; the <code>view</code> uses the <code>model</code> (the serializer), and the <code>URL</code> file uses the view.</p> <p>With this in mind, let\u2019s start building a RESTful API for our subscription application</p> <p></p> <p>The RESTful API will have this directory structure:</p> <pre><code>subscription_apis/\n\u2502\n\u251c\u2500\u2500 address_api/\n\u2502\u202f\u202f\u202f\u251c\u2500\u2500 models.py\n\u2502\u202f\u202f\u202f\u251c\u2500\u2500 serializers.py\n\u2502\u202f\u202f\u202f\u251c\u2500\u2500 urls.py\n\u2502\u202f\u202f\u202f\u2514\u2500\u2500 views.py\n\u2502\n\u251c\u2500\u2500 subscription_apis/\n\u2502\u202f\u202f\u202f\u251c\u2500\u2500 urls.py\n\u2502\u202f\u202f\u202f\u2514\u2500\u2500 settings.py\n\u2502\n\u2514\u2500\u2500 manage.py\n</code></pre> <p>And to build the RESTful API, we\u2019ll take this route:</p> <ol> <li>Setting up DRF</li> <li>Creating a model and a serializer</li> <li>Creating a view and a URL file for the endpoints</li> </ol> Creating a view and the URL endpoints <p>DRF was first released in 2011, and over time, the view mechanism evolved from <code>function-based</code> to <code>class-based</code> views</p> function-based viewsclass-based views <p>Function-based views are, as their name implies, based on a Python function, which defines the view\u2019s behavior. A function becomes a function-based view by decorating it like this:</p> <pre><code>@api_view(['GET', 'POST'])\ndef address_list(request):\n\u202f\u202f\u202f\u202fif request.method == 'GET':\n\u202f\u202f\u202f\u202f\u202f\u202f\u202f...\n\u202f\u202f\u202f\u202felif request.method == 'POST':\n        ...\n</code></pre> <p>The <code>@api-view</code> decorator promotes the <code>address_list</code> function to a <code>function-based</code> view, which clients can access through the GET and POST methods. Consequently, the <code>if</code> ... <code>elif</code> section handles <code>GET</code> and <code>POST</code> requests.</p> <p>Likewise, class-based views are based on DRF-specific Python classes:</p> <pre><code>class AddressViewSet(viewsets.ModelViewSet):\n\u202f\u202f\u202f\u202fqueryset = Address.objects.all()\n\u202f\u202f\u202f\u202fserializer_class = AddressSerializer\n</code></pre> <p>The generic <code>ModelViewSet</code> class integrates all HTTP methods, including <code>PUT</code> and <code>DELETE</code>, and covers most RESTful API requirements. All we have to do is specify a <code>queryset</code> object and a <code>serializer_class</code> object for the viewset, and DRF takes care of the rest.</p> <p></p> <p>Despite the evolution from <code>function-based</code> to <code>class-based</code> views, both view types still exist today, and their characteristics and differences come down to this:</p> <p>Important note</p> <p>In general, apply class-based views if you can and function-based views if you must because of some specific functionalities offered only by function-based views.</p>","tags":["package","python"]},{"location":"blog/2024/06/18/the-restful-api-architecture/#reference","title":"Reference","text":"<ul> <li>Hand on Microservices with Django</li> </ul>","tags":["package","python"]},{"location":"blog/2024/06/27/reverse-in-django/","title":"reverse() in django","text":"","tags":["django","env"]},{"location":"blog/2024/06/27/reverse-in-django/#reverse-in-django","title":"reverse() in django","text":"<p>In Django, the <code>reverse()</code> function is a powerful utility provided by the <code>django.urls</code> module that helps generate URLs for Django views based on their names and optional parameters. It is primarily used to avoid hardcoding URLs in your Django applications, promoting better code organization, maintainability, and flexibility.</p>","tags":["django","env"]},{"location":"blog/2024/06/27/reverse-in-django/#how-it-works","title":"How it works","text":"<p>How reverse() Works</p> <p>The reverse() function takes the following parameters:</p> <ul> <li> <p>viewname: This parameter is typically the name of a view function or a named URL pattern defined in your Django application's URL configuration (<code>urls.py</code>).</p> </li> <li> <p>args: Optional parameter that holds a list or tuple of positional arguments that the view function expects. These arguments are used to construct the final URL.</p> </li> <li> <p>kwargs: Optional parameter that holds a dictionary of keyword arguments that the view function expects. These arguments are also used to construct the final URL.</p> </li> </ul>","tags":["django","env"]},{"location":"blog/2024/06/27/reverse-in-django/#names-and-namespaces","title":"Names and namespaces","text":"<p>Always name your patterns. It helps in decoupling your code from the exact URL paths. For instance, in the previous <code>URLConf</code>, if you want to redirect to the <code>About</code> page, it might be tempting to use <code>redirect(\"/about\")</code> . Instead, use <code>redirect(\"about\")</code> , as it uses the name rather than the <code>path</code>.</p> <pre><code>&gt;&gt;&gt; from django.urls import reverse\n&gt;&gt;&gt; reverse(\"hello_fn\")\n/hello-fn/\n&gt;&gt;&gt; reverse(\"year_view\", kwargs={\"year\": \"793\"})\n/year/793/\n</code></pre> <p>Defination</p> NameNamespaceapp_name <p>Name is like a nickname or label you give to a specific web address (URL) in your Django application. It's used so you can easily refer to that URL in your code without having to remember or repeat the actual URL string.</p> <p>Example:</p> <p>If your Django app has a page for \"About Us\" with the URL <code>/about/</code>, you can name it 'about'. So, instead of writing <code>/about/</code> everywhere in your code, you just use 'about'.</p> <pre><code>from django.urls import path\nfrom . import views\n\nurlpatterns = [\n    path('about/', views.about, name='about'),\n    path('detail/&lt;int:pk&gt;/', views.detail, name='detail'),\n    # Other URL patterns...\n]\n</code></pre> <p>Namespace is a way to group and organize URLs from different parts of your Django project, especially useful when you have multiple apps with their own URLs. It helps prevent URLs from conflicting with each other.</p> <p>Example:</p> <p>Imagine you have two Django apps: blog and shop. Both might have a page named 'detail', but they mean different things (like a blog post detail versus a product detail). By using namespaces like 'blog:detail' and 'shop:detail', Django knows which one you're referring to.</p> <pre><code>from django.urls import include, path\n\nurlpatterns = [\n    path('myapp/', include('myapp.urls', namespace='myapp')),\n    # Other URL patterns...\n]\n</code></pre> <p>app_name is used inside a Django app's <code>urls.py</code> file to set the namespace for all the URLs defined in that file. It's like giving a name to the collection of URLs within that app, so Django can organize them correctly.</p> <p>app_name in Django is a variable used within a Django application's <code>urls.py</code> file to define the application namespace for its URL patterns.</p> <p>Example:</p> <p>In your blog app's <code>urls.py</code>, if you set app_name = 'blog', then all URLs defined there will belong to the 'blog' namespace. This helps Django resolve URLs correctly when you use functions like <code>reverse()</code> to generate URLs dynamically.</p> <pre><code>from django.urls import path\nfrom . import views\n\napp_name = 'myapp'\n\nurlpatterns = [\n    path('', views.index, name='index'),\n    path('about/', views.about, name='about'),\n    path('detail/&lt;int:pk&gt;/', views.detail, name='detail'),\n    # Other URL patterns...\n]\n</code></pre> Example blog/urls.pyshop/urls.pymyproject/urls.py <pre><code>from django.urls import path\nfrom . import views\n\napp_name = 'blog'\n\nurlpatterns = [\n    path('', views.index, name='index'),  # URL: /blog/\n    path('post/&lt;int:pk&gt;/', views.post_detail, name='post_detail'),  # URL: /blog/post/1/\n    # Other URL patterns specific to the blog app...\n]\n</code></pre> <pre><code>from django.urls import path\nfrom . import views\n\napp_name = 'shop'\n\nurlpatterns = [\n    path('', views.index, name='index'),  # URL: /shop/\n    path('product/&lt;int:pk&gt;/', views.product_detail, name='product_detail'),  # URL: /shop/product/1/\n    # Other URL patterns specific to the shop app...\n]\n</code></pre> <pre><code>from django.contrib import admin\nfrom django.urls import path, include\n\nurlpatterns = [\n    path('admin/', admin.site.urls),\n    path('blog/', include('blog.urls', namespace='blog')),  # Include blog app URLs with namespace 'blog'\n    path('shop/', include('shop.urls', namespace='shop')),  # Include shop app URLs with namespace 'shop'\n    # Other project-specific URL patterns...\n]\n</code></pre>","tags":["django","env"]},{"location":"blog/2024/06/27/reverse-in-django/#pattern-order","title":"Pattern order","text":"<p>Order your patterns to take advantage of how Django processes them, that is, top-down. A good rule of thumb is to keep all the special cases at the top. Broader or more general patterns can be mentioned further down. The broadest, a catch-all-if present, can go at the very end.</p> <p>For example, the path to your <code>Blog</code> posts might be any valid set of characters, but you might want to handle the <code>About</code> page separately. The right sequence of patterns should be as follows:</p> <pre><code>blog_patterns = [\n    path('about/', views.AboutView.as_view(), name= 'about'),\n    path('&lt;slug:slug&gt;/', views.ArticleView.as_view(), name='article'),\n]\n</code></pre> <p>if we reverse the order, then the special case, the <code>AboutView</code>, will never get called.</p>","tags":["django","env"]},{"location":"blog/2024/06/27/reverse-in-django/#url-pattern-styles","title":"URL pattern styles","text":"<p>Designing URLs of a site can easily be consistently overlooked. Well-designed URLs can not only logically organize your site, but can also make it easy for users to guess paths. Poorly designed ones can even be a security risk: for example, using a database ID (which occurs in a monotonic increasing sequence of integers) in a URL pattern can increase the risk of information theft or site ripping. Let's examine some common styles followed in designing URLs.</p>","tags":["django","env"]},{"location":"blog/2024/06/27/reverse-in-django/#reference","title":"Reference","text":"<ul> <li>django reverse: official</li> </ul>","tags":["django","env"]},{"location":"blog/2024/06/21/secret_key-in-django/","title":"SECRET_KEY in Django","text":"","tags":["secret_key","python"]},{"location":"blog/2024/06/21/secret_key-in-django/#secret_key-in-django","title":"SECRET_KEY in Django","text":"<p>In Django, the <code>SECRET_KEY</code> setting is crucial for cryptographic signing and should be kept confidential. It is used for securing session data, CSRF tokens, and other cryptographic operations. If Django cannot find a <code>SECRET_KEY</code> defined in your project's settings, it raises an ImproperlyConfigured exception because it cannot operate securely without it.</p>","tags":["secret_key","python"]},{"location":"blog/2024/06/21/secret_key-in-django/#what-is-secret_key","title":"What is SECRET_KEY?","text":"<p>The <code>SECRET_KEY</code> in Django is a cryptographic key used for various security operations within your application. It is fundamental to Django's session management, CSRF protection, and other cryptographic operations. Essentially, it acts as a private key that helps Django generate secure tokens and hashes, ensuring that sensitive data remains safe from unauthorized access and tampering.</p> <p>settings.py</p> <pre><code># settings.py\n\nimport os\nfrom django.core.management.utils import get_random_secret_key\n\n# Load SECRET_KEY from environment variable if available, otherwise generate a new one\nSECRET_KEY = os.getenv('DJANGO_SECRET_KEY', default=get_random_secret_key())\n</code></pre> <p>In this example:</p> <ul> <li>It attempts to load SECRET_KEY from an environment variable DJANGO_SECRET_KEY.</li> <li>If the environment variable is not set, it generates a new random secret key using get_random_secret_key().</li> </ul> <ul> <li> <p>Check for environment-specific configurations: If you are using environment variables or configuration management tools (like django-environ or python-decouple), ensure that the <code>SECRET_KEY</code> is properly set in your environment variables or configuration files.</p> </li> <li> <p>Restart Django server: After updating the <code>SECRET_KEY</code> setting, restart your Django development server to apply the changes.</p> </li> </ul>","tags":["secret_key","python"]},{"location":"blog/2024/06/21/secret_key-in-django/#best-practices-for-managing-secret_key","title":"Best Practices for Managing SECRET_KEY:","text":"<ol> <li> <p>Do Not Hardcode SECRET_KEY:</p> <ul> <li> <p>Generate Securely: Use Django's get_random_secret_key() function to generate a new random SECRET_KEY. Never hardcode or expose this key in your source code repository.</p> </li> <li> <p>Environment Variables: Store SECRET_KEY securely in environment variables or secure configuration management tools. This prevents accidental exposure and aids in managing different deployment environments (development, staging, production).</p> </li> </ul> </li> <li> <p>Security and Maintenance:</p> <ul> <li> <p>Regenerate Periodically: For added security, regenerate SECRET_KEY periodically (e.g., every few months). Update it across all deployment environments and ensure all team members are aware of the change.</p> </li> <li> <p>Keep It Private: Treat SECRET_KEY as confidential information. Avoid sharing it in public forums, version control systems, or unencrypted channels.</p> </li> </ul> </li> </ol>","tags":["secret_key","python"]},{"location":"blog/2024/06/21/secret_key-in-django/#conclusion","title":"Conclusion:","text":"<p>In conclusion, while the <code>SECRET_KEY</code> setting in Django may seem like a minor detail, its impact on application security and integrity cannot be overstated. By understanding its role and implementing best practices for its management, you can significantly enhance the security posture of your Django applications. Remember, a well-managed SECRET_KEY is not just a good practice\u2014it's a critical component of a robust defense against potential security threats.</p> <p>Implement these recommendations in your Django projects to safeguard sensitive data, protect against common web vulnerabilities, and ensure a secure user experience.</p>","tags":["secret_key","python"]},{"location":"blog/2024/04/16/unveiling-pythons-hidden-gems-exploring-the-secrets-module/","title":"Unveiling Python's Hidden Gems: Exploring the Secrets Module","text":""},{"location":"blog/2024/04/16/unveiling-pythons-hidden-gems-exploring-the-secrets-module/#unveiling-pythons-hidden-gems-exploring-the-secrets-module","title":"Unveiling Python's Hidden Gems: Exploring the Secrets Module","text":"<p>The secrets module in Python is a powerhouse when it comes to handling sensitive data such as passwords, API keys, and cryptographic tokens. Its primary purpose? Generating cryptographically strong random numbers suitable for managing data in a secure manner.</p> <p>Starting in Django 3.0 the key begins with <code>django-insecure</code> as an additional prompt to tell developers not to use this specific key in production.</p> <p>SECRET_KEY</p> <pre><code>import secrets\nprint(secrets.token_urlsafe())\n\ndir(secrets)\nhelp(secrets)\n</code></pre> <p>Copy and paste this new value into the <code>.env</code> file.</p> .env<pre><code>DEBUG=True\nSECRET_KEY=imDnfLXy-8Y-YozfJmP2Rw_81YA_qx1XKl5FeY0mXyY\n</code></pre>"},{"location":"blog/2024/04/16/unveiling-pythons-hidden-gems-exploring-the-secrets-module/#reference","title":"Reference","text":"<ul> <li>Django for Beginner: SECRET_KEY</li> <li>3rd Party Packages</li> <li>Projects to speed up the development of new projects.</li> <li>Django starter project with \ud83d\udd0b</li> <li>drfx for rest api</li> </ul>"},{"location":"blog/2024/07/13/how-to-send-multipartform-data-request-file-in-postman/","title":"How to send multipart/form-data request file in postman","text":"","tags":["js"]},{"location":"blog/2024/07/13/how-to-send-multipartform-data-request-file-in-postman/#how-to-send-multipartform-data-request-file-in-postman","title":"How to send multipart/form-data request file in postman","text":"","tags":["js"]},{"location":"blog/2024/07/13/how-to-send-multipartform-data-request-file-in-postman/#reference","title":"Reference","text":"<ul> <li>Video: How to send multipart/form-data request file</li> <li>How to send multipart/form-data request using Postman :closed</li> </ul>","tags":["js"]},{"location":"blog/2024/05/15/separating-business-logic-and-presentation-in-django/","title":"Separating Business Logic and Presentation in Django","text":""},{"location":"blog/2024/05/15/separating-business-logic-and-presentation-in-django/#separating-business-logic-and-presentation-in-django","title":"Separating Business Logic and Presentation in Django","text":"<p>In Django web development, maintaining a clear separation of concerns between business logic and presentation logic is essential for building scalable, maintainable, and reusable applications. By adhering to best practices and following established patterns, developers can ensure that their code remains organized, flexible, and easy to maintain.</p>"},{"location":"blog/2024/05/15/separating-business-logic-and-presentation-in-django/#1-using-class-based-views-cbvs","title":"1. Using Class-Based Views (CBVs):","text":"<p>Example</p> <p>Django's class-based views provide a structured approach to handling HTTP requests and responses. By defining views as classes, developers can encapsulate related functionality and separate concerns more effectively. For instance, ListView and DetailView are commonly used to display lists of objects and detailed views respectively, while keeping the presentation logic separate from the business logic.</p> <pre><code>from django.views.generic import ListView\nfrom .models import Product\n\nclass ProductListView(ListView):\n    model = Product\n    template_name = 'products/product_list.html'\n    context_object_name = 'products'\n</code></pre> <p>In this example, the ProductListView class-based view retrieves a list of products from the database using the Product model and renders them in a template called <code>product_list.html</code>.</p>"},{"location":"blog/2024/05/15/separating-business-logic-and-presentation-in-django/#2-thin-views-fat-models","title":"2. Thin Views, Fat Models:","text":"<p>Example</p> <p>Following the \"thin views, fat models\" principle encourages developers to keep views lightweight by moving most of the business logic into model methods. Models represent the application's data and are the ideal place to encapsulate business logic related to data manipulation, validation, and operations. This approach enhances code readability and maintainability by keeping views focused on handling HTTP requests and responses.</p> <pre><code>from django.db import models\n\nclass Product(models.Model):\n    name = models.CharField(max_length=100)\n    price = models.DecimalField(max_digits=10, decimal_places=2)\n\n    def calculate_discounted_price(self, discount_percent):\n        return self.price * (1 - discount_percent / 100)\n</code></pre> <p>In the Product model, we define a method called <code>calculate_discounted_price()</code> to encapsulate the logic for calculating the discounted price of a product. This keeps the view simple while moving the business logic to the model layer.</p>"},{"location":"blog/2024/05/15/separating-business-logic-and-presentation-in-django/#3-service-layers","title":"3. Service Layers:","text":"<p>Example</p> <p>Introducing service layers allows developers to encapsulate complex business logic that doesn't fit naturally into models or views. Service classes provide a dedicated place to house business logic that operates on multiple models or involves complex operations. This approach promotes code reusability and modularity by separating the concerns of data manipulation and business logic from the presentation layer.</p> services.py<pre><code>class ProductService:\n    @staticmethod\n    def get_discounted_price(product, discount_percent):\n        return product.price * (1 - discount_percent / 100)\n</code></pre> <p>In a service class called <code>ProductService</code>, we define a method <code>get_discounted_price()</code> to encapsulate the logic for calculating the discounted price of a product. This service class can be used in views or other parts of the application to access the business logic.</p>"},{"location":"blog/2024/05/15/separating-business-logic-and-presentation-in-django/#4-template-tags-and-filters","title":"4. Template Tags and Filters:","text":"<p>Example</p> <p>Django's template system supports custom template tags and filters, which enable developers to encapsulate presentation logic in templates. Custom template tags and filters can be used to format data, perform conditional checks, or execute custom logic directly within templates. This approach enhances template readability and maintainability by keeping presentation-related logic separate from business logic.</p> custom_filters.py<pre><code># templatetags/custom_filters.py\n\nfrom django import template\n\nregister = template.Library()\n\n@register.filter\ndef format_price(value):\n    return f\"${value:.2f}\"\n</code></pre> <p>In a custom template filter called <code>format_price</code>, we define a filter to format a numeric value as a currency string with two decimal places. This filter can be used in templates to format prices.</p>"},{"location":"blog/2024/05/15/separating-business-logic-and-presentation-in-django/#5-separate-apps-and-modules","title":"5. Separate Apps and Modules:","text":"<p>Example</p> <p>Organize your Django project into separate apps, each focusing on a specific functional area. For example, you might have separate apps for products, orders, users, etc., each containing models, views, and templates related to that area.</p>"},{"location":"blog/2024/05/15/separating-business-logic-and-presentation-in-django/#6-dry-dont-repeat-yourself","title":"6. DRY (Don't Repeat Yourself):","text":"<p>Example</p> <p>Identify repeated logic across views, models, and templates, and refactor it into reusable components. For example, if you find similar querysets being used in multiple views, consider creating a custom manager or utility function to encapsulate the logic.</p>"},{"location":"blog/2024/05/15/separating-business-logic-and-presentation-in-django/#7-tests","title":"7. Tests:","text":"<p>Example</p> <p>Write comprehensive unit tests for your business logic, ensuring that it behaves as expected and remains consistent across changes. For example, you might write tests to validate the behavior of model methods, view functions, and template tags.</p> <p>By applying these principles and practices in your Django projects, you can achieve a clear separation of concerns between business logic and presentation logic, leading to cleaner, more maintainable code.</p>"},{"location":"blog/2024/07/19/serve-static-files-in-production/","title":"Serve Static Files in Production","text":"","tags":["Django","production"]},{"location":"blog/2024/07/19/serve-static-files-in-production/#serve-static-files-in-production","title":"Serve Static Files in Production","text":"<p>Serving static files (CSS, images, JS) in a production environment for a <code>Django application</code> hosted on shared hosting can be a bit tricky because shared hosting environments often have limitations and different configurations compared to dedicated servers or cloud services.</p> <p>Here\u2019s a general approach to handling static files in such a setup:</p> <ol> <li> <p>Configure Static Files in <code>settings.py</code></p> <p>First, ensure your <code>settings.py</code> file is configured correctly for static files:</p> <pre><code>import os\n\n# Define the URL prefix for static files\nSTATIC_URL = '/static/'\n\n# Define the directory to collect static files for deployment\nSTATIC_ROOT = os.path.join(BASE_DIR, 'staticfiles')\n\n# Add your static files directories (if any)\nSTATICFILES_DIRS = [\n    os.path.join(BASE_DIR, 'static'),  # or wherever your static files are located\n]\n</code></pre> </li> <li> <p>Collect Static Files</p> <p>Run the <code>collectstatic</code> management command to gather all static files into the <code>STATIC_ROOT</code> directory:</p> <pre><code>python manage.py collectstatic\n</code></pre> <p>This command copies all the static files from your <code>STATICFILES_DIRS</code> and apps into the <code>STATIC_ROOT</code> directory.</p> </li> <li> <p>Serve Static Files in Production</p> <p>Since shared hosting often doesn\u2019t support Django's development server and may not be well-suited for serving static files directly, you\u2019ll typically need to configure your web server to serve these files. This is commonly done using either Apache or Nginx.</p> For Apache <ol> <li> <p>Edit the <code>.htaccess</code> File</p> <p>If your shared hosting uses Apache, you might need to configure your <code>.htaccess</code> file to serve static files. Add the following lines to your <code>.htaccess</code> file in the root of your project:</p> <pre><code># Serve static files\nAlias /static/ /path/to/your/project/staticfiles/\n\n&lt;Directory /path/to/your/project/staticfiles&gt;\n    Require all granted\n&lt;/Directory&gt;\n</code></pre> <p>Replace <code>/path/to/your/project/staticfiles/</code> with the absolute path to your <code>STATIC_ROOT</code> directory.</p> </li> <li> <p>Configure Apache</p> <p>In some shared hosting environments, you might not have direct access to Apache\u2019s configuration files. In such cases, configuring through <code>.htaccess</code> is the typical approach.</p> </li> </ol> For Nginx <ol> <li> <p>Edit the Nginx Configuration</p> <p>If you have access to the Nginx configuration, you\u2019ll need to add a location block to serve static files. This configuration might be added to the server block for your site. Example configuration:</p> <pre><code>server {\n    listen 80;\n    server_name yourdomain.com;\n\n    location /static/ {\n        alias /path/to/your/project/staticfiles/;\n    }\n\n    location / {\n        proxy_pass http://127.0.0.1:8000;  # Adjust the upstream server if needed\n        proxy_set_header Host $host;\n        proxy_set_header X-Real-IP $remote_addr;\n        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n        proxy_set_header X-Forwarded-Proto $scheme;\n    }\n}\n</code></pre> <p>Replace <code>/path/to/your/project/staticfiles/</code> with the absolute path to your <code>STATIC_ROOT</code> directory.</p> </li> </ol> </li> <li> <p>Test Your Setup</p> <p>Once you have configured your server to serve static files, test your application to ensure that the static files are being served correctly. You can do this by loading your site and inspecting the network activity in your browser\u2019s developer tools to confirm that static files (CSS, JS, images) are being loaded properly.</p> </li> <li> <p>Review and Troubleshoot</p> <ul> <li>Permissions: Ensure that the permissions for the <code>STATIC_ROOT</code> directory and its contents are set correctly so that the web server can read the files.</li> <li>Caching: Consider using caching mechanisms to improve the performance of serving static files.</li> </ul> </li> </ol> Additional Notes <ul> <li>Limitations: Shared hosting environments often have restrictions that might affect your ability to configure things precisely as needed. In such cases, consult your hosting provider\u2019s documentation or support for guidance.</li> <li>Security: Ensure that your configuration does not expose sensitive files or directories.</li> </ul> <p>By following these steps, you should be able to serve static files efficiently in a production environment on shared hosting.</p>","tags":["Django","production"]},{"location":"blog/2024/07/19/serve-static-files-in-production/#question","title":"Question","text":"","tags":["Django","production"]},{"location":"blog/2024/07/19/serve-static-files-in-production/#question-1","title":"Question 1","text":"<p>doesn't we need to serve in the settings <code>urls.py</code></p>","tags":["Django","production"]},{"location":"blog/2024/07/19/serve-static-files-in-production/#overview","title":"Overview","text":"<p>In Django, serving static files in production typically involves configuring the web server (like Apache or Nginx) rather than Django itself. However, it\u2019s important to understand how Django\u2019s <code>urls.py</code> file is involved in this process, particularly during development.</p> <p>Here\u2019s a detailed look at how Django\u2019s <code>urls.py</code> plays a role and how it differs from serving static files in production:</p>","tags":["Django","production"]},{"location":"blog/2024/07/19/serve-static-files-in-production/#development-vs-production","title":"Development vs. Production","text":"During Development <p>In development, Django's <code>built-in</code> server can handle serving static files. You typically include the following lines in your <code>urls.py</code> to serve static files:</p> <pre><code>from django.conf import settings\nfrom django.conf.urls.static import static\nfrom django.contrib import admin\nfrom django.urls import path\n\nurlpatterns = [\n    path('admin/', admin.site.urls),\n    # Add other URL patterns here\n]\n\n# Serve static files during development\nif settings.DEBUG:\n    urlpatterns += static(settings.STATIC_URL, document_root=settings.STATIC_ROOT)\n</code></pre> <p>In this setup:</p> <ul> <li><code>settings.DEBUG</code>should be <code>True</code> for this configuration to apply.</li> <li><code>static()</code> is a utility function provided by Django to handle static file serving in development.</li> </ul> In Production <p>In production, Django\u2019s development server is not used. Instead, static files are typically served by a web server like Apache or Nginx, or through a CDN (Content Delivery Network). Here\u2019s why <code>urls.py</code> is not usually used for serving static files in production:</p> <ol> <li> <p>Efficiency: Web servers like Apache and Nginx are optimized to serve static files directly. This is much more efficient than using Django to serve these files.</p> </li> <li> <p>Security and Scalability: Serving static files through a web server helps in maintaining security and scalability. It allows Django to focus on dynamic content generation while the web server handles static file delivery.</p> </li> </ol> Production Configuration Steps <p>Here\u2019s a summary of how to configure Django and your web server for static files in production:</p> <ol> <li> <p>Django Configuration (<code>settings.py</code>):</p> <ul> <li>Ensure <code>STATIC_URL</code> and <code>STATIC_ROOT</code> are properly set up.</li> <li>Run <code>python manage.py collectstatic</code> to gather static files in the <code>STATIC_ROOT</code> directory.</li> </ul> </li> <li> <p>Web Server Configuration:</p> <p>For Apache:</p> <ul> <li>Use <code>.htaccess</code> or your hosting provider\u2019s configuration to serve static files.</li> </ul> <p>For Nginx:</p> <ul> <li>Configure a <code>location</code> block to serve static files directly.</li> </ul> </li> <li> <p>Review and Test:</p> <ul> <li>Ensure that static files are accessible and properly served by your web server.</li> </ul> </li> </ol>","tags":["Django","production"]},{"location":"blog/2024/07/19/serve-static-files-in-production/#summary","title":"Summary","text":"<ul> <li>Development: Use <code>urls.py</code> to serve static files directly if <code>DEBUG</code> is <code>True</code>.</li> <li>Production: Configure your web server (Apache, Nginx, etc.) to serve static files. Django's <code>urls.py</code> is not used for this purpose in production.</li> </ul> <p>By configuring your web server properly and using Django\u2019s <code>collectstatic</code> management command, you can ensure that static files are served efficiently and securely in a production environment.</p>","tags":["Django","production"]},{"location":"blog/2024/01/02/how-to-implement-tokenization-using-jwt-and-django/","title":"How to Implement Tokenization using JWT and Django","text":"","tags":["SimpleJWT"]},{"location":"blog/2024/01/02/how-to-implement-tokenization-using-jwt-and-django/#how-to-implement-tokenization-using-jwt-and-django","title":"How to Implement Tokenization using JWT and Django","text":"<p>A JSON Web Token authentication plugin for the Django REST Framework.</p> <p>Simple JWT provides a JSON Web Token authentication backend for the Django REST Framework. It aims to cover the most common use cases of JWTs by offering a conservative set of default features. It also aims to be easily extensible in case a desired feature is not present.</p> <pre><code>$ pip install djangorestframework-simplejwt\n</code></pre>","tags":["SimpleJWT"]},{"location":"blog/2024/01/02/how-to-implement-tokenization-using-jwt-and-django/#project","title":"project","text":"<pre><code># urls.py\n\nfrom django.contrib import admin\nfrom django.urls import path, include\nfrom rest_framework_simplejwt.views import TokenObtainPairView, TokenRefreshView\n\nurlpatterns = [\n    path('admin/', admin.site.urls),\n    path('api/token/', TokenObtainPairView.as_view(), name=\"token_obtain_pair\"),\n    path('api/token/refresh', TokenRefreshView.as_view(), name=\"token_refresh\"),\n]\n</code></pre> <pre><code># settings.py\n\nINSTALLED_APPS = [\n  'django.contrib.admin',\n  'django.contrib.auth',\n  'django.contrib.contenttypes',\n  'django.contrib.sessions',\n  'django.contrib.messages',\n  'django.contrib.staticfiles',\n\n  # packages\n  'rest_framework',\n  'rest_framework_simplejwt',\n\n  # apps\n  'apps.accounts',\n  'apps.blogs',\n  'apps.privateapi',\n  'apps.books',\n]\n\n# add this\n\nREST_FRAMEWORK = {\n    'DEFAULT_AUTHENTICATION_CLASSES': [\n        'rest_framework_simplejwt.authentication.JWTAuthentication',\n    ],\n}\n\nSIMPLE_JWT = {\n    'AUTH_HEADER_TYPES': ('Bearer',),\n    'ACCESS_TOKEN_LIFETIME': timedelta(minutes=15),\n    'REFRESH_TOKEN_LIFETIME': timedelta(days=1),\n    'ROTATE_REFRESH_TOKENS': False,\n    'BLACKLIST_AFTER_ROTATION': False,\n    'ALGORITHM': 'HS256',\n    'SIGNING_KEY': SECRET_KEY,\n    'VERIFYING_KEY': None,\n    'AUTH_HEADER_TYPES': ('Bearer',),\n    'USER_ID_FIELD': 'id',\n    'USER_ID_CLAIM': 'user_id',\n    'AUTH_TOKEN_CLASSES': ('rest_framework_simplejwt.tokens.AccessToken',),\n    'TOKEN_TYPE_CLAIM': 'token_type',\n    'SLIDING_TOKEN_REFRESH_EXP_CLAIM': 'refresh_exp',\n    'SLIDING_TOKEN_LIFETIME': timedelta(minutes=15),\n    'SLIDING_TOKEN_REFRESH_LIFETIME': timedelta(days=1),\n}\n</code></pre>","tags":["SimpleJWT"]},{"location":"blog/2024/01/02/how-to-implement-tokenization-using-jwt-and-django/#reference","title":"Reference","text":"<ul> <li>simplejwt</li> </ul>","tags":["SimpleJWT"]},{"location":"blog/2024/06/05/mysqlclient-related-errors-in-ubuntu/","title":"mysqlclient related errors in ubuntu","text":"","tags":["Ubuntu","Django","Python"]},{"location":"blog/2024/06/05/mysqlclient-related-errors-in-ubuntu/#mysqlclient-related-errors-in-ubuntu","title":"mysqlclient related errors in ubuntu","text":"mysqlclient installation with error in ubuntu solved <p>Bug</p> <p><code>/bin/sh: 1</code>: pkg-config: not found</p> <p>Exception: Can not find valid pkg-config name.   Specify MYSQLCLIENT_CFLAGS and MYSQLCLIENT_LDFLAGS env vars manually</p> <p>Install build dependencies</p> <p>Install build dependencies ( specially - pkg-config )</p> bash<pre><code>sudo apt-get install python3-dev default-libmysqlclient-dev build-essential pkg-config\n</code></pre> <p>Reference</p> <ul> <li>mysqlclient installation with error: Exception: Can not find valid pkg-config name</li> </ul> Could not build wheels for cffi <p>Bug</p> <pre><code>Building wheels for collected packages: cffi, mysqlclient\n  Building wheel for cffi (pyproject.toml) ... error\n  error: subprocess-exited-with-error\n\n  \u00d7 Building wheel for cffi (pyproject.toml) did not run successfully.\n  \u2502 exit code: 1\n  \u2570\u2500&gt; [56 lines of output]\n\nERROR: Could not build wheels for cffi, which is required to install pyproject.toml-based projects\n</code></pre> <p>Solved</p> <p>I just installed libffi-dev with <code>sudo apt-get install libffi-dev</code> and it worked.</p> bash<pre><code>sudo apt-get install libffi-dev\n</code></pre> <p>Reference</p> <ul> <li>cffi error solved pip</li> </ul>","tags":["Ubuntu","Django","Python"]},{"location":"blog/2024/06/20/using-sqlite-with-django/","title":"Using sqlite with django","text":"","tags":["sqlite3","django"]},{"location":"blog/2024/06/20/using-sqlite-with-django/#using-sqlite-with-django","title":"Using sqlite with django","text":"<p>Using and managing SQLite databases in both Windows and Ubuntu can be done easily with a few tools and commands. Below are instructions for using SQLite on both operating systems:</p>","tags":["sqlite3","django"]},{"location":"blog/2024/06/20/using-sqlite-with-django/#using-sqlite","title":"Using SQLite","text":"<p>Abstract</p> WindowsUbuntu CLIGUI Tools <ol> <li>Download the SQLite tools from the SQLite Download Page.</li> <li>Extract the downloaded zip file to a directory of your choice.</li> <li>Add the directory to your system PATH to access the SQLite CLI from any command prompt.</li> </ol> <ul> <li> <p>Open a terminal and run the following command:</p> <pre><code>sudo apt install sqlite3\n\n# Using the SQLite CLI:\nsqlite3 mydatabase.db\n</code></pre> </li> </ul> <ol> <li> <p>DB Browser for SQLite:</p> <ul> <li>Download and install DB Browser for SQLite from the official website.</li> <li>Open the application and you can create, open, and manage SQLite databases with a graphical interface.</li> </ul> </li> <li> <p>DBeaver:</p> <ul> <li>Download and install DBeaver from the DBeaver website.</li> <li>Open DBeaver, create a new connection, and select SQLite as the database type. You can then manage your SQLite databases through this tool.</li> </ul> </li> </ol>","tags":["sqlite3","django"]},{"location":"blog/2024/04/29/exploring-static-and-dynamic-model-choices-in-django/","title":"Exploring Static and Dynamic Model Choices in Django","text":"","tags":["Programming"]},{"location":"blog/2024/04/29/exploring-static-and-dynamic-model-choices-in-django/#exploring-static-and-dynamic-model-choices-in-django","title":"Exploring Static and Dynamic Model Choices in Django","text":"<p>When developing web applications with Django, one often encounters scenarios where models need to interact with predefined choices or dynamically generated options. Django provides two primary methods to handle these situations: static model choices and dynamic choices models.</p>","tags":["Programming"]},{"location":"blog/2024/04/29/exploring-static-and-dynamic-model-choices-in-django/#1-static-model-choices","title":"1. Static Model Choices:","text":"<p>Static model choices involve predefining a set of options that a model field can accept. This is useful when the range of possible values is known in advance and unlikely to change frequently.</p> <p>For instance, consider a Product model that has a field for its category. Instead of allowing arbitrary strings for the category, you can define a set of choices like \"Electronics,\" \"Clothing,\" and \"Books.\"</p> <pre><code>from django.db import models\n\nclass Product(models.Model):\n  CATEGORY_CHOICES = [\n    ('E', 'Electronics'),\n    ('C', 'Clothing'),\n    ('B', 'Books'),\n  ]\n  name = models.CharField(max_length=100)\n  category = models.CharField(max_length=1, choices=CATEGORY_CHOICES)\n</code></pre> <p>This ensures that only the specified categories can be assigned to a product, maintaining consistency and preventing invalid data entry.</p>","tags":["Programming"]},{"location":"blog/2024/04/29/exploring-static-and-dynamic-model-choices-in-django/#2-dynamic-choices-model","title":"2. Dynamic Choices Model:","text":"<p>In contrast, dynamic choices models involve generating options dynamically based on certain conditions or data in the database. This approach is beneficial when the range of choices is extensive, subject to frequent updates, or depends on user-specific data.</p> <p>For example, consider a <code>City</code> model that stores information about cities and their corresponding countries. Instead of manually defining all possible cities and countries, we can dynamically populate the choices based on the data stored in the database.</p> <pre><code>from django.contrib.auth.models import User\nfrom django.db import models\n\nclass Country(models.Model):\n  name = models.CharField(max_length=100)\n\nclass City(models.Model):\n  name = models.CharField(max_length=100)\n  country = models.ForeignKey(Country, on_delete=models.CASCADE)\n\nclass UserProfile(models.Model):\n  user = models.OneToOneField(User, on_delete=models.CASCADE)\n  favorite_city = models.ForeignKey(City, on_delete=models.SET_NULL, null=True)\n</code></pre> <p>In this example, the <code>favorite_city</code> field of the UserProfile model dynamically fetches cities from the City model, allowing users to select their favorite city from a list that is continuously updated as new cities are added to the database.</p>","tags":["Programming"]},{"location":"blog/2024/04/29/exploring-static-and-dynamic-model-choices-in-django/#conclusion","title":"Conclusion:","text":"<p>Understanding when to use static model choices and dynamic choices models in Django is crucial for building robust and flexible applications. Static choices offer predictability and maintainability, while dynamic choices provide scalability and adaptability to changing data environments. By leveraging these two approaches effectively, developers can create Django applications that meet the specific needs of their projects.</p>","tags":["Programming"]},{"location":"blog/2024/04/25/a-peek-into-str-method-in-django/","title":"A peek into str method in django","text":"","tags":["Django"]},{"location":"blog/2024/04/25/a-peek-into-str-method-in-django/#a-peek-into-str-method-in-django","title":"A peek into str method in django","text":"<p>In Django, <code>__str__</code> is a special method used in Python classes to define how an instance of that class should be represented as a string. It's similar to the toString() method in other programming languages.</p> <p>When you define the <code>__str__</code> method within a model class in Django, you're specifying how instances of that model should be displayed when converted to a string.</p> <p>This is particularly useful for human-readable representations of objects, especially when debugging or displaying data in templates.</p> <p>Example</p> <pre><code>from django.db import models\n\nclass MyModel(models.Model):\n  name = models.CharField(max_length=100)\n  age = models.IntegerField()\n\n  def __str__(self):\n    return f\"{self.name} - {self.age}\"\n</code></pre> <p>In this example, the <code>__str__</code> method is defined to return a string containing the <code>name</code> and <code>age</code> of an instance of <code>MyModel</code>. This allows you to do things like <code>print(instance_of_mymodel)</code> or display the object in Django admin interface in a human-readable format.</p> f-string <p>The f before a string literal in Python, known as an f-string, stands for formatted string. It's a way to create strings that contain embedded Python expressions.</p> <p>Here's how it works:</p> <pre><code>name = \"John\"\nage = 30\nformatted_string = f\"My name is {name} and I am {age} years old.\"\nprint(formatted_string)\n</code></pre> <p>In this example, <code>{name}</code> and <code>{age}</code> are placeholders within the string. When the string is prefixed with <code>f</code>, Python evaluates the expressions within curly braces <code>{}</code> and substitutes them with their values. This makes it easy to create strings with dynamic content without having to concatenate multiple strings or use other formatting methods.</p> <p>F-strings were introduced in Python 3.6 and have become a preferred way to format strings due to their simplicity and readability.</p>","tags":["Django"]},{"location":"blog/2024/04/25/a-peek-into-str-method-in-django/#enhancing-user-experience-with-django-models-a-peek-into-inner-page-representation","title":"Enhancing User Experience with Django Models: A Peek into Inner Page Representation","text":"<p>In this case, it appears you want to implement the <code>__str__</code> method for the <code>AboutInner</code> model to provide a string representation of instances of this model. Since AboutInner instances represent inner pages of the about section, you might want to return something descriptive such as the title or a summary of the content.</p> <p>Here's how you could implement it:</p> Python<pre><code>class AboutInner(models.Model):\n  image = models.ImageField(verbose_name=\"Inner Page Image\", upload_to=\"about/\")\n  content = HTMLField()\n\n  class Meta:\n    db_table = \"ispl_about_inner\"\n    verbose_name = \"About Inner Page\"\n    verbose_name_plural = \"About Inner Pages\"\n\n  def __str__(self):\n    # Return a summary of the content or any other descriptive information\n    return f\"About Inner Page - {self.pk}\"  # Example: Return the primary key\n</code></pre> <p>In this implementation, <code>__str__</code> returns a string containing \"About Inner Page\" followed by the primary key of the instance (<code>self.pk</code>). You could replace <code>self.pk</code> with any other relevant information like a title or summary of the content if applicable. This provides a clear and descriptive representation of each <code>AboutInner</code> instance.</p>","tags":["Django"]},{"location":"blog/2024/04/26/understanding-django-query-methods-objectsall-vs-get_object_or_404/","title":"Understanding Django Query Methods: objects.all() vs get_object_or_404()","text":"","tags":["Django"]},{"location":"blog/2024/04/26/understanding-django-query-methods-objectsall-vs-get_object_or_404/#understanding-django-query-methods-objectsall-vs-get_object_or_404","title":"Understanding Django Query Methods: objects.all() vs get_object_or_404()","text":"<p>In Django development, two commonly used methods for retrieving objects from the database are <code>objects.all()</code> and <code>get_object_or_404()</code>. Although they both deal with database queries, they serve different purposes and are used in different contexts.</p> <ol> <li> <p>objects.all(): Retrieving Multiple Objects</p> <p>When you need to retrieve multiple objects from a database table, <code>objects.all()</code> comes to the rescue. This method returns a queryset containing all objects that match the query criteria. It's particularly useful when you want to fetch a collection of objects to display in a list or iterate over.</p> <p>Tip</p> <pre><code>from myapp.models import MyModel\n\nqueryset = MyModel.objects.all()\n</code></pre> </li> <li> <p>get_object_or_404(): Retrieving a Single Object</p> <p>On the other hand, when you're dealing with situations where you expect to retrieve a single object based on specific conditions, <code>get_object_or_404()</code> is your go-to method. This function retrieves an object based on the provided criteria (such as primary key or unique field value). If the object is not found, it raises a HTTP 404 Not Found error, which is particularly handy for handling cases where a requested object does not exist.</p> <p>Tip</p> <pre><code>from django.shortcuts import get_object_or_404\nfrom myapp.models import MyModel\n\nobj = get_object_or_404(MyModel, pk=1)\n</code></pre> </li> </ol>","tags":["Django"]},{"location":"blog/2024/04/26/understanding-django-query-methods-objectsall-vs-get_object_or_404/#when-to-use-each-method","title":"When to Use Each Method","text":"<ul> <li>objects.all(): Use this method when you need to fetch multiple objects from the database, such as when displaying a list of items.</li> <li>get_object_or_404(): Use this method when you expect to retrieve a single object based on specific criteria and want to handle the case where the object does not exist gracefully by raising a 404 error.</li> </ul>","tags":["Django"]},{"location":"blog/2024/04/26/understanding-django-query-methods-objectsall-vs-get_object_or_404/#conclusion","title":"Conclusion","text":"<p>Understanding the differences between <code>objects.all()</code> and <code>get_object_or_404()</code> allows you to leverage Django's powerful querying capabilities more effectively, ensuring your application retrieves the data it needs efficiently while handling errors gracefully.</p>","tags":["Django"]},{"location":"blog/2024/04/26/understanding-django-query-methods-objectsall-vs-get_object_or_404/#objectsall-vs-get_object_or_404","title":"<code>.objects.all()</code> vs <code>get_object_or_404()</code>","text":"<p>Note</p> <p>In Django, <code>IndustriesItem.objects.all()</code> and <code>get_object_or_404(IndustriesItem)</code> are used to retrieve objects from the database, but they serve different purposes.</p> <ol> <li> <p>IndustriesItem.objects.all():</p> <ul> <li>This retrieves all instances of the <code>IndustriesItem</code> model from the database.</li> <li>It returns a queryset, which is essentially a list of objects that match the query parameters (in this case, all objects).</li> <li>This is useful when you want to retrieve multiple objects and perform operations on them collectively.</li> </ul> </li> <li> <p>get_object_or_404(IndustriesItem):</p> <ul> <li>This is used to retrieve a single object of the <code>IndustriesItem</code> model from the database.</li> <li>If the object does not exist, it raises a 404 HTTP error, which is commonly used for handling \"not found\" errors in web applications.</li> <li>This is useful when you expect to retrieve a single object based on certain criteria, such as a unique identifier.</li> </ul> </li> </ol> <p>So, the main difference lies in the number of objects returned and the behavior when no matching objects are found. <code>IndustriesItem.objects.all()</code> returns multiple objects (all instances), while <code>get_object_or_404(IndustriesItem)</code> returns a single object or raises a 404 error if none is found.</p>","tags":["Django"]},{"location":"blog/2024/07/20/understanding-djangos-serve-view-and-static-function/","title":"Understanding Django\u2019s serve View and static() Function","text":"","tags":["Django","production"]},{"location":"blog/2024/07/20/understanding-djangos-serve-view-and-static-function/#understanding-djangos-serve-view-and-static-function","title":"Understanding Django\u2019s serve View and static() Function","text":"<p>In Django, both the <code>serve</code> view and the <code>static()</code> helper function are related to serving static files, but they serve different purposes and are intended for different environments.</p> <p>Understanding Django\u2019s serve View and static() Function: When and How to Use Each for Serving Static Files</p> <p>Here's a detailed explanation of each and their appropriate use cases:</p>","tags":["Django","production"]},{"location":"blog/2024/07/20/understanding-djangos-serve-view-and-static-function/#1-serve-view","title":"1. serve View","text":"<p>Definition:</p> <ul> <li>The <code>serve</code> view is a Django view provided by <code>django.views.static</code>. It is used to serve static files and media files during development.</li> </ul> <pre><code>from django.urls import re_path\nfrom django.views.static import serve\nfrom django.conf import settings\n\nurlpatterns = [\n    # Your other URL patterns\n]\n\nif settings.DEBUG:\n    urlpatterns += [\n        re_path(r'^static/(?P&lt;path&gt;.*)$', serve, {'document_root': settings.STATIC_ROOT}),\n        re_path(r'^media/(?P&lt;path&gt;.*)$', serve, {'document_root': settings.MEDIA_ROOT}),\n    ]\n</code></pre> <p>Characteristics:</p> <ul> <li>Development Use: Primarily used in development environments where Django\u2019s built-in development server (<code>runserver</code>) is used. It helps to quickly serve static and media files without requiring additional configuration.</li> <li>Not Optimized for Production: It is not designed for production use. It is slower and less efficient compared to dedicated web servers (like Apache or Nginx).</li> <li>Security Considerations: The <code>serve</code> view does not offer advanced security features for serving static files, making it less suitable for production environments.</li> </ul>","tags":["Django","production"]},{"location":"blog/2024/07/20/understanding-djangos-serve-view-and-static-function/#2-static-function","title":"2. static() Function","text":"<p>Definition:</p> <ul> <li>The <code>static()</code> function is a utility provided by <code>django.conf.urls.static</code>. It is used to simplify the URL configuration for serving static files in development.</li> </ul> <pre><code>from django.conf import settings\nfrom django.conf.urls.static import static\nfrom django.contrib import admin\nfrom django.urls import path\n\nurlpatterns = [\n    path('admin/', admin.site.urls),\n    # Other URL patterns\n]\n\nif settings.DEBUG:\n    urlpatterns += static(settings.STATIC_URL, document_root=settings.STATIC_ROOT)\n    urlpatterns += static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)\n</code></pre> <p>Characteristics:</p> <ul> <li>Development Use: The <code>static()</code> function is also intended for development use. It automatically creates URL patterns for serving static and media files, simplifying the <code>urls.py</code> configuration.</li> <li>Convenient for Development: It is a higher-level abstraction that simplifies including static files in development by handling URL routing.</li> </ul>","tags":["Django","production"]},{"location":"blog/2024/07/20/understanding-djangos-serve-view-and-static-function/#differences-and-when-to-use-each","title":"Differences and When to Use Each","text":"<ol> <li> <p>When to Use serve:</p> <ul> <li>Development and Testing: Use <code>serve</code> in development environments when you need to handle static or media file requests directly through Django. It\u2019s a straightforward approach for quick testing.</li> <li>Custom URL Patterns: Use <code>serve</code> if you need custom URL patterns for serving files or require more control over how files are served during development.</li> </ul> </li> <li> <p>When to Use static():</p> <ul> <li>Development and Simplification: Use <code>static()</code> in development environments for a simpler and more concise way to include static file handling in your <code>urls.py</code>. It automatically sets up URL patterns for static and media files.</li> <li>Default Setup: It is often the default choice for most development setups due to its simplicity and integration with Django\u2019s URL configuration.</li> </ul> </li> </ol>","tags":["Django","production"]},{"location":"blog/2024/07/20/understanding-djangos-serve-view-and-static-function/#production-considerations","title":"Production Considerations","text":"In Production <p>Neither <code>serve</code> nor <code>static()</code> is suitable for production environments. For production, you should configure your web server (<code>Apache</code>, <code>Nginx</code>) to handle static files. This ensures better performance, security, and scalability.</p> <ul> <li>Apache/Nginx Configuration: Configure your web server to serve static files by pointing it to the appropriate <code>STATIC_ROOT</code> and <code>MEDIA_ROOT</code> directories.</li> <li>CDN Option: Consider using a Content Delivery Network (CDN) to serve static files for improved performance and reliability.</li> </ul>","tags":["Django","production"]},{"location":"blog/2024/07/20/understanding-djangos-serve-view-and-static-function/#summary","title":"Summary","text":"<ul> <li><code>serve</code>: Use for serving static and media files during development when you need more control over file serving or custom URL patterns.</li> <li><code>static()</code>: Use for a simpler, default setup for serving static and media files in development, automatically handling URL patterns.</li> </ul> <p>Both are intended for development and are not suitable for production. For production environments, configure your web server or use a CDN to serve static files efficiently.</p>","tags":["Django","production"]},{"location":"blog/2024/07/17/understanding-media_root-and-media_url-in-django/","title":"Understanding MEDIA_ROOT and MEDIA_URL in Django","text":"","tags":["Django"]},{"location":"blog/2024/07/17/understanding-media_root-and-media_url-in-django/#understanding-media_root-and-media_url-in-django","title":"Understanding <code>MEDIA_ROOT</code> and <code>MEDIA_URL</code> in Django","text":"<p>Django, a powerful web framework, provides robust handling of user-uploaded files through its <code>MEDIA_ROOT</code> and <code>MEDIA_URL</code> settings. These configurations are essential for managing media files in your application, whether they are images, documents, or any other type of files. Let\u2019s delve into what these settings do, why they are important, and how to use them effectively.</p> Understanding <code>MEDIA_ROOT</code> and <code>MEDIA_URL</code> in Django: A Comprehensive Guide","tags":["Django"]},{"location":"blog/2024/07/17/understanding-media_root-and-media_url-in-django/#what-is-media_root","title":"What is MEDIA_ROOT?","text":"<p>MEDIA_ROOT is a Django setting that defines the absolute filesystem path where uploaded media files are stored. This directory is crucial for managing and organizing files uploaded by users through Django\u2019s models.</p> <ul> <li>Purpose: It specifies the location on the server\u2019s filesystem where uploaded files will be saved.</li> <li>Configuration: You set <code>MEDIA_ROOT</code> in your <code>settings.py</code> file.</li> </ul> <pre><code>import os\n\nMEDIA_ROOT = os.path.join(BASE_DIR, 'media')\n</code></pre> <p>In this example, <code>MEDIA_ROOT</code> is set to a <code>media</code> directory within your project\u2019s base directory. This means that all uploaded files will be stored in a folder named media located at the root of your project.</p>","tags":["Django"]},{"location":"blog/2024/07/17/understanding-media_root-and-media_url-in-django/#what-is-media_url","title":"What is MEDIA_URL?","text":"<p>MEDIA_URL is a Django setting that defines the URL endpoint used to access media files stored in <code>MEDIA_ROOT</code>. This URL is used to reference media files in templates and static files.</p> <ul> <li>Purpose: It provides the web-accessible URL to access the files stored in MEDIA_ROOT.</li> <li>Configuration: You set <code>MEDIA_URL</code> in your <code>settings.py</code> file.</li> </ul> <pre><code>MEDIA_URL = '/media/'\n</code></pre> <p>Here, <code>MEDIA_URL</code> is set to <code>/media/</code>. This means that files stored in <code>MEDIA_ROOT</code> will be accessible at URLs starting with <code>/media/</code>. For instance, a file stored as <code>media/profile_photos/avatar.jpg</code> would be accessible via <code>http://yourdomain.com/media/profile_photos/avatar.jpg</code>.</p>","tags":["Django"]},{"location":"blog/2024/07/17/understanding-media_root-and-media_url-in-django/#how-they-work-together","title":"How They Work Together","text":"<p>When you configure <code>MEDIA_ROOT</code> and <code>MEDIA_URL</code>, Django uses these settings to manage and serve user-uploaded files:</p> <ol> <li> <p>File Upload:</p> <p>When a file is uploaded through a model with an <code>ImageField</code> or <code>FileField</code>, Django saves the file in the directory specified by <code>MEDIA_ROOT</code> combined with the path provided in the <code>upload_to</code> parameter of the model field.</p> <pre><code>from django.db import models\n\nclass Profile(models.Model):\n    user = models.OneToOneField(User, on_delete=models.CASCADE)\n    photo = models.ImageField(upload_to='profile_photos/', blank=True, null=True)\n</code></pre> <p>If <code>MEDIA_ROOT</code> is <code>/home/user/myproject/media/</code>, and a file is uploaded to the <code>photo</code> field, it will be stored at <code>/home/user/myproject/media/profile_photos/filename.ext</code>.</p> </li> <li> <p>Serving Files:</p> <p>During development, Django uses the <code>MEDIA_URL</code> setting to serve these files. You need to configure URL patterns in <code>urls.py</code> to handle media files.</p> <pre><code>from django.conf import settings\nfrom django.conf.urls.static import static\nfrom django.urls import path\n\nurlpatterns = [\n    # Your URL patterns here\n] + static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)\n</code></pre> <p>This configuration tells Django to serve files from <code>MEDIA_ROOT</code> at the <code>MEDIA_URL</code> path.</p> </li> </ol>","tags":["Django"]},{"location":"blog/2024/07/17/understanding-media_root-and-media_url-in-django/#practical-considerations","title":"Practical Considerations","text":"<ol> <li> <p>Permissions:</p> <ul> <li>Ensure that the directory specified by <code>MEDIA_ROOT</code> has the correct permissions to allow Django to write files. This is crucial for file uploads to work correctly.</li> </ul> </li> <li> <p>Production Setup:</p> <ul> <li>In production, it is recommended to use a dedicated web server (e.g., Nginx or Apache) or a cloud storage service (e.g., Amazon S3) to serve media files. Django\u2019s built-in server is not suitable for serving files in a production environment.</li> </ul> </li> <li> <p>Security:</p> <ul> <li>Be cautious with user-uploaded files. Ensure that uploaded files are validated and sanitized to avoid security vulnerabilities, such as serving executable files or files with malicious content.</li> </ul> </li> <li> <p>Testing:</p> <ul> <li>Write tests to ensure that files are uploaded correctly and accessible via the expected URLs. This helps verify that <code>MEDIA_ROOT</code> and <code>MEDIA_URL</code> are configured correctly.</li> </ul> </li> </ol>","tags":["Django"]},{"location":"blog/2024/07/17/understanding-media_root-and-media_url-in-django/#summary","title":"Summary","text":"<ul> <li><code>MEDIA_ROOT</code>: Defines the filesystem path where uploaded files are stored.</li> <li><code>MEDIA_URL</code>: Defines the URL used to access these files on the web.</li> <li>Automatic Directory Creation: Django automatically creates directories in <code>MEDIA_ROOT</code> as needed.</li> <li>Development vs. Production: Use Django\u2019s development server for serving files during development; configure a web server or cloud storage for production.</li> </ul> <p>By understanding and correctly configuring <code>MEDIA_ROOT</code> and <code>MEDIA_URL</code>, you ensure that your Django application can efficiently handle and serve user-uploaded files, providing a seamless experience for users and administrators alike.</p>","tags":["Django"]},{"location":"blog/2024/07/17/understanding-media_root-and-media_url-in-django/#question","title":"Question","text":"<p>Do You Need to Create the MEDIA_ROOT Directory Manually?</p> <p>Ah, I see! You're asking whether you need to manually create the MEDIA_ROOT directory itself\u2014the root directory where all media files will be stored. Here\u2019s the detailed answer:</p>","tags":["Django"]},{"location":"blog/2024/07/17/understanding-media_root-and-media_url-in-django/#do-you-need-to-create-the-media_root-directory-manually","title":"Do You Need to Create the MEDIA_ROOT Directory Manually?","text":"<p>Generally, no, you do not need to manually create the MEDIA_ROOT directory itself before running your Django application. Here\u2019s why and what you should consider:</p> Automatic Directory Management <ol> <li> <p>Django\u2019s Role:</p> <ul> <li>Subdirectories: Django automatically creates subdirectories within <code>MEDIA_ROOT</code> as needed based on the <code>upload_to</code> parameter in your model fields. For example, if you have <code>upload_to='profile_photos/'</code>, Django will create this subdirectory inside <code>MEDIA_ROOT</code> when the first file is uploaded.</li> <li>Root Directory: However, Django does not automatically create the <code>MEDIA_ROOT</code> directory itself. This is because Django expects that you have already set up this directory as part of your application\u2019s configuration.</li> </ul> </li> <li> <p>Initial Setup:</p> <ul> <li>Creating <code>MEDIA_ROOT</code>: You should manually create the <code>MEDIA_ROOT</code> directory (if it does not already exist) to ensure that Django can save uploaded files correctly. This is a one-time setup task. You can create this directory using standard filesystem commands or through your hosting provider's file manager.</li> <li>Permissions: Ensure that the directory has the correct permissions to allow Django to write files. The directory should be writable by the user under which the Django application is running.</li> </ul> </li> </ol> How to Create the MEDIA_ROOT Directory <ol> <li> <p>Manual Creation:</p> <ul> <li> <p>Command Line: You can create the directory manually using command line tools. For example:</p> <pre><code>mkdir /path/to/your/project/media\n</code></pre> </li> <li> <p>File Manager: Alternatively, you can use a file manager provided by your hosting service or server environment to create the directory.</p> </li> </ul> </li> <li> <p>Setting Permissions:</p> <ul> <li> <p>After creating the directory, you may need to set the appropriate permissions to ensure that Django can write to it. For example:</p> <pre><code>chmod 755 /path/to/your/project/media\n</code></pre> </li> <li> <p>Ensure the directory is writable by the user under which Django or your web server runs. This might be something like <code>www-data</code> for many web servers.</p> </li> </ul> </li> </ol> Example Configuration in <code>settings.py</code> <p>Here\u2019s how you would typically configure <code>MEDIA_ROOT</code> and <code>MEDIA_URL</code> in <code>settings.py</code>:</p> <pre><code>import os\n\n# Define the filesystem path for media files\nMEDIA_ROOT = os.path.join(BASE_DIR, 'media')\n\n# Define the URL for accessing media files\nMEDIA_URL = '/media/'\n</code></pre> Summary <ul> <li>Initial Creation: You do need to manually create the <code>MEDIA_ROOT</code> directory itself if it does not already exist. Django does not create this root directory automatically.</li> <li>Permissions: Ensure that <code>MEDIA_ROOT</code> has the correct permissions to allow Django to write and manage files.</li> <li>Automatic Subdirectories: Once <code>MEDIA_ROOT</code> exists, Django will automatically manage and create subdirectories as needed based on the <code>upload_to</code> parameter.</li> </ul> <p>By setting up <code>MEDIA_ROOT</code> correctly and ensuring the right permissions, you\u2019ll enable Django to handle media files seamlessly, allowing your application to manage and serve user-uploaded content efficiently.</p>","tags":["Django"]},{"location":"blog/2024/06/19/phantomjs-headless-browser-is-dead/","title":"PhantomJS Headless Browser is DEAD","text":"","tags":["phantom","headless"]},{"location":"blog/2024/06/19/phantomjs-headless-browser-is-dead/#phantomjs-headless-browser-is-dead","title":"PhantomJS Headless Browser is DEAD","text":"<p>PhantomJS is said to be a headless browser because there is no involvement of browser while executing the JavaScript code. The execution will not be seen in the browser display, but on the command line prompt.</p> <p>the headless WebKit browser.</p>","tags":["phantom","headless"]},{"location":"blog/2024/06/19/phantomjs-headless-browser-is-dead/#reference","title":"Reference","text":"<ul> <li>phantom js</li> <li> <p>PhantomJS - Overview: tutorial point</p> </li> <li> <p>phantomjs_is_dead_use_chrome_headless_in</p> </li> <li>PhantomJS is dead, long live headless browsers</li> </ul>","tags":["phantom","headless"]},{"location":"blog/2024/07/15/using-pipenv-to-manage-development-dependencies/","title":"Using Pipenv to Manage Development Dependencies","text":"","tags":["databse","django","postgresql"]},{"location":"blog/2024/07/15/using-pipenv-to-manage-development-dependencies/#using-pipenv-to-manage-development-dependencies","title":"Using Pipenv to Manage Development Dependencies","text":"<p>Yes, when you run <code>pipenv install</code>, it installs the packages listed under the <code>[packages]</code> section of your <code>Pipfile</code>, but it does not install the <code>[dev-packages]</code> by default.</p>","tags":["databse","django","postgresql"]},{"location":"blog/2024/07/15/using-pipenv-to-manage-development-dependencies/#to-install-both-the-regular-and-development-dependencies","title":"To install both the regular and development dependencies:","text":"<p>To install both the regular and development dependencies (i.e., those listed under <code>[dev-packages]</code>), you need to run:</p> <pre><code>pipenv install --dev\n</code></pre> <p>This command installs both the regular and development dependencies. </p>","tags":["databse","django","postgresql"]},{"location":"blog/2024/07/15/using-pipenv-to-manage-development-dependencies/#if-you-want-to-install-only-the-development-dependencies","title":"If you want to install only the development dependencies:","text":"<p>If you want to install only the development dependencies, you can run:</p> <pre><code>pipenv install --dev-only\n</code></pre> <p>This is useful when you need testing, linting, or other tools that are not required in the production environment.</p>","tags":["databse","django","postgresql"]},{"location":"blog/2024/07/24/what-is-mro-method-resolution-order/","title":"What is MRO (Method Resolution Order)?","text":"","tags":["Python","Javascript"]},{"location":"blog/2024/07/24/what-is-mro-method-resolution-order/#what-is-mro-method-resolution-order","title":"What is MRO (Method Resolution Order)?","text":"<p>Method Resolution Order (MRO) is a mechanism in Python that determines the order in which base classes are looked up when searching for a method. This is particularly important in object-oriented programming, especially when dealing with multiple inheritance.</p>","tags":["Python","Javascript"]},{"location":"blog/2024/07/24/what-is-mro-method-resolution-order/#why-is-mro-important","title":"Why is MRO Important?","text":"<p>When a method is called on an object, Python needs to know which class's method to execute if the method exists in multiple classes due to inheritance. MRO helps Python decide this order systematically.</p>","tags":["Python","Javascript"]},{"location":"blog/2024/07/24/what-is-mro-method-resolution-order/#key-concepts","title":"Key Concepts","text":"","tags":["Python","Javascript"]},{"location":"blog/2024/07/24/what-is-mro-method-resolution-order/#1-single-inheritance","title":"1. Single Inheritance:","text":"<ul> <li>In single inheritance, if you have a class that inherits from another, the MRO is straightforward:</li> </ul> <pre><code>class Parent:\n    def greet(self):\n        return \"Hello from Parent!\"\n\nclass Child(Parent):\n    pass\n\nchild = Child()\nprint(child.greet())  # Calls greet from Parent\n</code></pre>","tags":["Python","Javascript"]},{"location":"blog/2024/07/24/what-is-mro-method-resolution-order/#2-multiple-inheritance","title":"2. Multiple Inheritance:","text":"<ul> <li> <p>With multiple inheritance, MRO becomes more complex. If a class inherits from multiple classes, MRO determines which parent class's method to use.</p> </li> <li> <p>For example:</p> </li> </ul> <pre><code>class A:\n    def method(self):\n        return \"Method from A\"\n\nclass B(A):\n    pass\n\nclass C(A):\n    def method(self):\n        return \"Method from C\"\n\nclass D(B, C):\n    pass\n\nobj = D()\nprint(obj.method())  # Determines which method to use\n</code></pre>","tags":["Python","Javascript"]},{"location":"blog/2024/07/24/what-is-mro-method-resolution-order/#3-using-the-mro-method","title":"3. Using the <code>mro()</code> Method:","text":"<ul> <li>You can view the MRO of a class using the <code>mro()</code> method or the <code>__mro__</code> attribute:</li> </ul> <pre><code>print(D.mro())       # Outputs: [&lt;class '__main__.D'&gt;, &lt;class '__main__.B'&gt;, &lt;class '__main__.C'&gt;, &lt;class '__main__.A'&gt;, &lt;class 'object'&gt;]\nprint(D.__mro__)     # Same as above\n</code></pre>","tags":["Python","Javascript"]},{"location":"blog/2024/07/24/what-is-mro-method-resolution-order/#how-mro-works","title":"How MRO Works","text":"<p>Python uses the C3 linearization algorithm (also known as C3 superclass linearization) to determine the MRO. The key rules of this algorithm are:</p> <ol> <li>The method resolution order must respect the order of the base classes.</li> <li>A class can only come after its parents.</li> <li>If a class appears as a base class in multiple places, it must be listed only once.</li> </ol>","tags":["Python","Javascript"]},{"location":"blog/2024/07/24/what-is-mro-method-resolution-order/#example-walkthrough","title":"Example Walkthrough","text":"<p>Let's analyze the earlier <code>D</code> class example:</p> <pre><code>class A:\n    def method(self):\n        return \"Method from A\"\n\nclass B(A):\n    pass\n\nclass C(A):\n    def method(self):\n        return \"Method from C\"\n\nclass D(B, C):\n    pass\n</code></pre> <ul> <li>MRO for D:</li> <li>Start with <code>D</code>.</li> <li>Check <code>B</code> (first base class).</li> <li>Next, check <code>C</code> (second base class).</li> <li>Finally, check <code>A</code> (the common ancestor).</li> </ul> <p>The MRO will be <code>[D, B, C, A, object]</code>.</p>","tags":["Python","Javascript"]},{"location":"blog/2024/07/24/what-is-mro-method-resolution-order/#conclusion","title":"Conclusion","text":"<p>MRO is crucial in Python for resolving which method to call in a hierarchy of classes, particularly with multiple inheritance. Understanding it helps you design your classes more effectively and avoid common pitfalls associated with method resolution.</p>","tags":["Python","Javascript"]},{"location":"blog/2024/07/24/what-is-mro-method-resolution-order/#additional","title":"Additional","text":"<p>now explain mro to 5 years old</p> <p>Sure! Let's use a simple story to explain MRO.</p> <p>Imagine a Family Tree</p> <p>Imagine you have a family with different members:</p> <ol> <li>Grandma (A)</li> <li>Mom (B), who learned from Grandma.</li> <li>Aunt (C), who also learned from Grandma.</li> <li>You (D), who learned from both Mom and Aunt.</li> </ol> <p>Now, when you want to bake cookies, you might ask one of them for the recipe. But who do you ask first?</p> <p>The Order of Asking</p> <ol> <li>First, you ask your Mom (B) because she\u2019s closest to you.</li> <li>If she doesn\u2019t know, you then ask your Aunt (C).</li> <li>Finally, if neither of them knows, you ask Grandma (A).</li> </ol> <p>The Rule of Asking</p> <p>This order of asking is like MRO (Method Resolution Order)! It tells you who to ask first when you want to find something out.</p> <p>So, in our family:</p> <ul> <li>You always check with Mom first,</li> <li>Then Aunt,</li> <li>And then Grandma.</li> </ul> <p>Summary</p> <p>MRO helps decide the order to ask for help in a family, just like how Python decides which method to use in a group of classes.</p>","tags":["Python","Javascript"]},{"location":"blog/2024/07/18/why-django-serves-static-files-differently-in-development-and-production/","title":"Why Django Serves Static Files Differently in Development and Production","text":"","tags":["Django","production"]},{"location":"blog/2024/07/18/why-django-serves-static-files-differently-in-development-and-production/#why-django-serves-static-files-differently-in-development-and-production","title":"Why Django Serves Static Files Differently in <code>Development</code> and <code>Production</code>","text":"<p>Django handles static files differently in development and production environments primarily due to performance, security, and architectural reasons.</p>","tags":["Django","production"]},{"location":"blog/2024/07/18/why-django-serves-static-files-differently-in-development-and-production/#overview","title":"Overview","text":"<p>Here\u2019s a detailed explanation of why Django serves static files in development but not in production:</p>","tags":["Django","production"]},{"location":"blog/2024/07/18/why-django-serves-static-files-differently-in-development-and-production/#development-environment","title":"Development Environment","text":"Why Django Serves Static Files in Development: <ul> <li> <p>Convenience: During development, having Django serve static files directly simplifies the setup. Developers can see changes to static files (like CSS, JavaScript, or images) immediately without needing to configure an additional static file server.</p> </li> <li> <p>Simplicity: It reduces the complexity of the development environment. Developers typically run Django\u2019s built-in development server (<code>runserver</code>), which includes basic handling for static files. This built-in server is not intended for production use but is adequate for development purposes.</p> </li> <li> <p>Automatic Handling: Django automatically serves static files from locations specified in the <code>STATICFILES_DIRS</code> and <code>STATIC_ROOT</code> settings. This means you don\u2019t need to set up a separate server or configure additional settings to serve static files during development.</p> </li> </ul>","tags":["Django","production"]},{"location":"blog/2024/07/18/why-django-serves-static-files-differently-in-development-and-production/#production-environment","title":"Production Environment","text":"Why Django Does Not Serve Static Files in Production: <ul> <li> <p>Performance: Serving static files directly from Django is not optimized for high performance. Django\u2019s built-in server is designed for development and is not suitable for handling high volumes of traffic or efficiently serving static files. In production, a dedicated web server (like Nginx or Apache) or a CDN is used, which is optimized for serving static files quickly and efficiently.</p> </li> <li> <p>Resource Management: Serving static files through Django adds unnecessary load on the application server. The web server (or CDN) is better suited to handle static file requests, allowing the application server to focus on processing dynamic requests (e.g., database queries, business logic).</p> </li> <li> <p>Scalability: In a production environment, scalability is a concern. Web servers like Nginx or Apache can handle a large number of concurrent requests for static files more efficiently than Django\u2019s development server. CDNs further enhance scalability by distributing static files across multiple servers globally.</p> </li> <li> <p>Security: By using a dedicated static file server or CDN, you can implement more granular control over security and access. For example, you can set up caching rules, apply security headers, and handle HTTPS more efficiently.</p> </li> </ul> Abstract <ul> <li>CDN (e.g., AWS CloudFront): Best for high performance, scalability, and global reach. Requires setup on CDN provider and may need DNS configuration.</li> <li>Dedicated Web Server (e.g., Nginx): Great for performance and flexibility, but requires server configuration.</li> <li>Cloud Storage with Static Hosting (e.g., Google Cloud Storage): Ideal for scalable and cost-effective file management.</li> <li>Application Server (e.g., Gunicorn): Simple setup but less optimal for high traffic. Use this for development or small-scale deployments.</li> <li>Reverse Proxy Configuration (e.g., Nginx): Useful for integrating with multiple services and advanced routing.</li> </ul>","tags":["Django","production"]},{"location":"blog/2024/07/18/why-django-serves-static-files-differently-in-development-and-production/#summary","title":"Summary","text":"<ul> <li> <p>Development: Django serves static files directly because it simplifies the setup and allows developers to see changes immediately without additional configuration. This setup is adequate for the relatively low traffic and simple requirements of development.</p> </li> <li> <p>Production: Django does not serve static files because a dedicated static file server or CDN provides better performance, scalability, and security. Handling static files separately from application logic ensures that the application server is free to focus on dynamic content and business logic.</p> </li> </ul> <p>In practice, for production, you\u2019ll use Django to collect static files into a single directory (specified by <code>STATIC_ROOT</code>) using the <code>collectstatic</code> command, and then configure a web server or CDN to serve these files efficiently. This separation of concerns helps in building a more robust and scalable application.</p>","tags":["Django","production"]},{"location":"blog/2024/07/18/why-django-serves-static-files-differently-in-development-and-production/#question","title":"Question","text":"<p>does other frarmework like laravel also donot serve the static file in the production or it serve.</p>","tags":["Django","production"]},{"location":"blog/2024/07/18/why-django-serves-static-files-differently-in-development-and-production/#intro","title":"Intro","text":"<p>In production, frameworks like <code>Laravel</code> handle static files in a manner similar to Django, where direct serving of static files by the framework itself is not the recommended approach. Instead, Laravel, like Django, relies on other tools or server configurations to efficiently handle static files. Here\u2019s how Laravel deals with static files in different environments:</p> <p>Laravel Static File Handling in Production</p> <ol> <li> <p>Use of Dedicated Web Server</p> <p>Description: Laravel recommends using a dedicated web server (like Nginx or Apache) to serve static files efficiently in production.</p> How It Works: <p>Configuration: You configure the web server to serve static files from the public directory, where Laravel places assets like CSS, JavaScript, and images.</p> <pre><code>server {\n    listen 80;\n    server_name yourdomain.com;\n\n    root /path/to/your/laravel/public;\n\n    location / {\n        try_files $uri $uri/ /index.php?$query_string;\n    }\n\n    location ~ \\.php$ {\n        include snippets/fastcgi-php.conf;\n        fastcgi_pass unix:/var/run/php/php7.4-fpm.sock;\n        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;\n        include fastcgi_params;\n    }\n\n    location /static/ {\n        alias /path/to/your/staticfiles/;\n    }\n}\n</code></pre> <p>In this configuration, <code>location /static/</code> can be used to serve static assets if they are stored separately from Laravel\u2019s <code>public</code> directory.</p> Advantages: <ul> <li>Performance: Web servers like Nginx or Apache are optimized to serve static files quickly.</li> <li>Scalability: They can handle high traffic and large volumes of requests efficiently.</li> <li>Caching: Web servers can be configured with caching rules to improve performance.</li> </ul> </li> <li> <p>Content Delivery Network (CDN)</p> </li> <li> <p>Cloud Storage with Static Hosting</p> </li> <li> <p>Application Server (<code>Built-In Handling</code>)</p> <p>Description: Laravel\u2019s <code>built-in</code> server (<code>php artisan serve</code>) is not intended for production use. It can serve static files during development but is not optimized for high traffic.</p> </li> </ol>","tags":["Django","production"]},{"location":"blog/2024/07/18/why-django-serves-static-files-differently-in-development-and-production/#summary-of-static-file-handling-in-laravel","title":"Summary of Static File Handling in Laravel","text":"<ul> <li>Dedicated Web Server (e.g., Nginx, Apache): Best for performance and scalability; handles static files efficiently.</li> <li>Content Delivery Network (CDN): Excellent for global reach and high traffic; provides caching and performance benefits.</li> <li>Cloud Storage with Static Hosting (e.g., AWS S3, Google Cloud Storage): Ideal for scalable and cost-effective static file management.</li> <li>Application Server (e.g., php artisan serve): Suitable for development but not recommended for production.</li> </ul> <p>Just like Django, Laravel does not directly serve static files in production but relies on external systems or configurations to handle this efficiently. This approach allows both frameworks to focus on application logic and dynamic content while leveraging other tools to manage static files.</p>","tags":["Django","production"]},{"location":"package/django-allauth/","title":"django-allauth","text":""},{"location":"package/django-allauth/#django-allauth","title":"django-allauth","text":"<p>The <code>django-allauth</code> package is a comprehensive authentication framework for Django, which provides out-of-the-box support for user authentication, registration, account management, and social authentication. Here's a detailed overview:</p>"},{"location":"package/django-allauth/#what-is-django-allauth","title":"What is django-allauth?","text":"<p>django-allauth is a third-party Django package designed to handle all aspects of user authentication and account management. It simplifies the process of implementing features like user registration, email verification, password reset, and social login.</p> Example Configuration <ul> <li> <p>Step 1:   Install django-allauth</p> <pre><code>pip install django-allauth\n</code></pre> </li> <li> <p>Step 2: Add to INSTALLED_APPS</p> <pre><code>INSTALLED_APPS = [\n    ...\n    'django.contrib.sites',\n    'allauth',\n    'allauth.account',\n    'allauth.socialaccount',\n    'allauth.socialaccount.providers.google',  # Example for Google social login\n    ...\n]\n\nSITE_ID = 1\n</code></pre> </li> <li> <p>Step 3: Add Authentication Backends</p> <pre><code>AUTHENTICATION_BACKENDS = (\n    'django.contrib.auth.backends.ModelBackend',\n    'allauth.account.auth_backends.AuthenticationBackend',\n)\n</code></pre> </li> <li> <p>Step 4: Add allauth URLs</p> <pre><code>from django.urls import path, include\n\nurlpatterns = [\n    ...\n    path('accounts/', include('allauth.urls')),\n    ...\n]\n</code></pre> </li> <li> <p>Step 5: Configure Settings</p> <p>Add relevant settings to settings.py:</p> <pre><code>ACCOUNT_EMAIL_REQUIRED = True\nACCOUNT_EMAIL_VERIFICATION = 'mandatory'\nACCOUNT_AUTHENTICATION_METHOD = 'email'\n\n# Email backend configuration\nEMAIL_BACKEND = 'django.core.mail.backends.smtp.EmailBackend'\nEMAIL_HOST = 'smtp.your-email-provider.com'\nEMAIL_PORT = 587\nEMAIL_USE_TLS = True\nEMAIL_HOST_USER = 'your-email@example.com'\nEMAIL_HOST_PASSWORD = 'your-email-password'\nDEFAULT_FROM_EMAIL = 'your-email@example.com'\n\n# Social account provider configuration (example for Google)\nSOCIALACCOUNT_PROVIDERS = {\n    'google': {\n        'SCOPE': ['profile', 'email'],\n        'AUTH_PARAMS': {'access_type': 'online'},\n    }\n}\n</code></pre> </li> </ul>"},{"location":"package/django-allauth/#summary","title":"Summary","text":"<p>django-allauth is a powerful and versatile package that simplifies the implementation of user authentication, registration, and social login in Django applications. Use it when you need a comprehensive solution for managing user accounts and integrating with third-party authentication providers.</p> Abstract <p>There are two scenarios where you might encounter URL patterns for authentication and user management in Django:</p> <ol> <li> <p>Using Django's Built-in Authentication Views:</p> <p>Django provides some built-in views for user authentication, such as <code>login</code> and <code>logout</code>. These views can be included in your project without needing to create a custom accounts app.</p> </li> <li> <p>Using Third-Party Packages like django-allauth:</p> <p>Packages like <code>django-allauth</code> provide a comprehensive set of URL patterns for user account management, which you include in your project's URLs.</p> </li> </ol>"},{"location":"package/django-allauth/#using-djangos-built-in-authentication-views","title":"Using Django's Built-in Authentication Views","text":"<p>Django's <code>django.contrib.auth</code> module provides several built-in views for handling authentication, such as <code>login</code>, <code>logout</code>, and <code>password management</code>. Here's how to use them:</p>"},{"location":"package/django-allauth/#step-1-include-built-in-auth-urls","title":"Step 1: Include Built-in Auth URLs","text":"<p>In your project's <code>urls.py</code>, you can include Django's built-in authentication URLs:</p> <pre><code>from django.urls import path, include\n\nurlpatterns = [\n    ...\n    path('accounts/', include('django.contrib.auth.urls')),\n    ...\n]\n</code></pre> <p>or</p> <pre><code>from django.urls import path, include\nfrom django.contrib.auth import views as auth_views\n\nurlpatterns = [\n    ...\n    path('accounts/login/', auth_views.LoginView.as_view(), name='login'),\n    path('accounts/logout/', auth_views.LogoutView.as_view(), name='logout'),\n    path('accounts/password_change/', auth_views.PasswordChangeView.as_view(), name='password_change'),\n    path('accounts/password_change/done/', auth_views.PasswordChangeDoneView.as_view(), name='password_change_done'),\n    path('accounts/password_reset/', auth_views.PasswordResetView.as_view(), name='password_reset'),\n    path('accounts/password_reset/done/', auth_views.PasswordResetDoneView.as_view(), name='password_reset_done'),\n    path('accounts/reset/&lt;uidb64&gt;/&lt;token&gt;/', auth_views.PasswordResetConfirmView.as_view(), name='password_reset_confirm'),\n    path('accounts/reset/done/', auth_views.PasswordResetCompleteView.as_view(), name='password_reset_complete'),\n]\n</code></pre>"},{"location":"package/django-allauth/#step-2-create-templates","title":"Step 2: Create Templates","text":"<p>Django expects certain templates to be available for these views. You should create templates in your <code>templates/registration/</code> directory:</p> <pre><code>login.html\nlogout.html (optional)\npassword_change_form.html\npassword_change_done.html\npassword_reset_form.html\npassword_reset_done.html\npassword_reset_confirm.html\npassword_reset_complete.html\n</code></pre> <p>Here is an example for <code>login.html</code>:</p> templates/registration/login.html<pre><code>&lt;!-- templates/registration/login.html --&gt;\n&lt;h2&gt;Login&lt;/h2&gt;\n&lt;form method=\"post\"&gt;\n    {% csrf_token %}\n    {{ form.as_p }}\n    &lt;button type=\"submit\"&gt;Login&lt;/button&gt;\n&lt;/form&gt;\n</code></pre>"},{"location":"package/django-allauth/#using-django-allauth","title":"Using django-allauth","text":"<p>If you are using <code>django-allauth</code>, you include its URL patterns to handle all aspects of user authentication and account management.</p>"},{"location":"package/django-allauth/#step-1-include-allauth-urls","title":"Step 1: Include allauth URLs","text":"<p>In your project's <code>urls.py</code>, include allauth URLs:</p> <pre><code>from django.urls import path, include\n\nurlpatterns = [\n    ...\n    path('accounts/', include('allauth.urls')),  # Includes allauth's built-in URLs\n    ...\n]\n</code></pre>"},{"location":"package/django-allauth/#summary_1","title":"Summary","text":"<ul> <li>Django's Built-in Authentication Views: You can include them directly using <code>django.contrib.auth.views</code> in your <code>urls.py</code>. You need to provide the corresponding templates for these views.</li> <li>Third-Party Packages (django-allauth): You can include allauth URLs in your <code>urls.py</code> to leverage its comprehensive authentication and account management features.</li> </ul> <p>Neither of these approaches involves a built-in accounts.urls provided by Django itself. Instead, you include and configure the necessary URL patterns and views according to your project's requirements.</p>"},{"location":"package/django-allauth/#reference","title":"Reference","text":"<ul> <li>django-allauth</li> <li>django built-in auth</li> </ul>"},{"location":"package/django-ratelimit/","title":"django-ratelimit","text":"<p>Django Ratelimit provides a decorator to rate-limit views. Limiting can be based on IP address or a field in the request\u2013either a <code>GET</code> or <code>POST</code> variable.</p> <pre><code>pip install django-ratelimit\n</code></pre>"},{"location":"package/django-ratelimit/#reference","title":"Reference","text":"<ul> <li>django-ratelimit.readthedocs.io</li> <li>django-ratelimit pypi</li> </ul>"},{"location":"package/djangorestframework-api-key/","title":"djangorestframework-api-key","text":""},{"location":"package/djangorestframework-api-key/#introduction","title":"Introduction","text":"<p>Django REST Framework API Key is a powerful library for allowing server-side clients to safely use your API. These clients are typically third-party backends and services (i.e. machines) which do not have a user account but still need to interact with your API in a secure way.</p>"},{"location":"package/djangorestframework-api-key/#quickstart","title":"Quickstart","text":"<p>Install with <code>pip</code>:</p> <pre><code>pip install \"djangorestframework-api-key==2.*\"\n</code></pre> Important <p>It is highly recommended to pin your dependency to the latest major version (as depicted above), as breaking changes may and will happen between major releases.</p> <p>Add the app to your <code>INSTALLED_APPS</code>:</p> <pre><code># settings.py\n\nINSTALLED_APPS = [\n  # ...\n  \"rest_framework\",\n  \"rest_framework_api_key\",\n]\n</code></pre> <p>Run the included migrations:</p> <pre><code>python manage.py migrate\n</code></pre> <p>To learn how to configure permissions and manage API keys, head to the User Guide.</p>"},{"location":"package/djangorestframework-api-key/#setting-permissions","title":"Setting permissions","text":"<p>The <code>HasAPIKey</code> permission class protects a view behind API key authorization.</p> <p>You can set the permission globally:</p> <pre><code># settings.py\nREST_FRAMEWORK = {\n    \"DEFAULT_PERMISSION_CLASSES\": [\n        \"rest_framework_api_key.permissions.HasAPIKey\",\n    ]\n}\n</code></pre> <p>or on a per-view basis:</p> <pre><code># views.py\nfrom rest_framework.views import APIView\nfrom rest_framework_api_key.permissions import HasAPIKey\n\nclass UserListView(APIView):\n    permission_classes = [HasAPIKey]\n    # ...\n</code></pre> <p>See also Setting the permission policy for more information on using permission classes in the Django REST Framework.</p> Tip <p>You can use the bitwise operators <code>|</code> and <code>&amp;</code> to compose <code>HasAPIKey</code> with other permission classes and achieve more complex authorization behaviour.</p> <p>For example, to require a valid API key or authentication credentials, use:</p> <pre><code>from rest_framework.permissions import IsAuthenticated\nfrom rest_framework_api_key.permissions import HasAPIKey\n# ...\npermission_classes = [HasAPIKey | IsAuthenticated]\n</code></pre>"},{"location":"package/djangorestframework-api-key/#making-authorized-requests","title":"Making authorized requests","text":""},{"location":"package/djangorestframework-api-key/#authorization-header","title":"Authorization header","text":"<p>By default, clients must pass their API key via the <code>Authorization</code> header. It must be formatted as follows:</p> <pre><code>Authorization: Api-Key &lt;API_KEY&gt;\n</code></pre> <p>where <code>&lt;API_KEY&gt;</code> refers to the full generated API key (see Creating and managing API keys below).</p> <p>To know under which conditions access is granted, please see Grant scheme.</p> <p>If wanting to also customize the keyword used for parsing the Api-Key, please see API key Custom Keyword</p>"},{"location":"package/djangorestframework-api-key/#custom-header","title":"Custom header","text":"<p>You can set the <code>API_KEY_CUSTOM_HEADER</code> setting to a non-<code>None</code> value to require clients to pass their API key in a custom header instead of the <code>Authorization</code> header.</p> <p>This is useful if you plan to use API keys AND an authentication scheme which already uses the <code>Authorization</code> header (e.g. token-based authentication).</p> <p>For example, if you set:</p> <pre><code># settings.py\nAPI_KEY_CUSTOM_HEADER = \"HTTP_X_API_KEY\"\n</code></pre> <p>then clients must make authorized requests using:</p> <pre><code>X-Api-Key: &lt;API_KEY&gt;\n</code></pre> <p>where <code>&lt;API_KEY&gt;</code> refers to the full generated API key.</p> <p>Please refer to HttpRequest.META for more information on headers in Django.</p>"},{"location":"package/djangorestframework-api-key/#creating-and-managing-api-keys","title":"Creating and managing API keys","text":""},{"location":"package/djangorestframework-api-key/#admin-site","title":"Admin site","text":"<p>When it is installed, <code>djangorestframework-api-key</code> adds an \"API Key Permissions\" section to the Django admin site where you can create, view and revoke API keys.</p> Note <p>Upon creating an API key from the admin, the full API key is shown only once in a success message banner. This is what should be passed in authorization headers. After creation, only the prefix of the API key is shown in the admin site, mostly for identification purposes. If you lose the full API key, you'll need to regenerate a new one.</p>"},{"location":"package/djangorestframework-api-key/#programmatic-usage","title":"Programmatic usage","text":"<p>API keys can be created, viewed and revoked programmatically by manipulating the <code>APIKey</code> model.</p> Note <p>The examples below use the Django shell.</p> <ul> <li>You can view and query <code>APIKey</code> like any other model. For example, to know the total number of API keys:</li> </ul> <pre><code>&gt;&gt;&gt; from rest_framework_api_key.models import APIKey\n&gt;&gt;&gt; APIKey.objects.count()\n42\n</code></pre> <ul> <li>If you wish to create an API key programmatically, you'll most likely want a one-time access to its generated key too. To do so, use the <code>.create_key()</code> method on the <code>APIKey</code> objects manager instead of <code>.create()</code>:</li> </ul> <pre><code>&gt;&gt;&gt; from rest_framework_api_key.models import APIKey\n&gt;&gt;&gt; api_key, key = APIKey.objects.create_key(name=\"my-remote-service\")\n&gt;&gt;&gt; # Proceed with `api_key` and `key`...\n</code></pre> Danger <p>To prevent leaking API keys, you must only give the <code>key</code> to the client that triggered its generation. In particular, do not keep any trace of it on the server.</p> <ul> <li>To retrieve an <code>APIKey</code> instance based on its generated key (which is not stored in the database) use the <code>.get_from_key()</code> method on the <code>APIKey</code> objects manager instead of <code>.get()</code>. This is useful if you'd like to access an <code>APIKey</code> object from a view protected by a <code>HasAPIKey</code> permission.</li> </ul> <pre><code>from rest_framework.views import APIView\nfrom rest_framework_api_key.models import APIKey\nfrom rest_framework_api_key.permissions import HasAPIKey\n\nfrom .models import Project\n\nclass ProjectListView(APIView):\n    permission_classes = [HasAPIKey]\n\n    def get(self, request):\n        \"\"\"Retrieve a project based on the request API key.\"\"\"\n        key = request.META[\"HTTP_AUTHORIZATION\"].split()[1]\n        api_key = APIKey.objects.get_from_key(key)\n        project = Project.objects.get(api_key=api_key)\n</code></pre>"},{"location":"package/djangorestframework-api-key/#test-your-api","title":"Test Your API","text":""},{"location":"package/djangorestframework-api-key/#normal-authorization","title":"Normal <code>Authorization</code>","text":"<p>To test the API key authentication:</p> <ul> <li>Include the API key in the <code>Authorization</code> header of your request:</li> </ul> <pre><code>Authorization: Api-Key &lt;your-api-key&gt;\n</code></pre> <ul> <li>Make sure to handle invalid or missing API keys appropriately.</li> </ul> <p></p>"},{"location":"package/djangorestframework-api-key/#using-api_key_custom_header","title":"Using <code>API_KEY_CUSTOM_HEADER</code>","text":"<pre><code># settings.py\nAPI_KEY_CUSTOM_HEADER = \"HTTP_X_API_KEY\"\n</code></pre>"},{"location":"package/djoser/","title":"djoser","text":""},{"location":"package/djoser/#djoser","title":"djoser","text":"<p>REST implementation of Django authentication system. djoser library provides a set of Django Rest Framework views to handle basic actions such as registration, login, logout, password reset and account activation. It works with <code>custom user model</code>.</p>"},{"location":"package/djoser/#reference","title":"Reference","text":"<ul> <li>djoser</li> </ul>"},{"location":"package/drf-rest-auth/","title":"drf-rest-auth","text":""},{"location":"package/drf-rest-auth/#drf-rest-auth","title":"drf-rest-auth","text":"Bug <pre><code># django-rest-auth (deprecate)\nREST_USE_JWT = True  # Enable JWT if needed\n</code></pre> Success <pre><code># dj-rest-auth\nREST_AUTH = {\n    ...\n    'USE_JWT': True,\n}\n</code></pre> dj_rest_auth (jwt) refresh token is empty when login <pre><code>REST_AUTH = {\n    ...\n    'JWT_AUTH_HTTPONLY':False\n} \n</code></pre> settings.py <pre><code>ACCOUNT_AUTHENTICATION_METHOD = 'EMAIL'\n# ACCOUNT_AUTHENTICATION_METHOD = 'email'\n# ACCOUNT_AUTHENTICATION_METHOD = 'username'\n</code></pre>"},{"location":"package/drf-rest-auth/#importing-views","title":"Importing views","text":"Note import viewsshow urlsCombine <pre><code>from dj_rest_auth.views import (\n    LoginView,\n    LogoutView,\n    PasswordChangeView,\n    PasswordResetView,\n    PasswordResetConfirmView,\n    UserDetailsView,\n    TokenVerifyView,\n    TokenRefreshView,\n)\n\nfrom dj_rest_auth.registration.views import (\n    RegisterView,\n    VerifyEmailView,\n    ResendEmailVerificationView,\n)\n</code></pre> <pre><code>from django.urls import path, include\n\nurlpatterns = [\n    path('dj-rest-auth/login/', LoginView.as_view(), name='login'),\n    path('dj-rest-auth/logout/', LogoutView.as_view(), name='logout'),\n    path('dj-rest-auth/password/change/', PasswordChangeView.as_view(), name='password_change'),\n    path('dj-rest-auth/password/reset/', PasswordResetView.as_view(), name='password_reset'),\n    path('dj-rest-auth/password/reset/confirm/', PasswordResetConfirmView.as_view(), name='password_reset_confirm'),\n    path('dj-rest-auth/user/', UserDetailsView.as_view(), name='user_details'),\n    path('dj-rest-auth/token/verify/', TokenVerifyView.as_view(), name='token_verify'),\n    path('dj-rest-auth/token/refresh/', TokenRefreshView.as_view(), name='token_refresh'),\n\n    path('dj-rest-auth/registration/', RegisterView.as_view(), name='register'),\n    path('dj-rest-auth/registration/verify-email/', VerifyEmailView.as_view(), name='verify_email'),\n    path('dj-rest-auth/registration/resend-email/', ResendEmailVerificationView.as_view(), name='resend_email'),\n]\n</code></pre> <pre><code>from django.contrib import admin\nfrom django.urls import path, include\nfrom dj_rest_auth.views import (\n    LoginView,\n    LogoutView,\n    PasswordChangeView,\n    PasswordResetView,\n    PasswordResetConfirmView,\n    UserDetailsView,\n    TokenVerifyView,\n    TokenRefreshView,\n)\nfrom dj_rest_auth.registration.views import (\n    RegisterView,\n    VerifyEmailView,\n    ResendEmailVerificationView,\n)\n\nurlpatterns = [\n    path('admin/', admin.site.urls),\n    path('dj-rest-auth/login/', LoginView.as_view(), name='login'),\n    path('dj-rest-auth/logout/', LogoutView.as_view(), name='logout'),\n    path('dj-rest-auth/password/change/', PasswordChangeView.as_view(), name='password_change'),\n    path('dj-rest-auth/password/reset/', PasswordResetView.as_view(), name='password_reset'),\n    path('dj-rest-auth/password/reset/confirm/', PasswordResetConfirmView.as_view(), name='password_reset_confirm'),\n    path('dj-rest-auth/user/', UserDetailsView.as_view(), name='user_details'),\n    path('dj-rest-auth/token/verify/', TokenVerifyView.as_view(), name='token_verify'),\n    path('dj-rest-auth/token/refresh/', TokenRefreshView.as_view(), name='token_refresh'),\n\n    path('dj-rest-auth/registration/', RegisterView.as_view(), name='register'),\n    path('dj-rest-auth/registration/verify-email/', VerifyEmailView.as_view(), name='verify_email'),\n    path('dj-rest-auth/registration/resend-email/', ResendEmailVerificationView.as_view(), name='resend_email'),\n]\n</code></pre>"},{"location":"package/drf-rest-auth/#using-dj-rest-auth-standalone","title":"Using <code>dj-rest-auth</code> standalone","text":"<p>No, you do not necessarily need to use <code>django-allauth</code> to use <code>dj-rest-auth</code>. However, <code>dj-rest-auth</code> can integrate with <code>django-allauth</code> to provide additional features, especially for user registration and social authentication. If you only need basic authentication (<code>login</code>, <code>logout</code>, <code>password reset</code>, etc.), you can use <code>dj-rest-auth</code> without <code>django-allauth</code>.</p> <p>Here are the steps to use <code>dj-rest-auth</code> without <code>django-allauth</code>:</p>"},{"location":"package/drf-rest-auth/#step-1-install-required-packages","title":"Step 1: Install Required Packages","text":"<p>First, install dj-rest-auth and its dependencies:</p> <pre><code>pip install dj-rest-auth\n</code></pre>"},{"location":"package/drf-rest-auth/#step-2-add-to-installed-apps","title":"Step 2: Add to Installed Apps","text":"<p>Add the required applications to your INSTALLED_APPS in <code>settings.py</code>:</p> <pre><code>INSTALLED_APPS = [\n    ...\n    'dj_rest_auth',\n    'rest_framework',\n    ...\n]\n</code></pre>"},{"location":"package/drf-rest-auth/#step-3-configure-rest-framework","title":"Step 3: Configure REST Framework","text":"<p>Add <code>rest_framework</code> settings in <code>settings.py</code>:</p> <pre><code>REST_FRAMEWORK = {\n    'DEFAULT_AUTHENTICATION_CLASSES': (\n        'rest_framework.authentication.SessionAuthentication',\n        'rest_framework.authentication.TokenAuthentication',\n    ),\n}\n</code></pre>"},{"location":"package/drf-rest-auth/#step-4-update-urls","title":"Step 4: Update URLs","text":"<p>Add the <code>dj-rest-auth</code> URLs to your <code>urls.py</code>:</p> <pre><code>from django.urls import path, include\n\nurlpatterns = [\n    ...\n    path('api/auth/', include('dj_rest_auth.urls')),\n    ...\n]\n</code></pre>"},{"location":"package/drf-rest-auth/#step-5-run-migrations","title":"Step 5: Run Migrations","text":"<p>Run the following commands to apply migrations:</p> <pre><code>python manage.py makemigrations\npython manage.py migrate\n</code></pre>"},{"location":"package/drf-rest-auth/#step-6-test-the-endpoints","title":"Step 6: Test the Endpoints","text":"<p>Now you can test the authentication endpoints provided by dj-rest-auth such as:</p> <pre><code>/api/auth/login/\n/api/auth/logout/\n/api/auth/password/reset/\n/api/auth/password/change/\n</code></pre>"},{"location":"package/drf-rest-auth/#optional-using-jwt","title":"Optional: Using JWT","text":"<p>If you want to use JWT for authentication, you need to install <code>djangorestframework-simplejwt</code> and configure it:</p> <pre><code>pip install djangorestframework-simplejwt\n</code></pre> <p>Update <code>settings.py</code>:</p> <pre><code>INSTALLED_APPS = [\n    ...\n    'rest_framework_simplejwt.token_blacklist',\n    ...\n]\n\nREST_FRAMEWORK = {\n    'DEFAULT_AUTHENTICATION_CLASSES': (\n        'rest_framework_simplejwt.authentication.JWTAuthentication',\n        'rest_framework.authentication.SessionAuthentication',\n    ),\n}\n\n# Add the following settings if you want to configure JWT behavior\nfrom datetime import timedelta\n\nSIMPLE_JWT = {\n    'ACCESS_TOKEN_LIFETIME': timedelta(minutes=5),\n    'REFRESH_TOKEN_LIFETIME': timedelta(days=1),\n    'ROTATE_REFRESH_TOKENS': True,\n    'BLACKLIST_AFTER_ROTATION': True,\n    'ALGORITHM': 'HS256',\n    'SIGNING_KEY': SECRET_KEY,\n    'VERIFYING_KEY': None,\n    'AUTH_HEADER_TYPES': ('Bearer',),\n    'USER_ID_FIELD': 'id',\n    'USER_ID_CLAIM': 'user_id',\n    'AUTH_TOKEN_CLASSES': ('rest_framework_simplejwt.tokens.AccessToken',),\n    'TOKEN_TYPE_CLAIM': 'token_type',\n    'JTI_CLAIM': 'jti',\n}\n</code></pre> <p>Add JWT URLs to <code>urls.py</code>:</p> <pre><code>from rest_framework_simplejwt.views import (\n    TokenObtainPairView,\n    TokenRefreshView,\n    TokenVerifyView,\n)\n\nurlpatterns = [\n    ...\n    path('api/auth/jwt/create/', TokenObtainPairView.as_view(), name='token_obtain_pair'),\n    path('api/auth/jwt/refresh/', TokenRefreshView.as_view(), name='token_refresh'),\n    path('api/auth/jwt/verify/', TokenVerifyView.as_view(), name='token_verify'),\n    ...\n]\n</code></pre> <p>With these steps, you can use <code>dj-rest-auth</code> for basic authentication features without needing django-allauth. If you require advanced user registration, social login, and other features, consider integrating django-allauth into your project.</p>"},{"location":"package/drf-rest-auth/#customize-loginview-in-dj-rest-auth","title":"Customize LoginView in dj-rest-auth","text":"<p>Customize LoginView in dj-rest-auth</p> views.pyurls.py <p>Create a new file <code>views.py</code> in your app and add the following:</p> <pre><code>from dj_rest_auth.views import LoginView\n\nclass CustomLoginView(LoginView):\n    # Customize the login view\n    def get_response(self):\n        # Custom response logic\n        pass\n</code></pre> <pre><code>from dj_rest_auth.views import LoginView\nfrom rest_framework.response import Response\nfrom rest_framework import status\nfrom rest_framework_simplejwt.tokens import RefreshToken\n\nclass CustomLoginView(LoginView):\n    def get_response(self):\n        # Get the serializer class for the response\n        serializer_class = self.get_response_serializer()\n\n        # Serialize the token\n        serializer = serializer_class(instance=self.token, context=self.get_serializer_context())\n\n        # Create tokens manually\n        user = self.user\n        refresh = RefreshToken.for_user(user)\n        access_token = str(refresh.access_token)\n        refresh_token = str(refresh)\n\n        # Prepare response data\n        response_data = {\n            'access': access_token,\n            'refresh': refresh_token,\n        }\n\n        # Return the custom response\n        response = Response(response_data, status=status.HTTP_200_OK)\n        return response\n</code></pre> <p>Update your <code>urls.py</code> to use the custom login view:</p> <pre><code>from django.urls import path, include\nfrom .views import CustomLoginView\n\nurlpatterns = [\n    path('api/auth/login/', CustomLoginView.as_view(), name='custom_login'),\n    path('api/auth/', include('dj_rest_auth.urls')),\n    path('api/auth/signup/', include('dj_rest_auth.registration.urls')),\n    # Other app URLs\n]\n</code></pre>"},{"location":"package/drf-rest-auth/#customizing-the-serializer-optional","title":"Customizing the Serializer (Optional)","text":"<p>If you need to customize the serializer used in LoginView, you can subclass the default serializer and override its methods. Here\u2019s an example:</p>"},{"location":"package/drf-rest-auth/#custom-serializer","title":"Custom Serializer","text":"<pre><code># serializers.py\n\nfrom dj_rest_auth.serializers import LoginSerializer\n\nclass CustomLoginSerializer(LoginSerializer):\n    def validate(self, attrs):\n        # Custom validation logic\n        data = super().validate(attrs)\n        # Add any custom response data here\n        return data\n</code></pre>"},{"location":"package/drf-rest-auth/#use-custom-serializer-in-custom-view","title":"Use Custom Serializer in Custom View","text":"<pre><code># views.py\n\nfrom .serializers import CustomLoginSerializer\n\nclass CustomLoginView(LoginView):\n    serializer_class = CustomLoginSerializer\n\n    def get_response(self):\n        # Custom response logic\n        ...\n</code></pre>"},{"location":"package/drf-rest-auth/#conclusion","title":"Conclusion","text":"<p>The serializer in dj-rest-auth's <code>LoginView</code> is used to convert the authentication token into a response format. In your CustomLoginView, you override this behavior to manually create JWT tokens and format the response data. If needed, you can also customize the serializer to add additional validation or response data.</p>"},{"location":"package/drf-rest-auth/#manually-token-creation-custom-serializer","title":"Manually Token Creation &amp; Custom Serializer","text":"Custom SerializerCustom View <p>If you still want to customize or add additional data using a serializer, you can do so by defining a custom serializer and using it to serialize additional user data. Here\u2019s how you can achieve that:</p> <pre><code># serializers.py\n\nfrom rest_framework import serializers\nfrom dj_rest_auth.serializers import LoginSerializer\n\nclass CustomLoginSerializer(LoginSerializer):\n    access = serializers.CharField(read_only=True)\n    refresh = serializers.CharField(read_only=True)\n\n    def validate(self, attrs):\n        data = super().validate(attrs)\n        user = self.user\n\n        # Manually create JWT tokens\n        refresh = RefreshToken.for_user(user)\n        data['access'] = str(refresh.access_token)\n        data['refresh'] = str(refresh)\n\n        # Add any custom response data here\n        return data\n</code></pre> <pre><code># views.py\n\nfrom .serializers import CustomLoginSerializer\n\nclass CustomLoginView(LoginView):\n    serializer_class = CustomLoginSerializer\n\n    def get_response(self):\n        serializer_class = self.get_response_serializer()\n        serializer = serializer_class(instance=self.token, context=self.get_serializer_context())\n\n        response_data = serializer.data\n        response = Response(response_data, status=status.HTTP_200_OK)\n        return response\n</code></pre> <p>Explanation</p> <ol> <li> <p>Custom Serializer:</p> <ul> <li>The <code>CustomLoginSerializer</code> subclass extends <code>LoginSerializer</code> and manually adds the access and refresh fields to the response data in the validate method.</li> </ul> </li> <li> <p>Use Custom Serializer in Custom View:</p> <ul> <li>In <code>CustomLoginView</code>, the custom serializer is specified by setting <code>serializer_class = CustomLoginSerializer</code>.</li> <li>The <code>get_response</code> method uses the custom serializer to serialize the response data.</li> </ul> </li> </ol> <p>By following this approach, you can customize the login response to include JWT tokens and any additional data you need. This method ensures that the response is serialized properly, adhering to the structure and validation rules defined in the custom serializer.</p>"},{"location":"package/drf-rest-auth/#reference","title":"Reference","text":"<ul> <li>dj_rest_auth (jwt) refresh token is empty when login - django rest framework</li> <li>What are the differences between these two plugins: dj-rest-auth vs djangorestframework-simplejwt ? : reddit</li> <li>dj-rest-auth: github</li> <li>How to implement jwt authentication using django rest auth?</li> <li>dj-rest: ACCOUNT_AUTHENTICATION_METHOD</li> <li>Django rest auth email instead of username: stackoverflow</li> <li>Django Part 3 - User authentication with dj-rest-auth and allauth </li> <li>dj-rest-auth: configuration</li> </ul>"},{"location":"package/drf-yasg/","title":"drf-yasg","text":"<pre><code>pip install drf-yasg\n</code></pre> <ol> <li> <p>Quickstart</p> <p>In <code>settings.py</code>:</p> <pre><code>INSTALLED_APPS = [\n    ...\n    'django.contrib.staticfiles',  # required for serving swagger ui's css/js files\n    'drf_yasg',\n    ...\n]\n</code></pre> <p>In <code>urls.py</code>:</p> <pre><code>...\nfrom django.urls import re_path\nfrom rest_framework import permissions\nfrom drf_yasg.views import get_schema_view\nfrom drf_yasg import openapi\n\n...\n\nschema_view = get_schema_view(\n    openapi.Info(\n        title=\"Snippets API\",\n        default_version='v1',\n        description=\"Test description\",\n        terms_of_service=\"https://www.google.com/policies/terms/\",\n        contact=openapi.Contact(email=\"contact@snippets.local\"),\n        license=openapi.License(name=\"BSD License\"),\n    ),\n    public=True,\n    permission_classes=(permissions.AllowAny,),\n)\n\nurlpatterns = [\n    path('swagger&lt;format&gt;/', schema_view.without_ui(cache_timeout=0), name='schema-json'),\n    path('swagger/', schema_view.with_ui('swagger', cache_timeout=0), name='schema-swagger-ui'),\n    path('redoc/', schema_view.with_ui('redoc', cache_timeout=0), name='schema-redoc'),\n    ...\n]\n</code></pre> </li> </ol> <p>This exposes 4 endpoints:</p> <ul> <li>A JSON view of your API specification at <code>/swagger.json</code></li> <li>A YAML view of your API specification at <code>/swagger.yaml</code></li> <li>A swagger-ui view of your API specification at <code>/swagger/</code></li> <li>A ReDoc view of your API specification at <code>/redoc/</code></li> </ul> <ul> <li>drf-yasg.readthedocs.io</li> </ul>"},{"location":"package/intro/","title":"Intro","text":"<p>Django Packages is a directory of reusable apps, sites, tools, and more for your Django projects.</p> <ul> <li>django-braces : Reusable, generic mixins for Django</li> </ul>"},{"location":"package/intro/#reference","title":"Reference","text":"<ul> <li>Django Packages</li> </ul>"},{"location":"package/pyjwt/","title":"pyjwt","text":"<p>Tip</p> <pre><code>pip install pyjwt\n</code></pre>"},{"location":"package/pyjwt/#refernce","title":"Refernce","text":"<ul> <li>pyjwt: readthedocs</li> </ul>"},{"location":"package/topic/","title":"Topic","text":"<p>In Django and Django REST Framework (DRF) development, there are several popular and widely-used packages that enhance functionality, streamline development, and integrate with other tools. Here\u2019s a list of some of the most popular packages:</p> <ol> <li> <p>Django Core Packages</p> <ul> <li> <p><code>django</code>:</p> <ul> <li>Purpose: Core Django framework.</li> <li>Installation: pip install django</li> <li>Documentation: Django Documentation</li> </ul> </li> <li> <p><code>django-environ</code>:</p> <ul> <li>Purpose: Allows for environment variable-based settings management.</li> <li>Installation: pip install django-environ</li> <li>Documentation: django-environ Documentation</li> </ul> </li> <li> <p><code>django-extensions</code>:</p> <ul> <li>Purpose: Provides additional management commands and utilities for Django.</li> <li>Installation: pip install django-extensions</li> <li>Documentation: django-extensions Documentation</li> </ul> </li> </ul> </li> <li> <p>Django REST Framework Packages</p> <ul> <li> <p><code>djangorestframework</code>:</p> <ul> <li>Purpose: Core package for building Web APIs with Django.</li> <li>Installation: pip install djangorestframework</li> <li>Documentation: DRF Documentation</li> </ul> </li> <li> <p><code>django-filter</code>:</p> <ul> <li>Purpose: Provides a way to filter querysets based on user input.</li> <li>Installation: pip install django-filter</li> <li>Documentation: django-filter Documentation</li> </ul> </li> <li> <p><code>django-cors-headers</code>:</p> <ul> <li>Purpose: Handles Cross-Origin Resource Sharing (CORS) to enable or restrict cross-site requests.</li> <li>Installation: pip install django-cors-headers</li> <li>Documentation: django-cors-headers Documentation</li> </ul> </li> <li> <p><code>djangorestframework-simplejwt</code>:</p> <ul> <li>Purpose: Provides JWT (JSON Web Token) authentication for DRF.</li> <li>Installation: pip install djangorestframework-simplejwt</li> <li>Documentation: Simple JWT Documentation</li> </ul> </li> <li> <p><code>django-rest-auth</code> (Note: django-rest-auth has been replaced by dj-rest-auth):</p> <ul> <li>Purpose: Provides endpoints for user authentication, registration, and password management.</li> <li>Installation: pip install dj-rest-auth</li> <li>Documentation: dj-rest-auth Documentation</li> </ul> </li> <li> <p><code>drf-yasg</code>:</p> <ul> <li>Purpose: Generates Swagger/OpenAPI documentation for DRF APIs.</li> <li>Installation: pip install drf-yasg</li> <li>Documentation: drf-yasg Documentation</li> </ul> </li> <li> <p><code>drf-spectacular</code>:</p> <ul> <li>Purpose: Another library for generating OpenAPI 3.0 documentation for DRF.</li> <li>Installation: pip install drf-spectacular</li> <li>Documentation: drf-spectacular Documentation</li> </ul> </li> </ul> </li> <li> <p>Database and Data Handling</p> <ul> <li> <p><code>django-crispy-forms</code>:</p> <ul> <li>Purpose: Provides a way to build better-looking forms with Django.</li> <li>Installation: pip install django-crispy-forms</li> <li>Documentation: django-crispy-forms Documentation</li> </ul> </li> <li> <p><code>django-taggit</code>:</p> <ul> <li>Purpose: Provides a simple tagging system for Django models.</li> <li>Installation: pip install django-taggit</li> <li>Documentation: django-taggit Documentation</li> </ul> </li> <li> <p><code>django-allauth</code>:</p> <ul> <li>Purpose: Provides integrated authentication, registration, and account management.</li> <li>Installation: pip install django-allauth</li> <li>Documentation: django-allauth Documentation</li> </ul> </li> </ul> </li> <li> <p>Deployment and Performance</p> <ul> <li> <p><code>gunicorn</code>:</p> <ul> <li>Purpose: A Python WSGI HTTP server for UNIX. Useful for deploying Django applications.</li> <li>Installation: pip install gunicorn</li> <li>Documentation: Gunicorn Documentation</li> </ul> </li> <li> <p><code>django-storages</code>:</p> <ul> <li>Purpose: Provides a way to store files in various backends, such as Amazon S3.</li> <li>Installation: pip install django-storages</li> <li>Documentation: django-storages Documentation</li> </ul> </li> <li> <p><code>whitenoise</code>:</p> <ul> <li>Purpose: Serves static files efficiently.</li> <li>Installation: pip install whitenoise</li> <li>Documentation: Whitenoise Documentation</li> </ul> </li> </ul> </li> <li> <p>Testing</p> <ul> <li> <p><code>pytest-django</code>:</p> <ul> <li>Purpose: Provides Django-specific testing tools for pytest.</li> <li>Installation: pip install pytest-django</li> <li>Documentation: pytest-django Documentation</li> </ul> </li> <li> <p><code>factory_boy</code>:</p> <ul> <li>Purpose: A flexible and easy-to-use library for creating test fixtures.</li> <li>Installation: pip install factory_boy</li> <li>Documentation: factory_boy Documentation</li> </ul> </li> </ul> </li> </ol>"},{"location":"package/topic/#additional-tips","title":"Additional Tips","text":"<ul> <li>Keep Your Environment Updated: Regularly check for updates and new versions of these packages to ensure compatibility and security.</li> <li>Leverage Community Resources: Participate in forums, GitHub discussions, and read blog posts to stay updated with best practices and new tools.</li> <li>Build Real Projects: Apply your knowledge by building projects and contributing to open-source to deepen your understanding and gain practical experience.</li> </ul> <p>By focusing on these packages and tools, you can enhance your Django and DRF development workflow and build more robust and feature-rich applications.</p>"},{"location":"python/args/","title":"Args","text":""},{"location":"python/args/#understanding-args-and-kwargs-in-python","title":"Understanding Args and Kwargs in Python","text":""},{"location":"python/args/#what-are-args","title":"What are Args?\"","text":"<ol> <li>*args are used to pass non-keyword arguments. Examples of non-keyword arguments are fun(12,14), fun(\u201cvalue1\u201d,\u201cvalue2\u201d).</li> <li>*args are usually used to prevent the program from crashing. If we do not know, numerous parameters will be passed to the function. This is used in other programming languages.</li> </ol> <p>It makes it easy to use any number of arguments without having to change your code. It provides more flexibility to your code since you can have as many arguments as you wish in the future.</p> <p>Example</p> <pre><code>def func(*args):\n    for arg in args:\n        print(arg)\n    func(11,22,33,\"Django\",\"Python\")\nlist = [11,22,33,\"Django\",\"Python\"]\n\nfunc(list)\n</code></pre> <pre><code>#OUTPUT\n11\n22\n33\nDjango\nPython\n\n#List\n[11, 22, 33, 'Django', 'Python']\n</code></pre>"},{"location":"python/args/#what-are-kwargs","title":"What are Kwargs?","text":"<p>**kwargs is a dictionary of keyword arguments. The double asterisk (<code>**</code>) symbol allows us to pass any number of arguments. A keyword argument is usually a dictionary.</p> <p>Here an example of a keyword argument is fun(a=1,b=17).</p> <p>Tips</p> <p>**kwargs are similar to *args, except you declare the variables and the amount within the same function arguments.</p>"},{"location":"python/args/#use-of-args-and-kwargs","title":"Use of Args and Kwargs","text":"<p>Args and kwargs are handy when you need to:</p> <ul> <li>Pass multiple arguments in functions</li> <li>Reduce code writing</li> <li>Make your code more readable</li> <li>Reuse the piece of code</li> </ul>"},{"location":"python/args/#using-both-args-and-kwargs-in-a-function","title":"Using Both Args and Kwargs in a Function","text":"<p>When using both args and kwargs in the same function definition, *args must occur before **kwargs.</p> <pre><code>def __init__(self, *args, **kwargs):\n</code></pre>"},{"location":"python/args/#reference","title":"Reference","text":"<ul> <li>Mastering Django A Beginner\u2019s Guide Edited by Sufyan bin Uzayr - <code>pg: 178</code></li> </ul>"},{"location":"python/content-management-system/","title":"CMS","text":""},{"location":"python/content-management-system/#content-management-system","title":"Content Management System","text":"<pre><code>pip install wagtail\nwagtail start mysite\ncd mysite\npip install -r requirements.txt\npython manage.py migrate\npython manage.py createsuperuser\npython manage.py runserver\n</code></pre>"},{"location":"python/content-management-system/#reference","title":"Reference","text":"<ul> <li> <p>List of content management system: wikipedia</p> </li> <li> <p>wagtail.org - official</p> </li> <li>wagtail: github</li> </ul>"},{"location":"blog/archive/2024/","title":"2024","text":""},{"location":"blog/page/2/","title":"Index","text":""},{"location":"blog/page/3/","title":"Index","text":""},{"location":"blog/page/4/","title":"Index","text":""},{"location":"blog/page/5/","title":"Index","text":""},{"location":"blog/page/6/","title":"Index","text":""},{"location":"blog/page/7/","title":"Index","text":""},{"location":"blog/page/8/","title":"Index","text":""},{"location":"blog/page/9/","title":"Index","text":""},{"location":"blog/archive/2024/page/2/","title":"2024","text":""},{"location":"blog/archive/2024/page/3/","title":"2024","text":""},{"location":"blog/archive/2024/page/4/","title":"2024","text":""},{"location":"blog/archive/2024/page/5/","title":"2024","text":""},{"location":"blog/archive/2024/page/6/","title":"2024","text":""},{"location":"blog/archive/2024/page/7/","title":"2024","text":""},{"location":"blog/archive/2024/page/8/","title":"2024","text":""},{"location":"blog/archive/2024/page/9/","title":"2024","text":""}]}